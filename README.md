# Parserator

> **Warning**
> This library is currently in early development and the API is subject to change. There are *several* bugs. Please don't use, even at your own risk. I am absolutely responsible for any bugs, so holler at me at [@texoport.in](https://bsky.app/profile/texoport.in).

> **Warning**
> This *temporary* readme was generated by an LLM. 

A TypeScript parser combinator library inspired by [Parsec](https://github.com/haskell/parsec) and [Effect-TS](https://github.com/Effect-ts/Effect). Write parsers using a clean, generator-based syntax or compose them using functional combinators.

## Features

* ðŸŽ¯ **Generator Syntax**: Write parsers using a clean, async-like syntax
* ðŸ”§ **Functional Combinators**: Compose parsers using functional programming patterns
* ðŸŽ­ **Type-Safe**: Full TypeScript support with precise type inference
* ðŸ“¦ **Zero Dependencies**: No external dependencies, just pure TypeScript
* ðŸ› **Great Error Messages**: Helpful error messages with source positions
* ðŸš€ **Fast?**: I wouldn't know, this could be the slowest thing in the known universe.

## Installation

```bash
npm install parserator
```

## Quick Start

### Generator Syntax

Write parsers using a clean, generator-based syntax that feels like async/await:

```typescript
import { Parser, char, many1, digit, optional } from 'parserator'

// Parse a floating point number
const float = Parser.gen(function* () {
  const sign = yield* optional(char("-"))
  const intPart = yield* many1(digit)
  const fractionalPart = yield* optional(
    Parser.gen(function* () {
      yield* char(".")
      return yield* many1(digit)
    })
  )
  const exponentPart = yield* optional(
    Parser.gen(function* () {
      yield* char("e")
      const expSign = yield* optional(char("+") || char("-"))
      const expDigits = yield* many1(digit)
      return (expSign ?? "") + expDigits.join("")
    })
  )

  const numStr = 
    (sign ?? "") + 
    intPart.join("") + 
    (fractionalPart ? "." + fractionalPart.join("") : "") +
    (exponentPart ? "e" + exponentPart : "")

  return parseFloat(numStr)
})

float.run("123.456e-7") // Right([1.23456e-5, ...])
float.run("abc") // Left(ParserError: Expected digit but found 'a')
```

### Core Combinators

Parserator provides a rich set of combinators for building complex parsers:

#### Basic Parsers

* `char(c)`: Match a single character
  

```typescript
  char("a").run("abc") // Right(["a", ...])
  ```

* `string(s)`: Match an exact string
  

```typescript
  string("hello").run("hello world") // Right(["hello", ...])
  ```

* `regex(re)`: Match a regular expression at the start of input
  

```typescript
  regex(/[0-9]+/).run("123abc") // Right(["123", ...])
  ```

* `alphabet`: Match any alphabetic character (a-z, A-Z)
  

```typescript
  alphabet.run("abc") // Right(["a", ...])
  ```

* `digit`: Match any digit (0-9)
  

```typescript
  digit.run("123") // Right(["1", ...])
  ```

#### Repetition

* `many0(parser)`: Match zero or more occurrences
  

```typescript
  many0(digit).run("123abc") // Right([["1","2","3"], ...])
  ```

* `many1(parser)`: Match one or more occurrences
  

```typescript
  many1(digit).run("123abc") // Right([["1","2","3"], ...])
  ```

* `manyN(parser, n)`: Match exactly n occurrences
  

```typescript
  manyN(digit, 2).run("123") // Right([["1","2"], ...])
  ```

#### Combinators

* `optional(parser)`: Make a parser optional
  

```typescript
  optional(char("-")).run("123") // Right([undefined, ...])
  ```

* `or(...parsers)`: Try multiple parsers in order
  

```typescript
  or(char("a"), char("b")).run("abc") // Right(["a", ...])
  ```

* `sequence([parser1, parser2, ...])`: Run parsers in sequence
  

```typescript
  sequence([char("a"), char("b")]).run("abc") // Right(["b", ...])
  ```

* `between(start, end, parser)`: Match content between delimiters
  

```typescript
  between(char("("), char(")"), digit).run("(5)") // Right(["5", ...])
  ```

* `sepBy(separator, parser)`: Match items separated by a separator
  

```typescript
  sepBy(char(","), digit).run("1,2,3") // Right([["1","2","3"], ...])
  ```

#### Look-ahead and Skipping

* `lookAhead(parser)`: Look ahead without consuming input
  

```typescript
  lookAhead(char("a")).run("abc") // Right(["a", ...]) // Position stays at "abc"
  ```

* `skipSpaces`: Skip any number of space characters
  

```typescript
  skipSpaces.then(char("a")).run("   abc") // Right(["a", ...])
  ```

### Error Handling

Parsers can be customized with error messages and callbacks:

```typescript
const parser = many1(digit).error("Expected at least one digit")
  .errorCallback((error, state) => {
    return `Error at line ${state.pos.line}, column ${state.pos.column}: ${error.message}`
  })
```

### Debugging

Debug tools help inspect parser behavior:

```typescript
import { debug, trace } from 'parserator'

const debuggedParser = debug(parser, "number-parser")
const tracedParser = trace("Before parsing number").then(parser)
```

### Advanced Examples

#### JSON Array Parser

```typescript
const jsonArray = Parser.gen(function* () {
  yield* char("[")
  yield* skipSpaces
  const items = yield* sepBy(
    char(","),
    Parser.gen(function* () {
      yield* skipSpaces
      const value = yield* or(stringParser, numberParser)
      yield* skipSpaces
      return value
    })
  )
  yield* skipSpaces
  yield* char("]")
  return items
})

jsonArray.run('["hello", 123, "world"]')
```

#### Length-Prefixed List Parser

```typescript
const lengthPrefixedList = Parser.gen(function* () {
  const length = yield* numberParser
  yield* skipSpaces
  yield* char("[")
  const items = yield* manyN(stringParser, length, char(","))
  yield* char("]")
  
  if (items.length !== length) {
    return yield* Parser.fail("Length mismatch")
  }
  return items
})

lengthPrefixedList.run('2 ["foo", "bar"]') // Right([["foo", "bar"], ...])
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT
