This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-17T06:16:16.017Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
examples/
  scheme/
    ast.ts
    example.ts
    parser.ts
    scheme.test.ts
src/
  chain.ts
  combinators.ts
  debug.ts
  either.ts
  errors.ts
  index.ts
  parser.ts
  state.ts
  types.ts
  utils.ts
tests/
  combinators.test.ts
  either.test.ts
.gitignore
.npmignore
biome.json
build.ts
index.ts
LICENSE
package.json
README.md
tsconfig.json
tsconfig.types.json
tsup.config.ts
typedoc.json

================================================================
Files
================================================================

================
File: examples/scheme/ast.ts
================
export namespace LispExpr {
	export type LispExpr =
		| Symbol
		| Number
		| String
		| Boolean
		| List
		| If
		| Lambda
		| Let

	export type Symbol = {
		readonly type: "Symbol"
		name: string
	}

	export type Number = {
		readonly type: "Number"
		value: number
	}

	export type String = {
		readonly type: "String"
		value: string
	}

	export type Boolean = {
		readonly type: "Boolean"
		value: boolean
	}

	export type List = {
		readonly type: "List"
		items: LispExpr[]
	}

	export type If = {
		readonly type: "If"
		condition: LispExpr
		consequent: LispExpr
		alternate: LispExpr
	}

	export type Lambda = {
		readonly type: "Lambda"
		params: string[]
		body: LispExpr
	}

	export type Let = {
		readonly type: "Let"
		bindings: Array<{ name: string; value: LispExpr }>
		body: LispExpr
	}
}

export const LispExpr = {
	symbol: (name: string): LispExpr.LispExpr => ({
		type: "Symbol",
		name,
	}),

	number: (value: number): LispExpr.LispExpr => ({
		type: "Number",
		value,
	}),

	string: (value: string): LispExpr.LispExpr => ({
		type: "String",
		value,
	}),

	bool: (value: boolean): LispExpr.LispExpr => ({
		type: "Boolean",
		value,
	}),

	list: (items: LispExpr.LispExpr[]): LispExpr.LispExpr => ({
		type: "List",
		items,
	}),

	if: (
		condition: LispExpr.LispExpr,
		consequent: LispExpr.LispExpr,
		alternate: LispExpr.LispExpr,
	): LispExpr.LispExpr => ({
		type: "If",
		condition,
		consequent,
		alternate,
	}),

	lambda: (params: string[], body: LispExpr.LispExpr): LispExpr.LispExpr => ({
		type: "Lambda",
		params,
		body,
	}),

	let: (
		bindings: Array<{
			name: string
			value: LispExpr.LispExpr
		}>,
		body: LispExpr.LispExpr,
	): LispExpr.LispExpr => ({
		type: "Let",
		bindings,
		body,
	}),
}

================
File: examples/scheme/example.ts
================
import { ParserError } from "../../src"
import { lispParser } from "./parser"

const program = `(+ 5 (+ 3 5))`

const result = lispParser.parseOrError(program)
if (result instanceof ParserError) {
	console.error(result.message)
} else {
	console.log(JSON.stringify(result, null, 2))
}

================
File: examples/scheme/parser.ts
================
import {
	Parser,
	State,
	char,
	parser,
	digit,
	many0,
	many1,
	optional,
	or,
	skipMany0,
	string,
	takeUpto,
} from "../../src"
import { peekAhead, peekState } from "../../src/utils"
import { LispExpr } from "./ast"

const whitespace = skipMany0(or(char(" "), char("\n"), char("\t")))
const optionalWhitespace = optional(whitespace)

export let expr: Parser<LispExpr.LispExpr>

const symbol = parser(function* () {
	yield* optionalWhitespace
	const name = yield* takeUpto(
		or(char(" "), char("\n"), char("\t"), char(")"), char("(")),
	)
	yield* optionalWhitespace
	if (name === "") return yield* Parser.error("Empty symbol")
	return LispExpr.symbol(name)
})

const number = parser(function* () {
	const sign = (yield* optional(char("-"))) ?? ""
	const digits = yield* many1(digit)
	const value = parseInt(sign + digits.join(""))
	return LispExpr.number(value)
})

const stringLiteral = parser(function* () {
	yield* char('"')
	const value = yield* takeUpto(char('"'))
	yield* char('"')
	return LispExpr.string(value)
})

const boolean = parser(function* () {
	const val = yield* or(string("#t"), string("#f"))
	return LispExpr.bool(val === "#t")
})

const atom = parser(function* () {
	const atom = yield* or(boolean, number, stringLiteral, symbol)
	return atom
})

const list = parser(function* () {
	yield* char("(")
	yield* optionalWhitespace

	const items = yield* many0(expr)
	if (items.length === 0) {
		return yield* Parser.error("Empty list")
	}

	yield* optionalWhitespace
	yield* char(")").withError(() => "list should be closed")
	return items
})

const listParser = list.flatMap((list) =>
	parser(function* () {
		if (list.length === 3) {
			const [first, paramsExpr, bodyExpr] = list
			if (first.type === "Symbol" && paramsExpr.type === "List") {
				if (first.name === "lambda") {
					return yield* lambdaParser(paramsExpr, bodyExpr)
				}
				if (first.name === "let") {
					return yield* letParser(paramsExpr, bodyExpr)
				}
			}
		}
		return LispExpr.list(list)
	}),
)

const lambdaParser = (paramsExpr: LispExpr.List, bodyExpr: LispExpr.LispExpr) =>
	parser(function* () {
		const params: string[] = []
		for (const item of paramsExpr.items) {
			if (item.type !== "Symbol") {
				return yield* Parser.error(
					"Invalid param definition for lambda expression",
				)
			}
			params.push(item.name)
		}

		return LispExpr.lambda(params, bodyExpr)
	})

const letParser = (bindingsExpr: LispExpr.List, bodyExpr: LispExpr.LispExpr) =>
	parser(function* () {
		const bindings: LispExpr.Let["bindings"] = []
		for (const item of bindingsExpr.items) {
			if (!(item.type === "List" && item.items.length === 2)) {
				return yield* Parser.error("Invalid let expression")
			}
			const [keyExpr, valExpr] = item.items
			if (keyExpr.type !== "Symbol") {
				return yield* Parser.error("Invalid let expression")
			}

			bindings.push({
				name: keyExpr.name,
				value: valExpr,
			})
		}

		return LispExpr.let(bindings, bodyExpr)
	})

expr = Parser.lazy(() =>
	parser(function* () {
		yield* optionalWhitespace
		const state = yield* peekState
		const isList = yield* peekAhead(1).map((x) => x === "(")
		const result = yield* isList ? listParser : atom
		yield* optionalWhitespace
		return result
	}),
)

//export const lispParser = many0(whitespace.then(expr).thenDiscard(whitespace))

export const lispParser = expr

================
File: examples/scheme/scheme.test.ts
================
import { describe, expect, it } from "bun:test"
import { LispExpr } from "./ast"
import { expr } from "./parser"

describe("scheme", () => {
	it("should parse a simple expression", () => {
		const result = expr.parseOrThrow("(+ 1 2)")
		expect(result).toEqual(
			LispExpr.list([
				LispExpr.symbol("+"),
				LispExpr.number(1),
				LispExpr.number(2),
			]),
		)
	})

	it("should parse a nested expression", () => {
		const result = expr.parseOrThrow("(+ 1 (+ 2 3))")
		expect(result).toEqual(
			LispExpr.list([
				LispExpr.symbol("+"),
				LispExpr.number(1),
				LispExpr.list([
					LispExpr.symbol("+"),
					LispExpr.number(2),
					LispExpr.number(3),
				]),
			]),
		)
	})

	it("should parse a string literal", () => {
		const result = expr.parseOrThrow('"hello"')
		expect(result).toEqual(LispExpr.string("hello"))
	})

	it("should parse a boolean literal", () => {
		const result1 = expr.parseOrThrow("#t")
		expect(result1).toEqual(LispExpr.bool(true))
		const result2 = expr.parseOrThrow("#f")
		expect(result2).toEqual(LispExpr.bool(false))
	})

	it("should parse a symbol", () => {
		const result = expr.parseOrThrow("hello")
		expect(result).toEqual(LispExpr.symbol("hello"))
	})

	it("should parse a symbol with special characters", () => {
		const result = expr.parseOrThrow("hello-world!")
		expect(result).toEqual(LispExpr.symbol("hello-world!"))
	})

	it("should fail on empty symbol", () => {
		const { result } = expr.parse("")
		expect(result._tag).toEqual("Left")
	})

	it("should parse a list", () => {
		const result = expr.parseOrThrow("(1 2 3)")
		expect(result).toEqual(
			LispExpr.list([
				LispExpr.number(1),
				LispExpr.number(2),
				LispExpr.number(3),
			]),
		)
	})

	it("should fail on empty list", () => {
		const { result } = expr.parse("()")
		expect(result._tag).toEqual("Left")
	})

	it("should parse a let expression with multiple bindings", () => {
		const result = expr.parseOrThrow("(let ((x 1) (y 2)) (+ x y))")
		expect(result).toEqual(
			LispExpr.let(
				[
					{ name: "x", value: LispExpr.number(1) },
					{ name: "y", value: LispExpr.number(2) },
				],
				LispExpr.list([
					LispExpr.symbol("+"),
					LispExpr.symbol("x"),
					LispExpr.symbol("y"),
				]),
			),
		)
	})

	it("should parse a let expression with a nested let expression", () => {
		const result = expr.parseOrThrow("(let ((x 1)) (let ((y 2)) (+ x y)))")
		expect(result).toEqual(
			LispExpr.let(
				[{ name: "x", value: LispExpr.number(1) }],
				LispExpr.let(
					[{ name: "y", value: LispExpr.number(2) }],
					LispExpr.list([
						LispExpr.symbol("+"),
						LispExpr.symbol("x"),
						LispExpr.symbol("y"),
					]),
				),
			),
		)
	})

	it("should parse a lambda expression", () => {
		const result = expr.parseOrThrow("(lambda (x) (+ x 2))")
		expect(result).toEqual(
			LispExpr.lambda(
				["x"],
				LispExpr.list([
					LispExpr.symbol("+"),
					LispExpr.symbol("x"),
					LispExpr.number(2),
				]),
			),
		)
	})

	it("should parse a let expression with a lambda expression", () => {
		const result = expr.parseOrThrow("(let ((x (lambda (y) y))) (x))")
		expect(result).toEqual(
			LispExpr.let(
				[
					{
						name: "x",
						value: LispExpr.lambda(["y"], LispExpr.symbol("y")),
					},
				],
				LispExpr.list([LispExpr.symbol("x")]),
			),
		)
	})

	it("should parse a list", () => {
		const result = expr.parseOrThrow("(a b c)")
		expect(result).toEqual(
			LispExpr.list([
				LispExpr.symbol("a"),
				LispExpr.symbol("b"),
				LispExpr.symbol("c"),
			]),
		)
	})

	it("should parse a let expression with a single binding", () => {
		const result = expr.parseOrThrow("(let ((x 1)) x)")
		expect(result).toEqual(
			LispExpr.let(
				[{ name: "x", value: LispExpr.number(1) }],
				LispExpr.symbol("x"),
			),
		)
	})
})

================
File: src/chain.ts
================
import { Either } from "./either"
import { Parser } from "./parser"

export type Chain<Ctx = {}> = {
	<T, U>(parser: Parser<T, Ctx>, fn1: (value: T) => Parser<U>): Parser<U>
	<T1, T2, T3>(
		parser: Parser<T1, Ctx>,
		fn1: (value: T1) => Parser<T2, Ctx>,
		fn2: (value: T2) => Parser<T3, Ctx>,
	): Parser<T3>
	<T1, T2, T3, T4>(
		parser: Parser<T1, Ctx>,
		fn1: (value: T1) => Parser<T2, Ctx>,
		fn2: (value: T2) => Parser<T3, Ctx>,
		fn3: (value: T3) => Parser<T4, Ctx>,
	): Parser<T4>
	<T1, T2, T3, T4, T5>(
		parser: Parser<T1, Ctx>,
		fn1: (value: T1) => Parser<T2, Ctx>,
		fn2: (value: T2) => Parser<T3, Ctx>,
		fn3: (value: T3) => Parser<T4, Ctx>,
		fn4: (value: T4) => Parser<T5, Ctx>,
	): Parser<T5>
	<T1, T2, T3, T4, T5, T6>(
		parser: Parser<T1, Ctx>,
		fn1: (value: T1) => Parser<T2, Ctx>,
		fn2: (value: T2) => Parser<T3, Ctx>,
		fn3: (value: T3) => Parser<T4, Ctx>,
		fn4: (value: T4) => Parser<T5, Ctx>,
		fn5: (value: T5) => Parser<T6, Ctx>,
	): Parser<T6>
	<T1, T2, T3, T4, T5, T6, T7>(
		parser: Parser<T1, Ctx>,
		fn1: (value: T1) => Parser<T2, Ctx>,
		fn2: (value: T2) => Parser<T3, Ctx>,
		fn3: (value: T3) => Parser<T4, Ctx>,
		fn4: (value: T4) => Parser<T5, Ctx>,
		fn5: (value: T5) => Parser<T6, Ctx>,
		fn6: (value: T6) => Parser<T7, Ctx>,
	): Parser<T7>
	<T1, T2, T3, T4, T5, T6, T7, T8>(
		parser: Parser<T1, Ctx>,
		fn1: (value: T1) => Parser<T2, Ctx>,
		fn2: (value: T2) => Parser<T3, Ctx>,
		fn3: (value: T3) => Parser<T4, Ctx>,
		fn4: (value: T4) => Parser<T5, Ctx>,
		fn5: (value: T5) => Parser<T6, Ctx>,
		fn6: (value: T6) => Parser<T7, Ctx>,
		fn7: (value: T7) => Parser<T8, Ctx>,
	): Parser<T8>
	<T1, T2, T3, T4, T5, T6, T7, T8, T9>(
		parser: Parser<T1, Ctx>,
		fn1: (value: T1) => Parser<T2, Ctx>,
		fn2: (value: T2) => Parser<T3, Ctx>,
		fn3: (value: T3) => Parser<T4, Ctx>,
		fn4: (value: T4) => Parser<T5, Ctx>,
		fn5: (value: T5) => Parser<T6, Ctx>,
		fn6: (value: T6) => Parser<T7, Ctx>,
		fn7: (value: T7) => Parser<T8, Ctx>,
		fn8: (value: T8) => Parser<T9, Ctx>,
	): Parser<T9>
	<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
		parser: Parser<T1, Ctx>,
		fn1: (value: T1) => Parser<T2, Ctx>,
		fn2: (value: T2) => Parser<T3, Ctx>,
		fn3: (value: T3) => Parser<T4, Ctx>,
		fn4: (value: T4) => Parser<T5, Ctx>,
		fn5: (value: T5) => Parser<T6, Ctx>,
		fn6: (value: T6) => Parser<T7, Ctx>,
		fn7: (value: T7) => Parser<T8, Ctx>,
		fn8: (value: T8) => Parser<T9, Ctx>,
		fn9: (value: T9) => Parser<T10, Ctx>,
	): Parser<T10>
}

export const chain = <Ctx = {}>(
	parser: Parser<any, Ctx>,
	...fns: Array<(value: any) => Parser<any, Ctx>>
): Chain<Ctx> => {
	return new Parser<any, Ctx>((state) => {
		let result = parser.run(state)
		for (const fn of fns) {
			const { result: parserResult, state: newState } = result
			if (Either.isLeft(parserResult)) {
				return Parser.fail(parserResult.left, newState)
			}
			const value = parserResult.right
			result = fn(value).run(newState)
		}
		return result
	}) as any
}

================
File: src/combinators.ts
================
import { Either } from "./either"
import { Parser } from "./parser"
import { type ParserState, State } from "./state"

/**
 * Creates a parser that looks ahead in the input stream without consuming any input.
 * The parser will succeed with the result of the given parser but won't advance the input position.
 *
 * @param parser - The parser to look ahead with
 * @returns A new parser that peeks at the input without consuming it
 * ```ts
 * const parser = lookAhead(char('a'))
 * parser.run('abc') // Right(['a', {...}])
 * // Input position remains at 'abc', 'a' is not consumed
 * ```
 */
export function lookAhead<T, Ctx = {}>(
	parser: Parser<T, Ctx>,
): Parser<T | undefined, Ctx> {
	return new Parser((state) => {
		const { result } = parser.run(state)
		if (Either.isRight(result)) {
			return Parser.succeed(result.right, state)
		}
		return Parser.succeed(undefined, state)
	})
}

/**
 * Creates a parser that succeeds only if the given parser fails to match.
 * If the parser succeeds, this parser fails with an error message.
 *
 * @param parser - The parser that should not match
 * @returns A new parser that succeeds only if the input parser fails
 * ```ts
 * const notA = notFollowedBy(char('a'))
 * notA.run('bcd') // Right([true, {...}]) - Succeeds because 'a' is not found
 * notA.run('abc') // Left(error) - Fails because 'a' is found
 * ```
 */
export function notFollowedBy<T, Ctx = {}>(
	parser: Parser<T, Ctx>,
): Parser<boolean, Ctx> {
	return new Parser((state) => {
		const { result, state: newState } = parser.run(state)
		if (Either.isRight(result)) {
			if (parser.options?.name) {
				const message = `Found ${parser.options.name} when it should not appear here`
				return Parser.fail({ message, expected: [] }, newState)
			}
			return Parser.fail(
				{
					message: "Expected not to follow",
					expected: [],
					found: state.remaining.at(0),
				},
				newState,
			)
		}
		return Parser.succeed(true, newState)
	})
}

/**
 * Creates a parser that matches an exact string in the input.
 *
 * @param str - The string to match
 * @returns A parser that matches and consumes the exact string
 * ```ts
 * const parser = string("hello")
 * parser.run("hello world") // Right(["hello", {...}])
 * parser.run("goodbye") // Left(error)
 * ```
 */
export const string = <Ctx = {}>(str: string): Parser<string, Ctx> =>
	new Parser(
		(state) => {
			if (state.remaining.startsWith(str)) {
				return Parser.succeed(str, State.consume(state, str.length))
			}

			const message =
				`Expected '${str}', ` +
				`but found '${state.remaining.slice(0, str.length)}'`

			return Parser.fail(
				{
					message,
					expected: [str],
					found: state.remaining.slice(0, str.length),
				},
				state,
			)
		},
		{ name: str },
	)

/**
 * Creates a parser that matches an exact string literal type.
 * Similar to string parser but preserves the literal type information.
 *
 * @param str - The string literal to match
 * @returns A parser that matches and consumes the exact string with preserved type
 * ```ts
 * const parser = narrowedString("hello") // Parser<"hello">
 * parser.run("hello world") // Right(["hello", {...}])
 * parser.run("goodbye") // Left(error)
 * ```
 */
export function narrowedString<const T extends string, Ctx>(
	str: T,
): Parser<T, Ctx> {
	return string(str) as any
}

/**
 * Creates a parser that matches a single character.
 *
 * @param ch - The character to match
 * @returns A parser that matches and consumes a single character
 * ```ts
 * const parser = char("a")
 * parser.run("abc") // Right(["a", {...}])
 * parser.run("xyz") // Left(error)
 * ```
 */
export const char = <T extends string, Ctx = {}>(ch: T): Parser<T, Ctx> => {
	return new Parser(
		(state) => {
			if (ch.length !== 1) {
				return Parser.fail(
					{ message: "Incorrect usage of char parser.", expected: [ch] },
					state,
				)
			}
			if (state.remaining[0] === ch) {
				return Parser.succeed(ch, State.consume(state, 1))
			}

			const message = `Expected ${ch} but found ${state.remaining.at(0)}.`
			return Parser.fail(
				{ message, expected: [ch], found: state.remaining.at(0) },
				state,
			)
		},
		{ name: ch },
	)
}

/**
 * A parser that matches any single alphabetic character (a-z, A-Z).
 *
 * ```ts
 * const parser = alphabet
 * parser.run("abc") // Right(["a", {...}])
 * parser.run("123") // Left(error)
 * ```
 */
export const alphabet = new Parser(
	(state) => {
		if (State.isAtEnd(state)) {
			return Parser.fail(
				{ message: "Unexpected end of input", expected: [] },
				state,
			)
		}
		const first = state.remaining[0]
		if (first && /^[a-zA-Z]$/.test(first)) {
			return Parser.succeed(first, State.consume(state, 1))
		}
		const message = `Expected alphabetic character, but got '${first}'`
		return Parser.fail(
			{ message, expected: [], found: state.remaining[0] },
			state,
		)
	},
	{ name: "alphabet" },
)

/**
 * A parser that matches any single digit character (0-9).
 *
 * ```ts
 * const parser = digit
 * parser.run("123") // Right(["1", {...}])
 * parser.run("abc") // Left(error)
 * ```
 */
export const digit = new Parser(
	(state) => {
		if (State.isAtEnd(state)) {
			return Parser.fail(
				{ message: "Unexpected end of input", expected: [] },
				state,
			)
		}
		const first = state.remaining[0]
		if (first && /^[0-9]$/.test(first)) {
			return Parser.succeed(first, State.consume(state, 1))
		}
		const message = `Expected digit, but got '${first}'`
		return Parser.fail(
			{ message, expected: [], found: state.remaining[0] },
			state,
		)
	},
	{ name: "digit" },
)

/**
 * Creates a parser that matches zero or more occurrences of elements separated by a separator.
 *
 * @param sepParser - Parser for the separator between elements
 * @param parser - Parser for the elements
 * @returns A parser that produces an array of matched elements
 *
 * ```ts
 * const parser = sepBy(char(','), digit)
 * parser.run("1,2,3") // Right([["1", "2", "3"], {...}])
 * parser.run("") // Right([[], {...}])
 * ```
 */
// TODO: fix this
export function sepBy<S, T, Ctx>(
	sepParser: Parser<S, Ctx>,
	parser: Parser<T, Ctx>,
): Parser<T[], Ctx> {
	return new Parser((state) => {
		const results: T[] = []
		let currentState = state

		const { result: firstResult, state: firstState } = parser.run(currentState)
		if (Either.isLeft(firstResult)) {
			return Parser.fail(firstResult.left, firstState)
		}

		results.push(firstResult.right)
		currentState = firstState

		while (true) {
			const { result: sepResult, state: sepState } = sepParser.run(currentState)
			if (Either.isLeft(sepResult)) {
				break
			}
			currentState = sepState

			const { result: itemResult, state: itemResultState } =
				parser.run(currentState)
			if (Either.isLeft(itemResult)) {
				return Parser.fail(itemResult.left, itemResultState)
			}
			results.push(itemResult.right)
			currentState = itemResultState
		}

		return Parser.succeed(results, currentState)
	})
}

/**
 * Creates a parser that matches content between two string delimiters.
 *
 * @param start - The opening delimiter string
 * @param end - The closing delimiter string
 * @param parser - The parser for the content between delimiters
 * @returns A parser that matches content between delimiters
 *
 * ```ts
 * const parser = between('(', ')', digit)
 * parser.run('(5)') // Right(['5', {...}])
 * parser.run('5') // Left(error)
 * ```
 */
export function between<T, Ctx = {}>(
	start: Parser<any, Ctx>,
	end: Parser<any, Ctx>,
	parser: Parser<T, Ctx>,
): Parser<any, Ctx> {
	return new Parser((state) => {
		// Parse opening delimiter
		const startResult = start.run(state)
		if (Either.isLeft(startResult.result)) {
			return startResult
		}

		// Parse content
		const contentResult = parser.run(startResult.state)
		if (Either.isLeft(contentResult.result)) {
			return contentResult
		}

		// Parse closing delimiter
		const endResult = end.run(contentResult.state)
		if (Either.isLeft(endResult.result)) {
			return endResult
		}

		// Return the content and final state
		return Parser.succeed(contentResult.result.right, endResult.state)
	})
}

export function anyChar<Ctx = {}>() {
	return new Parser<string, Ctx>((state) => {
		if (State.isAtEnd(state)) {
			return Parser.fail(
				{ message: "Unexpected end of input", expected: [] },
				state,
			)
		}
		return Parser.succeed(state.remaining[0], State.consume(state, 1))
	})
}

/**
 * Internal helper function for creating repetition parsers.
 *
 * @param count - Minimum number of repetitions required
 * @returns A function that creates a parser matching multiple occurrences
 */
function many_<S, T, Ctx = {}>(count: number) {
	return (
		parser: Parser<T, Ctx>,
		separator?: Parser<S, Ctx>,
	): Parser<T[], Ctx> => {
		return new Parser((state) => {
			const results: T[] = []
			let currentState = state

			while (true) {
				// Try to parse the next item
				const itemResult = parser.run(currentState)
				if (Either.isLeft(itemResult.result)) {
					// If we have enough items, return success
					if (results.length >= count) {
						return Parser.succeed(results, currentState)
					}
					const message = `Expected at least ${count} occurrences, but only found ${results.length}`
					return Parser.fail({ message, expected: [] }, itemResult.state)
				}

				// Add the item and update state
				const { result: value, state: newState } = itemResult
				results.push(value.right)
				currentState = newState

				// If we have a separator, try to parse it
				if (separator) {
					const { result: sepResult, state } = separator.run(currentState)
					if (Either.isLeft(sepResult)) {
						break
					}
					currentState = state
				}
			}

			if (results.length >= count) {
				return Parser.succeed(results, currentState)
			}

			const message = `Expected at least ${count} occurrences, but only found ${results.length}`
			return Parser.fail({ message, expected: [] }, currentState)
		})
	}
}

/**
 * Creates a parser that matches zero or more occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @returns A parser that produces an array of all matches
 */
export const many0 = <S, T, Ctx = {}>(
	parser: Parser<T, Ctx>,
	separator?: Parser<S, Ctx>,
) => many_<S, T, Ctx>(0)(parser, separator)

/**
 * Creates a parser that matches one or more occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @returns A parser that produces an array of all matches (at least one)
 */
export const many1 = <S, T, Ctx>(
	parser: Parser<T, Ctx>,
	separator?: Parser<S, Ctx>,
) => many_<S, T, Ctx>(1)(parser, separator)

/**
 * Creates a parser that matches at least n occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @param n - Number of required repetitions
 * @returns A parser that produces an array of at least n matches
 */
export const manyN = <S, T, Ctx>(
	parser: Parser<T, Ctx>,
	n: number,
	separator?: Parser<S, Ctx>,
) => many_<S, T, Ctx>(n)(parser, separator)

/**
 * Creates a parser that matches exactly n occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @param n - Number of required repetitions
 * @param separator - Optional parser to match between occurrences
 * @returns A parser that produces an array of exactly n matches
 */

export const manyNExact = <S, T, Ctx>(
	parser: Parser<T, Ctx>,
	n: number,
	separator?: Parser<S, Ctx>,
) =>
	Parser.gen(function* () {
		const results = yield* manyN(parser, n, separator)
		if (results.length !== n) {
			const message = `Expected exactly ${n} occurrences, but found ${results.length}`
			return yield* Parser.error<Ctx>(message)
		}
		return results
	})

/**
 * Internal helper function for creating skipping repetition parsers.
 *
 * @param count - Minimum number of repetitions required
 * @returns A function that creates a parser skipping multiple occurrences
 */
function skipMany_<T, Ctx>(count: number) {
	return (parser: Parser<T, Ctx>): Parser<undefined, Ctx> => {
		return new Parser((state) => {
			let currentState = state
			let successes = 0

			while (true) {
				const { result, state: newState } = parser.run(currentState)
				if (Either.isLeft(result)) {
					break
				}
				successes++
				currentState = newState
			}

			if (successes >= count) {
				return Parser.succeed(undefined, currentState)
			}
			const message = `Expected at least ${count} occurrences, but only found ${successes}`
			return Parser.fail({ message, expected: [] }, state)
		})
	}
}

/**
 * Creates a parser that skips zero or more occurrences of the input parser.
 *
 * @param parser - The parser to skip
 * @returns A parser that skips all matches
 */
export const skipMany0 = <T, Ctx = {}>(parser: Parser<T, Ctx>) =>
	skipMany_<T, Ctx>(0)(parser)

/**
 * Creates a parser that skips one or more occurrences of the input parser.
 *
 * @param parser - The parser to skip
 * @returns A parser that skips all matches (requires at least one)
 */
export const skipMany1 = <T, Ctx>(parser: Parser<T, Ctx>) =>
	skipMany_<T, Ctx>(1)(parser)

/**
 * Creates a parser that skips exactly n occurrences of the input parser.
 *
 * @param parser - The parser to skip
 * @param n - Number of required repetitions to skip
 * @returns A parser that skips exactly n matches
 */
export const skipManyN = <T, Ctx>(parser: Parser<T, Ctx>, n: number) =>
	skipMany_<T, Ctx>(n)(parser)

/**
 * Creates a parser that skips input until the given parser succeeds.
 *
 * @param parser - The parser to look for
 * @returns A parser that skips input until a match is found
 */
export function skipUntil<T, Ctx = {}>(
	parser: Parser<T, Ctx>,
): Parser<undefined, Ctx> {
	return new Parser((state) => {
		let currentState = state

		while (!State.isAtEnd(currentState)) {
			const { result, state: newState } = parser.run(currentState)
			if (Either.isRight(result)) {
				return Parser.succeed(undefined, newState)
			}
			currentState = State.consume(currentState, 1)
		}

		return Parser.succeed(undefined, currentState)
	})
}

/**
 * Creates a parser that takes input until the given parser succeeds.
 *
 * @param parser - The parser to look for
 * @returns A parser that takes input until a match is found
 */
export function takeUntil<T, Ctx = {}>(
	parser: Parser<T, Ctx>,
): Parser<string, Ctx> {
	return new Parser((state) => {
		let currentState = state
		let collected = ""

		while (!State.isAtEnd(currentState)) {
			const { result, state: newState } = parser.run(currentState)
			if (Either.isRight(result)) {
				return Parser.succeed(collected, newState)
			}
			collected += currentState.remaining[0]
			currentState = State.consume(currentState, 1)
		}

		return Parser.succeed(collected, currentState)
	})
}

/**
 * Creates a parser that takes input until the given character is found.
 *
 * @param char - The character to look for
 * @returns A parser that takes input until the character is found
 */
export function parseUntilChar<Ctx = {}>(char: string): Parser<string, Ctx> {
	return new Parser((state) => {
		if (char.length !== 1) {
			return Parser.fail(
				{
					message: "Incorrect usage of parseUntilChar parser.",
					expected: [char],
				},
				state,
			)
		}
		let currentState = state
		let collected = ""

		while (!State.isAtEnd(currentState)) {
			if (currentState.remaining[0] === char) {
				return Parser.succeed(collected, currentState)
			}
			collected += currentState.remaining[0]
			currentState = State.consume(currentState, 1)
		}

		const message = `Expected character ${char} but found ${collected}`
		return Parser.fail({ message, expected: [char] }, currentState)
	})
}

/**
 * A parser that skips any number of space characters.
 */
export const skipSpaces = new Parser(
	(state) =>
		Parser.succeed(
			undefined,
			State.consumeWhile(state, (char) => char === " "),
		),
	{ name: "skipSpaces" },
)

/**
 * Creates a parser that tries multiple parsers in order until one succeeds.
 *
 * @param parsers - Array of parsers to try
 * @returns A parser that succeeds if any of the input parsers succeed
 */
export function or<Parsers extends Parser<any, any>[], Ctx = {}>(
	...parsers: Parsers
): Parser<Parsers[number] extends Parser<infer T, Ctx> ? T : never, Ctx> {
	return new Parser((state) => {
		//const expectedNames: string[] = []
		for (const parser of parsers) {
			const { result, state: newState } = parser.run(state)
			if (Either.isRight(result)) {
				return Parser.succeed(result.right, newState)
			}
			//if (parser.options?.name) {
			//	expectedNames.push(parser.options.name)
			//}
		}

		const message = `None of the ${parsers.length} choices could be satisfied`
		return Parser.fail({ message }, state)
	})
}

/**
 * Creates a parser that optionally matches the input parser.
 * If the parser fails, returns undefined without consuming input.
 *
 * @param parser - The parser to make optional
 * @returns A parser that either succeeds with a value or undefined
 */
export function optional<T, Ctx = {}>(parser: Parser<T, Ctx>) {
	return new Parser((state: ParserState<Ctx>) => {
		const { result, state: newState } = parser.run(state)
		if (Either.isLeft(result)) {
			return Parser.succeed(undefined, newState)
		}
		// return result
		return Parser.succeed(result.right, newState)
	})
}

type LastParser<T, Ctx = {}> = T extends [...any[], Parser<infer L, Ctx>]
	? L
	: never

/**
 * Creates a parser that runs multiple parsers in sequence.
 * Returns the result of the last parser in the sequence.
 *
 * @param parsers - Array of parsers to run in sequence
 * @returns A parser that succeeds if all parsers succeed in sequence
 */
export function sequence<Parsers extends Parser<any>[], Ctx = {}>(
	parsers: [...Parsers],
): Parser<LastParser<Parsers, Ctx>, Ctx> {
	return new Parser((state: ParserState<Ctx>) => {
		const results: Parsers[] = []
		let currentState = state

		for (const parser of parsers) {
			const { result, state: newState } = parser.run(currentState)
			if (Either.isLeft(result)) {
				return Parser.fail(result.left, newState)
			}
			results.push(result.right)
			// TODO: fix this
			// @ts-expect-error this should be fine
			currentState = newState
		}

		return Parser.succeed(results.at(-1), currentState) as any
	})
}

/**
 * Creates a parser that matches input against a regular expression.
 * The regex must match at the start of the input.
 *
 * @param re - The regular expression to match against
 * @returns A parser that matches the regex pattern
 */
export const regex = <Ctx = {}>(re: RegExp): Parser<string, Ctx> => {
	// Create a new RegExp without global flag to ensure consistent behavior
	const nonGlobalRe = new RegExp(re.source, re.flags.replace("g", ""))

	return new Parser(
		(state) => {
			const match = nonGlobalRe.exec(state.remaining)
			if (match && match.index === 0) {
				const value = match[0]
				return Parser.succeed(value, state)
			}
			const message = `Expected ${re} but found ${state.remaining.slice(0, 10)}...`
			return Parser.fail(
				{
					message,
					expected: [re.toString()],
				},
				state,
			)
		},
		{ name: re.toString() },
	)
}

export function zip<A, B>(
	parserA: Parser<A>,
	parserB: Parser<B>,
): Parser<[A, B]> {
	return parserA.zip(parserB)
}

export function then<A, B>(parserA: Parser<A>, parserB: Parser<B>): Parser<B> {
	return parserA.then(parserB)
}

export const zipRight = then

export function thenDiscard<A, B>(
	parserA: Parser<A>,
	parserB: Parser<B>,
): Parser<A> {
	return parserA.thenDiscard(parserB)
}
export const zipLeft = thenDiscard

/**
 * Creates a parser that takes input until the given parser would succeed, without consuming the parser.
 *
 * @param parser - The parser to look for
 * @returns A parser that takes input until before a match would be found
 */
export function takeUpto<T>(parser: Parser<T>): Parser<string> {
	return new Parser((state) => {
		let currentState = state
		let collected = ""

		while (!State.isAtEnd(currentState)) {
			const { result } = parser.run(currentState)
			if (Either.isRight(result)) {
				return Parser.succeed(collected, currentState)
			}
			collected += currentState.remaining[0]
			currentState = State.consume(currentState, 1)
		}

		return Parser.succeed(collected, currentState)
	})
}

================
File: src/debug.ts
================
import { Either } from "./either"
import { Parser } from "./parser"
import { type ParserState, State, type ParserOutput } from "./state"
/**
 * Creates a debug output for a parser's current state and result
 */
export function debugState<Ctx = {}>(
	label: string,
	state: ParserState<Ctx>,
	result: ParserOutput<any, Ctx>,
	options: {
		inputPreviewLength?: number
		separator?: string
	} = {},
) {
	const { inputPreviewLength = 20, separator = "=".repeat(40) } = options

	console.log(`\n=== ${label} ===`)
	console.log("Position:", State.printPosition(state))
	console.log(
		"Input:",
		JSON.stringify(
			state.remaining.slice(0, inputPreviewLength) +
				(state.remaining.length > inputPreviewLength ? "..." : ""),
		),
	)
	console.log(
		"Result:",
		Either.isRight(result.result)
			? `Success: ${JSON.stringify(result.result.right.value)}`
			: `Error: ${result.result.left.message}`,
	)
	console.log(separator)
}

/**
 * Adds debug output to a parser
 */
export function debug<T, Ctx = {}>(
	parser: Parser<T, Ctx>,
	label: string,
): Parser<T, Ctx> {
	return parser.tap(({ state, result }) => debugState(label, state, result))
}

/**
 * Creates a parser that logs its input state and continues
 */
export function trace<Ctx = {}>(label: string): Parser<void, Ctx> {
	return new Parser((state) => {
		console.log(`\n[TRACE] ${label}`)
		console.log("Position:", State.printPosition(state))
		console.log("Remaining:", JSON.stringify(state.remaining))
		return Parser.succeed(undefined, state)
	})
}

/**
 * Adds breakpoints to a parser for step-by-step debugging
 */
export function breakpoint<T, Ctx = {}>(
	parser: Parser<T, Ctx>,
	label: string,
): Parser<T, Ctx> {
	return parser.tap(({ state, result }) => {
		debugState(label, state, result)
		// eslint-disable-next-line no-debugger
		debugger
	})
}

/**
 * Times how long a parser takes to run
 */
export function benchmark<T, Ctx = {}>(
	parser: Parser<T, Ctx>,
	label: string,
): Parser<T, Ctx> {
	return new Parser((state) => {
		const start = performance.now()
		const result = parser.run(state)
		const end = performance.now()
		console.log(`\n[BENCHMARK] ${label}: ${(end - start).toFixed(2)}ms`)
		return result
	})
}

================
File: src/either.ts
================
export type Either<R, L> = Left<L, R> | Right<R, L>

export class Left<L, R = never> {
	readonly _tag = "Left"
	constructor(public readonly left: L) {}
	*[Symbol.iterator](): Generator<Either<R, L>, R, any> {
		return yield this
	}
}

export class Right<R, L> {
	readonly _tag = "Right"
	constructor(public readonly right: R) {}
	*[Symbol.iterator](): Generator<Either<R, L>, R, any> {
		return yield this
	}
}

export const Either = {
	left<L, R = never>(l: L): Either<R, L> {
		return new Left(l)
	},

	right<R, L = never>(r: R): Either<R, L> {
		return new Right(r)
	},

	isLeft<R, L>(either: Either<R, L>): either is Left<L, R> {
		return either._tag === "Left"
	},

	isRight<R, L>(either: Either<R, L>): either is Right<R, L> {
		return either._tag === "Right"
	},

	match<R, L, T>(
		either: Either<R, L>,
		patterns: {
			onLeft: (left: L) => T
			onRight: (right: R) => T
		},
	): T {
		if (Either.isLeft(either)) {
			return patterns.onLeft(either.left)
		}
		return patterns.onRight(either.right)
	},

	gen<R, L>(f: () => Generator<Either<any, L>, R, any>): Either<R, L> {
		const iterator = f()
		let current = iterator.next()

		while (!current.done) {
			const either = current.value
			if (Either.isLeft(either)) {
				return either
			}
			current = iterator.next(either.right)
		}

		return Either.right(current.value)
	},
}

================
File: src/errors.ts
================
import type { ParserError, ParserState, SourcePosition } from "./state"

export function printPosition(position: SourcePosition) {
	return `line ${position.line}, column ${position.column}`
}

export function printArrow(position: SourcePosition) {
	const lineNumberDigits = position.line.toString().length
	return " ".repeat(lineNumberDigits + 3 + position.column - 1) + "^"
}

export function printErrorContext<Ctx = {}>(
	state: ParserState<Ctx>,
	message?: string,
) {
	return (
		"Parser Error:\n" +
		printErrorLine(state) +
		"\n" +
		printArrow(state.pos) +
		`${message ? `\n${message}` : ""}`
	)
}

export function printErrorLine<Ctx = {}>(state: ParserState<Ctx>) {
	const lines = state.context.source.split("\n")
	const lineNum = state.pos.line
	const startLine = Math.max(0, lineNum - 1)
	const endLine = lineNum
	const relevantLines = lines.slice(startLine, endLine + 1)
	const padding = lineNum.toString().length

	return relevantLines
		.map((line, i) => {
			const num = startLine + i + 1
			const paddedNum = num.toString().padStart(padding, " ")
			return `${paddedNum} | ${line}`
		})
		.join("\n")
}

export function printPositionWithOffset(position: SourcePosition) {
	return `line ${position.line}, column ${position.column}, offset ${position.offset}`
}

export function getErrorLine<Ctx = {}>(
	error: ParserError,
	state: ParserState<Ctx>,
) {
	const errorLine = state.context.source.slice(
		state.pos.offset,
		state.context.source.indexOf("\n", state.pos.offset),
	)
	return errorLine
}

================
File: src/index.ts
================
export * from "./chain"
export * from "./combinators"
export * from "./debug"
export * from "./either"
export * from "./errors"
export * from "./parser"
export * from "./state"
export * from "./types"
export * from "./utils"

================
File: src/parser.ts
================
import { debug } from "./debug"
import { Either } from "./either"
import { printErrorContext } from "./errors"
import {
	type ParserContext,
	ParserError,
	type ParserOptions,
	type ParserOutput,
	type ParserState,
	State,
} from "./state"
import type { Prettify } from "./types"

type BindResult<T, K extends string, B> = Prettify<
	T & {
		[k in K]: B
	}
>

export class Parser<T, Ctx = {}> {
	constructor(
		/**
		 * @internal
		 */
		public run: (state: ParserState<Ctx>) => ParserOutput<T, Ctx>,
		public options?: ParserOptions,
	) {}

	name(name: string) {
		this.options = { ...this.options, name }
		return this
	}

	static succeed<T, Ctx = {}>(
		value: T,
		state: ParserState<Ctx>,
	): ParserOutput<T, Ctx> {
		return {
			state,
			result: Either.right(value),
		}
	}

	static fail<Ctx = {}>(
		error: {
			message: string
			expected?: string[]
			found?: string
		},
		state: ParserState<Ctx>,
	): ParserOutput<never, Ctx> {
		const errorMessage = error.message.startsWith("Parser Error:")
			? error.message
			: printErrorContext(state, error.message)

		return {
			state,
			result: Either.left(
				new ParserError(errorMessage, error.expected ?? [], error.found),
			),
		}
	}

	static error<Ctx = {}>(
		message: string,
		expected: string[] = [],
		stateCallback?: (state: ParserState<Ctx>) => ParserState<Ctx>,
	): Parser<never, Ctx> {
		return new Parser((state) => {
			return Parser.fail(
				{ message, expected },
				stateCallback ? stateCallback(state) : state,
			)
		})
	}

	/**
	 * Adds an error message to the parser
	 * @param makeMessage - A function that returns an error message
	 * @returns A new parser with the error message added
	 */
	withError(
		makeMessage: (errorCtx: {
			error: ParserError
			state: ParserState<Ctx>
		}) => string,
	): Parser<T, Ctx> {
		return new Parser<T, Ctx>((state) => {
			const output = this.run(state)
			if (Either.isLeft(output.result)) {
				return Parser.fail(
					{
						message: makeMessage({
							error: output.result.left,
							state: output.state,
						}),
						expected: output.result.left.expected,
					},
					output.state,
				)
			}
			return output
		}, this.options)
	}

	parse(
		input: string,
		context = { source: input } as ParserContext<Ctx>,
	): ParserOutput<T, Ctx> {
		const { result, state } = this.run(State.fromInput(input, context))
		if (Either.isLeft(result)) {
			return Parser.fail(result.left, state)
		}
		return Parser.succeed(result.right, state)
	}

	withTrace(label: string): Parser<T, Ctx> {
		return new Parser<T, Ctx>((state) => {
			if (!state.context?.debug) {
				return this.run(state)
			}
			return debug(this, label).run(state)
		}, this.options)
	}

	parseOrError(
		input: string,
		context = { source: input } as ParserContext<Ctx>,
	) {
		const { result } = this.run(State.fromInput(input, context))
		if (Either.isRight(result)) {
			return result.right
		}
		return result.left
	}

	parseOrThrow(
		input: string,
		context = { source: input } as ParserContext<Ctx>,
	): T {
		const { result } = this.parse(
			input,
			context ?? {
				source: input,
			},
		)

		if (Either.isLeft(result)) {
			throw new Error(result.left.message)
		}
		return result.right
	}

	map<B>(f: (a: T) => B): Parser<B, Ctx> {
		return new Parser<B, Ctx>((state) => {
			const { result, state: newState } = this.run(state)
			if (Either.isLeft(result)) {
				return Parser.fail(result.left, state)
			}
			return Parser.succeed(f(result.right), newState)
		})
	}

	flatMap<B>(f: (a: T) => Parser<B, Ctx>): Parser<B, Ctx> {
		return new Parser<B, Ctx>((state) => {
			const { result, state: newState } = this.run(state)
			if (Either.isLeft(result)) {
				return Parser.fail(result.left, newState)
			}
			const nextParser = f(result.right)
			return nextParser.run(newState)
		})
	}

	static pure = <A>(a: A): Parser<A> =>
		new Parser((state) => Parser.succeed(a, state))

	static Do = Parser.pure({})

	/**
	 * Creates a new parser that lazily evaluates the given function.
	 * This is useful for creating recursive parsers.
	 *
	 * @param fn - A function that returns a parser
	 * @returns A new parser that evaluates the function when parsing
	 * @template T The type of value produced by the parser
	 *
	 * @example
	 * ```ts
	 * // Create a recursive parser for nested parentheses
	 * const parens: Parser<string> = Parser.lazy(() =>
	 *   between(
	 *     char('('),
	 *     char(')'),
	 *     parens
	 *   )
	 * )
	 * ```
	 */
	static lazy<T>(fn: () => Parser<T>): Parser<T> {
		return new Parser((state) => {
			const parser = fn()
			return parser.run(state)
		})
	}

	zip<B>(parserB: Parser<B, Ctx>): Parser<[T, B], Ctx> {
		return new Parser((state) => {
			const { result: a, state: stateA } = this.run(state)
			if (Either.isLeft(a)) {
				return Parser.fail(a.left, stateA)
			}
			const { result: b, state: stateB } = parserB.run(stateA)
			if (Either.isLeft(b)) {
				return Parser.fail(b.left, stateB)
			}
			return Parser.succeed([a.right, b.right], stateB)
		})
	}

	then<B>(parserB: Parser<B, Ctx>): Parser<B, Ctx> {
		return this.zip(parserB).map(([_, b]) => b)
	}

	zipRight = this.then

	thenDiscard<B>(parserB: Parser<B, Ctx>): Parser<T, Ctx> {
		return this.zip(parserB).map(([a, _]) => a)
	}

	zipLeft = this.thenDiscard

	bind<K extends string, B>(
		k: K,
		other: Parser<B, Ctx> | ((a: T) => Parser<B, Ctx>),
	): Parser<BindResult<T, K, B>, Ctx> {
		return new Parser<BindResult<T, K, B>, Ctx>((state) => {
			const { result: resultA, state: stateA } = this.run(state)
			if (Either.isLeft(resultA)) {
				return Parser.fail(resultA.left, stateA)
			}
			const nextParser = other instanceof Parser ? other : other(resultA.right)
			const { result: resultB, state: stateB } = nextParser.run(stateA)
			if (Either.isLeft(resultB)) {
				return Parser.fail(resultB.left, stateB)
			}
			return Parser.succeed(
				{ ...resultA.right, [k]: resultB.right } as BindResult<T, K, B>,
				stateB,
			)
		}, this.options)
	}

	*[Symbol.iterator](): Generator<Parser<T, Ctx>, T, any> {
		return yield this
	}

	/**
	 * Adds a tap point to observe the current state and result during parsing.
	 * Useful for debugging parser behavior.
	 *
	 * @param callback - Function called with current state and result
	 * @returns The same parser with the tap point added
	 */
	tap(
		callback: (args: {
			state: ParserState<Ctx>
			result: ParserOutput<T, Ctx>
		}) => void,
	): Parser<T, Ctx> {
		return new Parser((state) => {
			const result = this.run(state)
			callback({ state, result })
			return result
		}, this.options)
	}

	static gen<T, Ctx = unknown>(
		f: () => Generator<Parser<any, Ctx>, T, any>,
	): Parser<T, Ctx> {
		return new Parser<T, Ctx>((state) => {
			const iterator = f()
			let current = iterator.next()
			let currentState: ParserState<Ctx> = state
			while (!current.done) {
				const { result, state: updatedState } = current.value.run(currentState)
				if (Either.isLeft(result)) {
					return Parser.fail(result.left, updatedState)
				}
				currentState = updatedState
				current = iterator.next(result.right)
			}
			return Parser.succeed(current.value, currentState)
		})
	}

	trim(parser: Parser<any, Ctx>) {
		return parser.then(this).thenDiscard(parser)
	}

	trimLeft(parser: Parser<any, Ctx>): Parser<T, Ctx> {
		return parser.then(this)
	}

	trimRight(parser: Parser<any, Ctx>): Parser<T, Ctx> {
		return this.thenDiscard(parser)
	}
}

export function parser<T, Ctx = unknown>(
	f: () => Generator<Parser<any, Ctx>, T, any>,
): Parser<T, Ctx> {
	return new Parser<T, Ctx>((state) => {
		const iterator = f()
		let current = iterator.next()
		let currentState: ParserState<Ctx> = state
		while (!current.done) {
			const { result, state: updatedState } = current.value.run(currentState)
			if (Either.isLeft(result)) {
				return Parser.fail(result.left, updatedState)
			}
			currentState = updatedState
			current = iterator.next(result.right)
		}
		return Parser.succeed(current.value, currentState)
	})
}

================
File: src/state.ts
================
import type { Either } from "./either"
import type { Prettify } from "./types"

export type ParserContext<Ctx = {}> = Prettify<
	Ctx & {
		debug?: boolean
		source: string
	}
>

export type ParserOptions = { name?: string }

export class ParserError {
	constructor(
		public message: string,
		public expected: string[],
		public found?: string,
	) {}
}

export type ParserOutput<T, Ctx = {}> = {
	state: ParserState<Ctx>
	result: Either<T, ParserError>
}

export type SourcePosition = {
	line: number
	column: number
	offset: number
}

export type ParserState<Ctx = {}> = {
	remaining: string
	pos: SourcePosition
	context: ParserContext<Ctx>
}

/**
 * Utility object containing static methods for creating and manipulating parser state.
 */
export const State = {
	/**
	 * Creates a new parser state from an input string.
	 *
	 * @param input - The input string to parse
	 * @returns A new parser state initialized at the start of the input
	 */
	fromInput<Ctx = {}>(
		input: string,
		context: ParserContext<Ctx>,
	): ParserState<Ctx> {
		return {
			remaining: input,
			pos: { line: 1, column: 1, offset: 0 },
			context,
		}
	},

	/**
	 * Creates a new state by consuming n characters from the current state.
	 *
	 * @param state - The current parser state
	 * @param n - Number of characters to consume
	 * @returns A new state with n characters consumed and position updated
	 * @throws Error if attempting to consume more characters than remaining
	 */
	consume<Ctx = {}>(state: ParserState<Ctx>, n: number): ParserState<Ctx> {
		if (n === 0) return state
		if (n > state.remaining.length) {
			throw new Error("Cannot consume more characters than remaining")
		}

		const consumed = state.remaining.slice(0, n)
		let { line, column, offset } = state.pos

		for (const char of consumed) {
			if (char === "\n") {
				line++
				column = 1
			} else {
				column++
			}
			offset++
		}

		return {
			remaining: state.remaining.slice(n),
			pos: { line, column, offset },
			context: state.context,
		}
	},

	/**
	 * Creates a new state by consuming a specific string from the current state.
	 *
	 * @param state - The current parser state
	 * @param str - The string to consume
	 * @returns A new state with the string consumed and position updated
	 * @throws Error if the input doesn't start with the specified string
	 */
	consumeString<Ctx = {}>(
		state: ParserState<Ctx>,
		str: string,
	): ParserState<Ctx> {
		if (!state.remaining.startsWith(str)) {
			throw new Error(
				`Cannot consume "${str}" - input "${state.remaining}" doesn't start with it`,
			)
		}
		return State.consume(state, str.length)
	},

	move<Ctx = {}>(state: ParserState<Ctx>, moveBy: number) {
		return State.consume(
			{
				...state,
				remaining: state.context.source,
				pos: { line: 1, column: 1, offset: 0 },
			},
			state.pos.offset + moveBy,
		)
	},

	/**
	 * Creates a new state by consuming characters while a predicate is true.
	 *
	 * @param state - The current parser state
	 * @param predicate - Function that tests each character
	 * @returns A new state with matching characters consumed
	 */
	consumeWhile<Ctx = {}>(
		state: ParserState<Ctx>,
		predicate: (char: string) => boolean,
	): ParserState<Ctx> {
		let i = 0
		while (i < state.remaining.length && predicate(state.remaining[i])) {
			i++
		}
		return State.consume(state, i)
	},

	/**
	 * Gets the next n characters from the input without consuming them.
	 *
	 * @param state - The current parser state
	 * @param n - Number of characters to peek (default: 1)
	 * @returns The next n characters as a string
	 */
	peek<Ctx = {}>(state: ParserState<Ctx>, n: number = 1): string {
		return state.remaining.slice(0, n)
	},

	/**
	 * Checks if the parser has reached the end of input.
	 *
	 * @param state - The current parser state
	 * @returns True if at end of input, false otherwise
	 */
	isAtEnd<Ctx = {}>(state: ParserState<Ctx>): boolean {
		return state.remaining.length === 0
	},

	printPosition<Ctx = {}>(state: ParserState<Ctx>): string {
		return `line ${state.pos.line}, column ${state.pos.column}, offset ${state.pos.offset}`
	},
}

================
File: src/types.ts
================
export type Prettify<T> = {
	[K in keyof T]: T[K]
} & {}

export type Last<T> = T extends [...any[], infer L] ? L : never

================
File: src/utils.ts
================
import { Parser } from "./parser"

export const peekState = new Parser((s) => {
	return Parser.succeed(s, s)
})

export const peekRemaining = new Parser((s) => {
	console.log(s.remaining)
	return Parser.succeed(s.remaining, s)
})

export const peekAhead = (n: number) =>
	new Parser((s) => {
		return Parser.succeed(s.remaining.slice(0, n), s)
	})

export const peekLine = new Parser((s) => {
	const restOfLine = s.remaining.slice(0, s.remaining.indexOf("\n"))
	console.log(restOfLine)
	return Parser.succeed(restOfLine, s)
})

export const peekUntil = (ch: string) =>
	new Parser((s) => {
		const index = s.remaining.indexOf(ch)
		return Parser.succeed(s.remaining.slice(0, index), s)
	})

================
File: tests/combinators.test.ts
================
import { describe, expect, test } from "bun:test"
import {
	alphabet,
	between,
	char,
	digit,
	lookAhead,
	many0,
	many1,
	manyN,
	manyNExact,
	optional,
	or,
	regex,
	sepBy,
	sequence,
	skipSpaces,
	takeUntil,
} from "../src/combinators"
import { Either } from "../src/either"
import { Parser } from "../src/parser"

const stringParser = skipSpaces
	.then(char('"'))
	.then(many1(or(alphabet, digit)))
	.thenDiscard(char('"'))
	.map((s) => s.join(""))

const integerParser = skipSpaces
	.then(many1(digit))
	.map((s) => parseInt(s.join("")))
	.withError(() => "Expected an integer")

test("sepBy string array", () => {
	const p = char("[")
		.then(sepBy(char(","), or(stringParser, integerParser)))
		.thenDiscard(char("]"))
	expect(p.parseOrThrow('["hello", 2, "foo"]')).toEqual(["hello", 2, "foo"])
})

test("optional", () => {
	const p = optional(or(stringParser, integerParser))
	expect(p.parseOrThrow('"hello"')).toEqual("hello")
	expect(p.parseOrThrow("123")).toEqual(123)
})

test("sequence", () => {
	const p = sequence([
		stringParser,
		skipSpaces,
		char(","),
		skipSpaces,
		integerParser,
		skipSpaces,
		char(","),
		skipSpaces,
		integerParser,
	])
	expect(p.parseOrThrow('"hello", 123, 23')).toEqual(23)
})

describe("regex", () => {
	test("should match at the start of the input", () => {
		const p = regex(/foo/)
		expect(p.parseOrThrow("foo")).toEqual("foo")
	})

	test("should not match at the start of the input", () => {
		const p = regex(/foo/)
		expect(Either.isLeft(p.parse("bar").result)).toEqual(true)
	})

	test("should match at the start of the input with global flag", () => {
		const p = regex(/foo/g)
		expect(p.parseOrThrow("foo")).toEqual("foo")
	})
})

describe("basic combinators", () => {
	test("char", () => {
		const p = char("a")
		expect(p.parseOrThrow("a")).toBe("a")
		expect(Either.isLeft(p.parse("b").result)).toBe(true)
		expect(Either.isLeft(p.parse("").result)).toBe(true)
	})

	test("digit", () => {
		expect(digit.parseOrThrow("1")).toBe("1")
		expect(digit.parseOrThrow("9")).toBe("9")
		expect(Either.isLeft(digit.parse("a").result)).toBe(true)
		expect(Either.isLeft(digit.parse("").result)).toBe(true)
	})

	test("alphabet", () => {
		expect(alphabet.parseOrThrow("a")).toBe("a")
		expect(alphabet.parseOrThrow("Z")).toBe("Z")
		expect(Either.isLeft(alphabet.parse("1").result)).toBe(true)
		expect(Either.isLeft(alphabet.parse("").result)).toBe(true)
	})
})

describe("many combinators", () => {
	test("many1 requires at least one match", () => {
		const digits = many1(digit)
		expect(digits.parseOrThrow("123")).toEqual(["1", "2", "3"])
		expect(digits.parseOrThrow("1")).toEqual(["1"])
		expect(Either.isLeft(digits.parse("").result)).toBe(true)
		expect(Either.isLeft(digits.parse("abc").result)).toBe(true)
	})

	test("manyNExact requires exactly n matches", () => {
		const threeDigits = manyNExact(digit, 3)
		const t1 = threeDigits.parseOrError("123")
		expect(t1).toEqual(["1", "2", "3"])
		expect(Either.isLeft(threeDigits.parse("12").result)).toBe(true)
		const t2 = threeDigits.parse("1234")
		expect(Either.isLeft(t2.result)).toBe(true)
		expect(Either.isLeft(threeDigits.parse("").result)).toBe(true)
	})

	test("manyN with separator", () => {
		const threeDigitsComma = manyN(digit, 3, char(",")).thenDiscard(
			lookAhead(or(char("\n"), Parser.pure(undefined))),
		)
		expect(threeDigitsComma.parseOrThrow("1,2,3")).toEqual(["1", "2", "3"])
		expect(Either.isLeft(threeDigitsComma.parse("1,2").result)).toBe(true)
	})
})

describe("complex combinations", () => {
	test("nested array of numbers", () => {
		type Value = number | Value[]
		const value = Parser.lazy(() => or(number, array))
		const number = many1(digit).map((s) => parseInt(s.join("")))
		const array: Parser<Value[]> = char("[")
			.then(sepBy(char(","), value))
			.thenDiscard(char("]"))

		expect(value.parseOrError("[1,2,[3,4],5]")).toEqual([1, 2, [3, 4], 5])
		expect(Either.isLeft(value.parse("[1,2,[3,4],]").result)).toBe(true)
	})

	test("simple expression parser", () => {
		type Expr = number
		const expr: Parser<Expr> = Parser.lazy(() => or(number, parens))
		const number = many1(digit).map((s) => parseInt(s.join("")))
		const parens: Parser<number> = char("(")
			.then(expr)
			.thenDiscard(char(")"))
			.map((n: number) => n * 2)
		expect(expr.parseOrThrow("123")).toBe(123)
		expect(expr.parseOrThrow("(123)")).toBe(246)
		expect(expr.parseOrThrow("((123))")).toBe(492)
		expect(Either.isLeft(expr.parse("(123").result)).toBe(true)
	})

	test("key-value parser", () => {
		const key = many1(alphabet).map((s) => s.join(""))
		const value = many1(digit).map((s) => parseInt(s.join("")))
		const pair = key
			.thenDiscard(char(":"))
			.flatMap((k) => value.map((v) => [k, v] as const))
		const object = char("{")
			.then(sepBy(char(","), pair))
			.thenDiscard(char("}"))
			.map(Object.fromEntries)
		expect(object.parseOrThrow("{foo:123,bar:456}")).toEqual({
			foo: 123,
			bar: 456,
		})
		expect(Either.isLeft(object.parse("{foo:123,}").result)).toBe(true)
	})
})

describe("error handling", () => {
	test("custom error messages", () => {
		const p = digit.withError(
			({ state }) => `Expected a digit at position ${state.pos.offset}`,
		)
		const { result } = p.parse("a")
		expect(Either.isLeft(result)).toBe(true)
	})

	test("error callback", () => {
		const p = digit.withError(
			({ state }) => `Expected a digit at position ${state.pos.offset}`,
		)
		const { result } = p.parse("a")
		expect(Either.isLeft(result)).toBe(true)
	})
})

describe("parser composition", () => {
	test("map transformation", () => {
		const p = digit.map(Number)
		expect(p.parseOrThrow("5")).toBe(5)
	})

	test("flatMap chaining", () => {
		const p = digit.flatMap((d) => digit.map((d2) => Number(d + d2)))
		expect(p.parseOrThrow("12")).toBe(12)
	})

	test("then sequencing", () => {
		const p = char("[").then(digit).thenDiscard(char("]"))
		expect(p.parseOrThrow("[5]")).toBe("5")
	})
})

describe("advanced combinators", () => {
	test("lookAhead without consuming", () => {
		const p = lookAhead(char("a")).then(char("a"))
		expect(p.parseOrThrow("a")).toBe("a")
		expect(Either.isLeft(p.parse("b").result)).toBe(true)
	})

	test("sequence with type inference", () => {
		const p = sequence([digit.map(Number), char("+"), digit.map(Number)])
		expect(p.parseOrThrow("1+2")).toBe(2) // returns last value
	})

	test("sepBy with empty input", () => {
		const p = sepBy(char(","), digit)
		// expect(p.parseOrThrow("")).toEqual([])
		// expect(p.parseOrThrow("1")).toEqual(["1"])
		// expect(p.parseOrThrow("1,2,3")).toEqual(["1", "2", "3"])
	})

	test("optional with chaining", () => {
		const p = optional(char("-")).flatMap((sign) =>
			many1(digit).map((digits) => ({
				sign: sign === "-" ? -1 : 1,
				value: Number(digits.join("")),
			})),
		)

		expect(p.parseOrThrow("123")).toEqual({
			sign: 1,
			value: 123,
		})
		expect(p.parseOrThrow("-123")).toEqual({
			sign: -1,
			value: 123,
		})
	})
})

describe("error recovery", () => {
	test("custom error with context", () => {
		const identifier = regex(/[a-z]+/).withError(
			() => "Expected lowercase identifier",
		)
		const number = regex(/[0-9]+/).withError(() => "Expected number")
		const assignment = identifier
			.thenDiscard(char("=").thenDiscard(skipSpaces))
			.then(number)
			.withError(({ error }) => error.message)

		const { result } = assignment.parse("foo = bar")
		expect(Either.isLeft(result)).toBe(true)
	})

	test("error position tracking", () => {
		const p = many1(digit).thenDiscard(char(";"))
		const { result, state } = p.parse("123x")
		expect(Either.isLeft(result)).toBe(true)
	})
})

describe("between", () => {
	test("between parser", () => {
		const p = between(char("("), char(")"), many1(digit))
		expect(p.parseOrThrow("(123)")).toEqual(["1", "2", "3"])
	})

	test("between with nested parsers", () => {
		const strParser = char('"')
			.then(many1(or(alphabet, digit)))
			.thenDiscard(char('"'))
			.map((s) => s.join(""))
		const p = between(
			char("["),
			char("]"),
			sepBy(
				many0(char(" "))
					.then(char(","))
					.then(many0(char(" "))),
				strParser,
			),
		)
		const result = p.parseOrThrow('["hello", "world"]')
		expect(result).toEqual(["hello", "world"])
	})
})

describe("takeUntil", () => {
	test("takeUntil 1", () => {
		const p = takeUntil(char("a"))
		expect(p.parseOrThrow("123142abc")).toBe("123142")
	})

	test("takeUntil 2", () => {
		const strParser = char('"')
			.then(many1(or(alphabet, digit)))
			.thenDiscard(char('"'))
			.map((s) => s.join(""))
		const p = takeUntil(strParser)
		expect(p.parseOrThrow('this is a "hello"')).toBe("this is a ")
	})
})

================
File: tests/either.test.ts
================
import { describe, expect, test } from "bun:test"
import { Either } from "../src/either"

const ea = (): Either<number, string> =>
	Either.gen(function* () {
		const a = yield* Either.right(5)
		const b = yield* Either.right(3)
		return a + b
	})

const eb = (): Either<number, string> =>
	Either.gen(function* () {
		const a = yield* ea()
		const aa = yield* ea()
		yield* Either.left("hi")
		return a + aa
	})

describe("either", () => {
	test("either right", () => {
		const result = ea()
		expect(Either.isRight(result)).toBe(true)
	})

	test("either left", () => {
		const result = eb()
		expect(Either.isLeft(result)).toBe(true)
	})
})

================
File: .gitignore
================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

================
File: .npmignore
================
.git
.gitignore
node_modules
src
tsconfig.json
biome.json
.vscode
.cursorrules

================
File: biome.json
================
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": []
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "tab"
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": false
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double",
      "semicolons": "asNeeded",
      "lineWidth": 80
    }
  }
}

================
File: build.ts
================
import { copyFile } from "node:fs/promises"
import { join } from "node:path"

async function main() {
	await copyFile(
		join("dist", "index.d.ts"),
		join("dist", "index.d.cts"),
	)
}

main().catch(console.error)

================
File: index.ts
================
export * from "./src/chain"
export * from "./src/combinators"
export * from "./src/debug"
export * from "./src/either"
export * from "./src/errors"
export * from "./src/parser"
export * from "./src/state"
export * from "./src/types"
export * from "./src/utils"

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Texoport

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "parserator",
  "version": "0.1.31",
  "description": "A parser combinator library inspired by Parsec and Effect-TS",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "require": {
        "types": "./dist/index.d.cts",
        "default": "./dist/index.cjs"
      }
    }
  },
  "files": [
    "dist",
    "README.md"
  ],
  "scripts": {
    "build": "tsup && bun build.ts",
    "test": "bun test",
    "typecheck": "tsc --noEmit",
    "prepublishOnly": "bun run build && bun test",
    "publish:patch": "bun run build && npm version patch && npm publish --access public",
    "publish:minor": "bun run build && npm version minor && npm publish --access public",
    "publish:major": "bun run build && npm version major && npm publish --access public",
    "release:patch": "bun run build && bun test && bun run publish:patch",
    "release:minor": "bun run build && bun test && bun run publish:minor",
    "release:major": "bun run build && bun test && bun run publish:major"
  },
  "keywords": [
    "parser",
    "parser-combinators",
    "typescript",
    "functional-programming"
  ],
  "author": "Sai (https://bsky.app/profile/texoport.in)",
  "license": "MIT",
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@types/bun": "^1.1.10",
    "tsup": "^8.3.5",
    "typescript": "^5.0.0",
    "vitest": "^1.2.1"
  },
  "peerDependencies": {
    "typescript": "^5.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/saiashirwad/parserator.git"
  },
  "bugs": {
    "url": "https://github.com/saiashirwad/parserator/issues"
  },
  "homepage": "https://github.com/saiashirwad/parserator#readme"
}

================
File: README.md
================
# Parserator

> **Warning**
> This library is currently in early development and the API is subject to change. There are *several* bugs. Please don't use, even at your own risk. I am absolutely responsible for any bugs, so holler at me at [@texoport.in](https://bsky.app/profile/texoport.in).

A TypeScript parser combinator library inspired by [Parsec](https://github.com/haskell/parsec) and [Effect-TS](https://github.com/Effect-ts/Effect). Write parsers using a clean, generator-based syntax or compose them using functional combinators.

## Table of Contents

* [Installation](#installation)
* [Basic Usage](#basic-usage)
* [Generator Syntax](#generator-syntax)
* [Primitive Parsers](#primitive-parsers)
* [Combinators](#combinators)
* [Error Handling](#error-handling)
* [Debugging](#debugging)
* [Advanced Usage](#advanced-usage)
* [API Reference](#api-reference)

## Installation

```bash
npm install parserator
```

## Basic Usage

```typescript
import { Parser, char, many1, digit } from 'parserator'

// Create a simple number parser
const numberParser = many1(digit).map(digits => parseInt(digits.join(""), 10))

// Parse a string
const result = numberParser.run("123")
// Right([123, {...}])

// Handle errors
const error = numberParser.run("abc")
// Left(ParserError: Expected digit but found 'a')
```

## Generator Syntax

Write parsers using a clean, generator-based syntax that feels like async/await:

```typescript
import { Parser, char, many1, digit, optional } from 'parserator'

// Parse a floating point number
const float = Parser.gen(function* () {
  // Parse optional sign
  const sign = yield* optional(char("-"))
  
  // Parse integer part
  const intPart = yield* many1(digit)
  
  // Parse optional fractional part
  const fractionalPart = yield* optional(
    Parser.gen(function* () {
      yield* char(".")
      return yield* many1(digit)
    })
  )
  
  // Parse optional exponent
  const exponentPart = yield* optional(
    Parser.gen(function* () {
      yield* char("e")
      const expSign = yield* optional(char("+") || char("-"))
      const expDigits = yield* many1(digit)
      return (expSign ?? "") + expDigits.join("")
    })
  )

  // Combine parts
  const numStr = 
    (sign ?? "") + 
    intPart.join("") + 
    (fractionalPart ? "." + fractionalPart.join("") : "") +
    (exponentPart ? "e" + exponentPart : "")

  return parseFloat(numStr)
})

float.run("123.456e-7") // Right([1.23456e-5, ...])
```

## Primitive Parsers

### Character Parsers

```typescript
import { char, string, regex, alphabet, digit } from 'parserator'

// Match a single character
char("a").run("abc") // Right(["a", ...])

// Match an exact string
string("hello").run("hello world") // Right(["hello", ...])

// Match using regex
regex(/[0-9]+/).run("123abc") // Right(["123", ...])

// Match any letter
alphabet.run("abc") // Right(["a", ...])

// Match any digit
digit.run("123") // Right(["1", ...])
```

## Combinators

### Repetition

```typescript
import { many0, many1, manyN, digit } from 'parserator'

// Match zero or more
many0(digit).run("123abc") // Right([["1","2","3"], ...])

// Match one or more
many1(digit).run("123abc") // Right([["1","2","3"], ...])

// Match exact number
manyN(digit, 2).run("123") // Right([["1","2"], ...])
```

### Sequencing and Choice

```typescript
import { sequence, or, between, sepBy } from 'parserator'

// Run parsers in sequence
sequence([char("a"), char("b")]).run("abc")
// Right(["b", ...])

// Try multiple parsers
or(char("a"), char("b")).run("abc")
// Right(["a", ...])

// Match between delimiters
between(char("("), char(")"), digit).run("(5)")
// Right(["5", ...])

// Match separated values
sepBy(char(","), digit).run("1,2,3")
// Right([["1","2","3"], ...])
```

### Look-ahead and Skipping

```typescript
import { lookAhead, skipSpaces } from 'parserator'

// Look ahead without consuming
lookAhead(char("a")).run("abc")
// Right(["a", ...]) // Position stays at "abc"

// Skip whitespace
skipSpaces.then(char("a")).run("   abc")
// Right(["a", ...])
```

## Error Handling

Customize error messages and add error callbacks:

```typescript
const parser = many1(digit)
  .error("Expected at least one digit")
  .errorCallback((error, state) => {
    return `Error at ${state.pos.line}:${state.pos.column}: ${error.message}`
  })

parser.run("abc")
// Left(ParserError: Error at 1:1: Expected at least one digit)
```

## Debugging

Debug tools to inspect parser behavior:

```typescript
import { debug, trace } from 'parserator'

// Add debug output
const debuggedParser = debug(parser, "number-parser")

// Add trace points
const tracedParser = trace("Before parsing number")
  .then(parser)
```

## Advanced Usage

### JSON Array Parser

```typescript
const jsonArray = Parser.gen(function* () {
  yield* char("[")
  yield* skipSpaces
  
  const items = yield* sepBy(
    char(","),
    Parser.gen(function* () {
      yield* skipSpaces
      const value = yield* or(stringParser, numberParser)
      yield* skipSpaces
      return value
    })
  )
  
  yield* skipSpaces
  yield* char("]")
  return items
})

jsonArray.run('["hello", 123, "world"]')
// Right([["hello", 123, "world"], ...])
```

### Recursive Parsers

```typescript
const expr: Parser<number> = Parser.lazy(() => 
  Parser.gen(function* () {
    yield* char("(")
    const left = yield* number
    const op = yield* or(char("+"), char("-"))
    const right = yield* expr
    yield* char(")")
    
    return op === "+" ? left + right : left - right
  })
)

expr.run("(1+(2-(3+4)))")
// Right([-4, ...])
```

## API Reference

### Parser<T>

The core Parser class that represents a parsing computation.

#### Methods

* `run(input: string): ParserResult<T>` - Run the parser on an input string
* `parseOrError(input: string): T | ParserError` - Run parser and return result or error
* `parseOrThrow(input: string): T` - Run parser and throw on error
* `map<B>(f: (a: T) => B): Parser<B>` - Transform parser result
* `flatMap<B>(f: (a: T) => Parser<B>): Parser<B>` - Chain parsers
* `error(message: string): Parser<T>` - Set error message
* `errorCallback(cb: (error: ParserError, state: ParserState) => string): Parser<T>` - Custom error handling
* `tap(callback: (state: ParserState, result: ParserResult<T>) => void): Parser<T>` - Adds a tap point to observe the current state and result during parsing
* `withName(name: string): Parser<T>` - Name the parser for better errors

#### Static Methods

* `Parser.gen<T>(f: () => Generator<Parser<any>, T>): Parser<T>` - Create parser using generator syntax
* `Parser.succeed<T>(value: T): Parser<T>` - Create always-succeeding parser
* `Parser.fail(message: string): Parser<never>` - Create always-failing parser
* `Parser.lazy<T>(f: () => Parser<T>): Parser<T>` - Creates a new parser that lazily evaluates the given function. This is useful for creating recursive parsers.

### Combinators

#### Basic Parsers

* `char(ch: string): Parser<string>` - Creates a parser that matches a single character.
  

```ts
  const parser = char("a")
  parser.run("abc") // Right(["a", {...}])
  parser.run("xyz") // Left(error)
  ```

* `string(str: string): Parser<string>` - Creates a parser that matches an exact string in the input.
  

```ts
  const parser = string("hello")
  parser.run("hello world") // Right(["hello", {...}])
  parser.run("goodbye") // Left(error)
  ```

* `regex(re: RegExp): Parser<string>` - Creates a parser that matches input against a regular expression. The regex must match at the start of the input.
  

```ts
  const parser = regex(/[0-9]+/)
  parser.run("123abc") // Right(["123", {...}])
  ```

* `alphabet: Parser<string>` - A parser that matches any single alphabetic character (a-z, A-Z).
  

```ts
  const parser = alphabet
  parser.run("abc") // Right(["a", {...}])
  parser.run("123") // Left(error)
  ```

* `digit: Parser<string>` - A parser that matches any single digit character (0-9).
  

```ts
  const parser = digit
  parser.run("123") // Right(["1", {...}])
  parser.run("abc") // Left(error)
  ```

#### Repetition

* `many0<T>(parser: Parser<T>, separator?: Parser<any>): Parser<T[]>` - Creates a parser that matches zero or more occurrences of the input parser.

* `many1<T>(parser: Parser<T>, separator?: Parser<any>): Parser<T[]>` - Creates a parser that matches one or more occurrences of the input parser.

* `manyN<T>(parser: Parser<T>, n: number, separator?: Parser<any>): Parser<T[]>` - Creates a parser that matches at least n occurrences of the input parser.

* `manyNExact<T>(parser: Parser<T>, n: number, separator?: Parser<any>): Parser<T[]>` - Creates a parser that matches exactly n occurrences of the input parser.

#### Sequencing and Choice

* `sequence<Parsers extends Parser<any>[]>(parsers: [...Parsers]): Parser<LastParser<Parsers>>` - Creates a parser that runs multiple parsers in sequence. Returns the result of the last parser in the sequence.

* `between<T>(start: Parser<any>, end: Parser<any>, parser: Parser<T>): Parser<T>` - Creates a parser that matches content between two string delimiters.
  

```ts
  const parser = between(char('('), char(')'), digit)
  parser.run('(5)') // Right(['5', {...}])
  parser.run('5') // Left(error)
  ```

* `sepBy<S, T>(sepParser: Parser<S>, parser: Parser<T>): Parser<T[]>` - Creates a parser that matches zero or more occurrences of elements separated by a separator.
  

```ts
  const parser = sepBy(char(','), digit)
  parser.run("1,2,3") // Right([["1", "2", "3"], {...}])
  parser.run("") // Right([[], {...}])
  ```

* `or<Parsers extends Parser<any>[]>(...parsers: Parsers): Parser<T>` - Creates a parser that tries multiple parsers in order until one succeeds.

* `optional<T>(parser: Parser<T>): Parser<T | undefined>` - Creates a parser that optionally matches the input parser. If the parser fails, returns undefined without consuming input.

#### Look-ahead and Skipping

* `lookAhead<T>(parser: Parser<T>): Parser<T>` - Creates a parser that looks ahead in the input stream without consuming any input. The parser will succeed with the result of the given parser but won't advance the input position.
  

```ts
  const parser = lookAhead(char('a'))
  parser.run('abc') // Right(['a', {...}])
  // Input position remains at 'abc', 'a' is not consumed
  ```

* `skipSpaces: Parser<undefined>` - A parser that skips any number of space characters.

* `skipMany0<T>(parser: Parser<T>): Parser<undefined>` - Creates a parser that skips zero or more occurrences of the input parser.

* `skipMany1<T>(parser: Parser<T>): Parser<undefined>` - Creates a parser that skips one or more occurrences of the input parser.

* `skipManyN<T>(parser: Parser<T>, n: number): Parser<undefined>` - Creates a parser that skips exactly n occurrences of the input parser.

* `skipUntil<T>(parser: Parser<T>): Parser<undefined>` - Creates a parser that skips input until the given parser succeeds.

#### Debug Tools

* `debug<T>(parser: Parser<T>, label: string): Parser<T>` - Adds debug output to a parser.

* `trace(label: string): Parser<void>` - Creates a parser that logs its input state and continues.

* `debugState(label: string, state: ParserState, result: ParserResult<any>, options?: { inputPreviewLength?: number, separator?: string })` - Creates a debug output for a parser's current state and result.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": [
      "ESNext",
      "DOM"
    ],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,
    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "declaration": true,
    "declarationMap": true,
    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}

================
File: tsconfig.types.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "emitDeclarationOnly": true,
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./src",
  },
  "include": [
    "src/**/*.ts"
  ]
}

================
File: tsup.config.ts
================
import { defineConfig } from "tsup"

export default defineConfig({
	format: ["esm", "cjs"],
	entry: {
		index: "src/index.ts",
	},
	outDir: "dist",
	sourcemap: true,
	clean: true,
	dts: {
		resolve: true,
		entry: "src/index.ts",
	},
})

================
File: typedoc.json
================
{
  "$schema": "https://typedoc.org/schema.json",
  "entryPoints": ["src/index.ts"],
  "entryPointStrategy": "expand",
  "out": "docs",
  "name": "Parserator",
  "includeVersion": true,
  "navigationLinks": {
    "GitHub": "https://github.com/saiashirwad/parserator",
    "NPM": "https://www.npmjs.com/package/parserator"
  },
  "categorizeByGroup": true,
  "searchInComments": true,
  "readme": "README.md",
  "sort": ["source-order"],
  "excludePrivate": true,
  "excludeInternal": true,
  "validation": {
    "invalidLink": true,
    "notDocumented": true
  }
}
