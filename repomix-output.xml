This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
examples/
  scheme/
    ast.ts
    error-debug.ts
    example.ts
    parser.ts
    scheme.test.ts
  ini-parser.ts
src/
  chain.ts
  combinators.ts
  debug.ts
  either.ts
  error-formatter.ts
  errors.ts
  hints.ts
  index.ts
  parser.ts
  rich-errors.ts
  state.ts
  types.ts
  utils.ts
tests/
  combinators.test.ts
  either.test.ts
  error-formatter.test.ts
  hints.test.ts
  label-system.test.ts
  rich-errors.test.ts
.gitignore
.npmignore
AGENT.md
biome.json
build.ts
index.ts
LICENSE
package.json
README.md
tsconfig.json
tsconfig.types.json
tsup.config.ts
typedoc.json
updates.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="examples/scheme/error-debug.ts">
import { lispParser } from "./parser"
import { ErrorFormatter } from "../../src"

const originalInput = "(+ 5  (+ 3 5)"
console.log("=== ParseErrorBundle Debug ===")
console.log(`Input: "${originalInput}"`)
console.log(`Length: ${originalInput.length}`)

const result = lispParser.parse(originalInput)
if (result.result._tag === "Left") {
  const bundle = result.result.left
  
  console.log("\n--- ParseErrorBundle Structure ---")
  console.log("Bundle type:", bundle.constructor.name)
  console.log("Number of errors:", bundle.errors.length)
  console.log("Source length:", bundle.source.length)
  console.log("Source matches input:", bundle.source === originalInput)
  
  console.log("\n--- Primary Error Analysis ---")
  const primary = bundle.primary
  console.log("Primary error tag:", primary.tag)
  console.log("Primary error span:", primary.span)
  console.log("Primary error message:", primary.tag === "Custom" ? primary.message : "N/A")
  console.log("Primary error context:", primary.context)
  
  console.log("\n--- All Errors Analysis ---")
  bundle.errors.forEach((error, i) => {
    console.log(`Error ${i + 1}:`)
    console.log(`  Tag: ${error.tag}`)
    console.log(`  Span: offset=${error.span.offset}, length=${error.span.length}, line=${error.span.line}, column=${error.span.column}`)
    if (error.tag === "Custom") {
      console.log(`  Message: ${error.message}`)
    } else if (error.tag === "Expected") {
      console.log(`  Expected: ${error.items}`)
    } else if (error.tag === "Unexpected") {
      console.log(`  Found: ${error.found}`)
    }
    console.log(`  Context: [${error.context.join(" > ")}]`)
  })
  
  console.log("\n--- Position Verification ---")
  const span = primary.span
  console.log(`Reported position: line ${span.line}, column ${span.column}`)
  console.log(`Reported offset: ${span.offset}`)
  console.log(`Input length: ${originalInput.length}`)
  console.log(`Expected offset: ${originalInput.length} (at end of input)`)
  console.log(`Offset matches expectation: ${span.offset === originalInput.length}`)
  
  // Manual position calculation
  let line = 1
  let column = 1
  for (let i = 0; i < span.offset && i < originalInput.length; i++) {
    if (originalInput[i] === '\n') {
      line++
      column = 1
    } else {
      column++
    }
  }
  console.log(`Manual calculation: line ${line}, column ${column}`)
  console.log(`Manual matches reported: line=${line === span.line}, column=${column === span.column}`)
  
  console.log("\n--- ErrorFormatter Output ---")
  const formatter = new ErrorFormatter("ansi")
  const formatted = formatter.format(bundle)
  console.log(formatted)
  
  console.log("\n--- Character-by-character position map ---")
  console.log("Index: 0123456789012345")
  console.log("       1         2")
  console.log(`Input: ${originalInput}`)
  console.log(`Error: ${" ".repeat(span.offset)}^`)
  console.log(`Should:${" ".repeat(originalInput.length)}^`)
  
} else {
  console.log("âŒ Unexpected success - parser should have failed!")
}
</file>

<file path="examples/ini-parser.ts">
import { char, string, parser, ErrorFormatter, many1, takeUpto } from "../src"

const iniParser = parser(function* () {
  yield* char("[")
  const value = yield* takeUpto(
    string("]\n").withError(() => "Missing closing bracket ']'")
  )
  yield* char("]")
  yield* char("\n")
  return
})

const input = "[database\nhost=localhost"

const result = iniParser.parse(input)
if (result.result._tag === "Left") {
  const formatter = new ErrorFormatter("ansi")
  console.log(formatter.format(result.result.left))
} else {
  console.log("Success:", result.result.right)
}
</file>

<file path=".npmignore">
.git
.gitignore
node_modules
src
tsconfig.json
biome.json
.vscode
.cursorrules
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Texoport

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/error-formatter.ts">
import type { ParseErr, ParseErrorBundle } from "./rich-errors"

export type ErrorFormat = "plain" | "ansi" | "html" | "json"

export type ErrorFormatterOptions = {
	maxContextLines?: number
	showHints?: boolean
	colorize?: boolean
	showContext?: boolean
	tabSize?: number
}

/**
 * Formats ParseErrorBundle into human-readable error messages with multiple output formats.
 * Supports plain text, ANSI colors, HTML, and JSON formats.
 */
export class ErrorFormatter {
	private _format: ErrorFormat
	private options: ErrorFormatterOptions

	constructor(
		format: ErrorFormat = "plain",
		options: ErrorFormatterOptions = {},
	) {
		this._format = format
		// Set default options
		this.options = {
			maxContextLines: 3,
			showHints: true,
			colorize: true,
			showContext: true,
			tabSize: 2,
			...options,
		}
	}

	/**
	 * Format a ParseErrorBundle into a string based on the configured format.
	 * 
	 * @param bundle - The error bundle to format
	 * @returns Formatted error message string
	 */
	format(bundle: ParseErrorBundle): string {
		switch (this._format) {
			case "ansi":
				return this.formatAnsi(bundle)
			case "html":
				return this.formatHtml(bundle)
			case "json":
				return this.formatJson(bundle)
			default:
				return this.formatPlain(bundle)
		}
	}

	/**
	 * Format error with ANSI color codes for terminal output.
	 */
	private formatAnsi(bundle: ParseErrorBundle): string {
		const primary = bundle.primary
		const lines = bundle.source.split("\n")
		const errorLine = lines[primary.span.line - 1] || ""

		const parts: string[] = []

		// Error header with location
		parts.push(
			`\x1b[31mError\x1b[0m at line ${primary.span.line}, column ${primary.span.column}:`,
		)

		// Show context lines if enabled
		if (this.options.showContext && this.options.maxContextLines! > 0) {
			const contextLines = this.getContextLines(
				lines,
				primary.span.line - 1,
				this.options.maxContextLines!,
			)
			parts.push(...contextLines.map((line) => `  ${line}`))
		} else {
			// Just show the error line
			parts.push(`  ${errorLine}`)
		}

		// Add pointer arrow (accounting for line prefix)
		const linePrefix = `  >   ${primary.span.line.toString().padStart(3, " ")} | `
		const adjustedColumn = primary.span.column + linePrefix.length - 2 // -2 for the "  " we add
		const pointer = this.createPointer(adjustedColumn, primary.span.length)
		parts.push(`  ${pointer}`)

		// Error message
		parts.push(this.formatErrorMessage(primary))

		// Add hints if available
		const hints = this.getHints(primary)
		if (this.options.showHints && hints.length > 0) {
			parts.push("")
			for (const hint of hints) {
				parts.push(`  \x1b[36mDid you mean: ${hint}?\x1b[0m`)
			}
		}

		// Add context stack if available
		if (
			this.options.showContext &&
			primary.context &&
			primary.context.length > 0
		) {
			parts.push("")
			parts.push(`  \x1b[90mContext: ${primary.context.join(" > ")}\x1b[0m`)
		}

		return parts.join("\n")
	}

	/**
	 * Format error as plain text without colors.
	 */
	private formatPlain(bundle: ParseErrorBundle): string {
		const primary = bundle.primary
		const lines = bundle.source.split("\n")
		const errorLine = lines[primary.span.line - 1] || ""

		const parts: string[] = []

		// Error header
		parts.push(
			`Error at line ${primary.span.line}, column ${primary.span.column}:`,
		)

		// Show context lines
		if (this.options.showContext && this.options.maxContextLines! > 0) {
			const contextLines = this.getContextLines(
				lines,
				primary.span.line - 1,
				this.options.maxContextLines!,
			)
			parts.push(...contextLines.map((line) => `  ${line}`))
		} else {
			parts.push(`  ${errorLine}`)
		}

		// Add pointer (accounting for line prefix)
		const linePrefix = `  >   ${primary.span.line.toString().padStart(3, " ")} | `
		const adjustedColumn = primary.span.column + linePrefix.length - 2 // -2 for the "  " we add
		const pointer = this.createPointer(adjustedColumn, primary.span.length, false)
		parts.push(`  ${pointer}`)

		// Error message
		parts.push(this.formatErrorMessage(primary, false))

		// Add hints
		const hints = this.getHints(primary)
		if (this.options.showHints && hints.length > 0) {
			parts.push("")
			for (const hint of hints) {
				parts.push(`  Did you mean: ${hint}?`)
			}
		}

		// Add context
		if (
			this.options.showContext &&
			primary.context &&
			primary.context.length > 0
		) {
			parts.push("")
			parts.push(`  Context: ${primary.context.join(" > ")}`)
		}

		return parts.join("\n")
	}

	/**
	 * Format error as HTML with styling.
	 */
	private formatHtml(bundle: ParseErrorBundle): string {
		const primary = bundle.primary
		const lines = bundle.source.split("\n")
		const errorLine = lines[primary.span.line - 1] || ""

		const parts: string[] = []

		parts.push('<div class="parse-error">')

		// Error header
		parts.push(
			`  <div class="error-header">Error at line ${primary.span.line}, column ${primary.span.column}:</div>`,
		)

		// Code context
		parts.push('  <div class="error-context">')
		if (this.options.showContext && this.options.maxContextLines! > 0) {
			const contextLines = this.getContextLines(
				lines,
				primary.span.line - 1,
				this.options.maxContextLines!,
			)
			for (const line of contextLines) {
				parts.push(`    <div class="context-line">${this.escapeHtml(line)}</div>`)
			}
		} else {
			parts.push(
				`    <div class="error-line">${this.escapeHtml(errorLine)}</div>`,
			)
		}

		// Pointer (accounting for line prefix in plain text representation)
		const pointer = this.createPointer(primary.span.column, primary.span.length, false)
		parts.push(`    <div class="error-pointer">${pointer}</div>`)
		parts.push("  </div>")

		// Error message
		parts.push(
			`  <div class="error-message">${this.escapeHtml(this.formatErrorMessage(primary, false))}</div>`,
		)

		// Hints
		const hints = this.getHints(primary)
		if (this.options.showHints && hints.length > 0) {
			parts.push('  <div class="error-hints">')
			for (const hint of hints) {
				parts.push(
					`    <div class="hint">Did you mean: <span class="suggestion">${this.escapeHtml(hint)}</span>?</div>`,
				)
			}
			parts.push("  </div>")
		}

		// Context
		if (
			this.options.showContext &&
			primary.context &&
			primary.context.length > 0
		) {
			parts.push(
				`  <div class="error-context-stack">Context: ${primary.context.map((c) => `<span class="context-item">${this.escapeHtml(c)}</span>`).join(" &gt; ")}</div>`,
			)
		}

		parts.push("</div>")

		return parts.join("\n")
	}

	/**
	 * Format error as JSON for programmatic consumption.
	 */
	private formatJson(bundle: ParseErrorBundle): string {
		const primary = bundle.primary
		const lines = bundle.source.split("\n")

		const contextLines = this.options.showContext
			? this.getContextLines(
					lines,
					primary.span.line - 1,
					this.options.maxContextLines!,
			  )
			: [lines[primary.span.line - 1] || ""]

		return JSON.stringify(
			{
				error: {
					type: primary.tag,
					message: this.getPlainErrorMessage(primary),
					location: {
						line: primary.span.line,
						column: primary.span.column,
						offset: primary.span.offset,
						length: primary.span.length,
					},
					context: {
						lines: contextLines,
						stack: primary.context || [],
					},
					hints: this.getHints(primary),
					source: bundle.source,
				},
				allErrors: bundle.errors.map((err) => ({
					type: err.tag,
					location: {
						line: err.span.line,
						column: err.span.column,
						offset: err.span.offset,
						length: err.span.length,
					},
					context: err.context || [],
					...(err.tag === "Expected" && { items: err.items }),
					...(err.tag === "Unexpected" && { found: err.found }),
					...(err.tag === "Custom" && { 
						message: err.message,
						hints: err.hints 
					}),
				})),
			},
			null,
			this.options.tabSize,
		)
	}

	/**
	 * Format the error message based on error type.
	 */
	private formatErrorMessage(error: ParseErr, useColors: boolean = true): string {
		const red = useColors ? "\x1b[31m" : ""
		const yellow = useColors ? "\x1b[33m" : ""
		const reset = useColors ? "\x1b[0m" : ""

		switch (error.tag) {
			case "Expected":
				return `  ${yellow}Expected:${reset} ${error.items.join(" or ")}`
			case "Unexpected":
				return `  ${red}Unexpected:${reset} ${error.found}`
			case "Custom":
				return `  ${error.message}`
		}
	}

	/**
	 * Get plain error message without formatting.
	 */
	private getPlainErrorMessage(error: ParseErr): string {
		switch (error.tag) {
			case "Expected":
				return `Expected: ${error.items.join(" or ")}`
			case "Unexpected":
				return `Unexpected: ${error.found}`
			case "Custom":
				return error.message
		}
	}

	/**
	 * Create a pointer/caret pointing to the error location.
	 */
	private createPointer(
		column: number,
		length: number = 1,
		useColors: boolean = true,
	): string {
		const spaces = " ".repeat(Math.max(0, column - 1))
		const carets = "^".repeat(Math.max(1, length))
		const red = useColors ? "\x1b[31m" : ""
		const reset = useColors ? "\x1b[0m" : ""
		return `${spaces}${red}${carets}${reset}`
	}

	/**
	 * Get context lines around the error location.
	 */
	private getContextLines(
		allLines: string[],
		errorLineIndex: number,
		maxLines: number,
	): string[] {
		const contextRadius = Math.floor(maxLines / 2)
		const startLine = Math.max(0, errorLineIndex - contextRadius)
		const endLine = Math.min(allLines.length - 1, errorLineIndex + contextRadius)

		const contextLines: string[] = []
		for (let i = startLine; i <= endLine; i++) {
			const lineNum = i + 1
			const lineContent = allLines[i] || ""
			const isErrorLine = i === errorLineIndex
			const prefix = isErrorLine ? ">" : " "
			const paddedLineNum = lineNum.toString().padStart(3, " ")
			contextLines.push(`${prefix} ${paddedLineNum} | ${lineContent}`)
		}

		return contextLines
	}

	/**
	 * Escape HTML entities.
	 */
	private escapeHtml(text: string): string {
		return text
			.replace(/&/g, "&amp;")
			.replace(/</g, "&lt;")
			.replace(/>/g, "&gt;")
			.replace(/"/g, "&quot;")
			.replace(/'/g, "&#39;")
	}

	/**
	 * Create a new formatter with different options.
	 */
	withOptions(options: Partial<ErrorFormatterOptions>): ErrorFormatter {
		return new ErrorFormatter(this._format, { ...this.options, ...options })
	}

	/**
	 * Create a new formatter with a different format.
	 */
	withFormat(format: ErrorFormat): ErrorFormatter {
		return new ErrorFormatter(format, this.options)
	}

	/**
	 * Get hints from an error, handling the union type safely.
	 */
	private getHints(error: ParseErr): string[] {
		if (error.tag === "Custom" && error.hints) {
			return error.hints
		}
		if (error.tag === "Unexpected" && error.hints) {
			return error.hints
		}
		return []
	}
}

/**
 * Convenience functions for quick formatting.
 */
export const formatError = {
	plain: (bundle: ParseErrorBundle, options?: ErrorFormatterOptions) =>
		new ErrorFormatter("plain", options).format(bundle),
	ansi: (bundle: ParseErrorBundle, options?: ErrorFormatterOptions) =>
		new ErrorFormatter("ansi", options).format(bundle),
	html: (bundle: ParseErrorBundle, options?: ErrorFormatterOptions) =>
		new ErrorFormatter("html", options).format(bundle),
	json: (bundle: ParseErrorBundle, options?: ErrorFormatterOptions) =>
		new ErrorFormatter("json", options).format(bundle),
}
</file>

<file path="src/hints.ts">
import { Either } from "./either"
import { Parser } from "./parser"
import { type ParseErr, createSpan } from "./rich-errors"
import { State } from "./state"

/**
 * Calculate the Levenshtein distance between two strings.
 * This measures the minimum number of single-character edits (insertions, deletions, or substitutions)
 * required to change one string into another.
 * 
 * @param a - The first string
 * @param b - The second string
 * @returns The edit distance between the strings
 */
export function levenshteinDistance(a: string, b: string): number {
	const matrix = Array(b.length + 1)
		.fill(null)
		.map(() => Array(a.length + 1).fill(null))

	// Initialize first row and column
	for (let i = 0; i <= a.length; i++) matrix[0][i] = i
	for (let j = 0; j <= b.length; j++) matrix[j][0] = j

	// Fill the matrix
	for (let j = 1; j <= b.length; j++) {
		for (let i = 1; i <= a.length; i++) {
			const indicator = a[i - 1] === b[j - 1] ? 0 : 1
			matrix[j][i] = Math.min(
				matrix[j][i - 1] + 1, // deletion
				matrix[j - 1][i] + 1, // insertion
				matrix[j - 1][i - 1] + indicator, // substitution
			)
		}
	}

	return matrix[b.length][a.length]
}

/**
 * Generate helpful hints for a user's input based on a list of expected values.
 * Uses edit distance to find the closest matches and suggests them as "Did you mean..." options.
 * 
 * @param found - The string the user actually typed
 * @param expected - Array of valid/expected strings
 * @param maxDistance - Maximum edit distance to consider (default: 2)
 * @param maxHints - Maximum number of hints to return (default: 3)
 * @returns Array of suggested strings, sorted by edit distance
 */
export function generateHints(
	found: string,
	expected: string[],
	maxDistance: number = 2,
	maxHints: number = 3,
): string[] {
	const hints: Array<{ word: string; distance: number }> = []

	for (const candidate of expected) {
		const distance = levenshteinDistance(found, candidate)
		if (distance <= maxDistance && distance > 0) {
			hints.push({ word: candidate, distance })
		}
	}

	return hints
		.sort((a, b) => a.distance - b.distance)
		.slice(0, maxHints)
		.map((h) => h.word)
}

/**
 * Enhanced keyword parser that provides intelligent hints when the user types something similar.
 * 
 * @param keywords - Array of valid keywords to match against
 * @returns A function that creates a parser for a specific keyword with hint generation
 * 
 * @example
 * ```ts
 * const schemeKeywords = ["lambda", "let", "if", "cond", "define", "quote"]
 * const lambdaParser = keywordWithHints(schemeKeywords)("lambda")
 * 
 * // Parsing "lamdba" will suggest "lambda" as a hint
 * const result = lambdaParser.parse("lamdba")
 * ```
 */
export const keywordWithHints = (keywords: string[]) => (keyword: string) =>
	new Parser((state) => {
		if (state.remaining.startsWith(keyword)) {
			return Parser.succeed(keyword, State.consume(state, keyword.length))
		}

		// Try to extract what the user actually typed
		const match = state.remaining.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)
		const found = match ? match[0] : state.remaining[0] || "end of input"

		const hints = generateHints(found, keywords)

		const error: ParseErr = {
			tag: "Unexpected",
			span: createSpan(state, found.length),
			found,
			context: state.context.labelStack || [],
			...(hints.length > 0 && { hints }),
		}

		return Parser.failRich({ errors: [error] }, state)
	})

/**
 * Creates a parser that matches any of the provided keywords with hint generation.
 * 
 * @param keywords - Array of valid keywords
 * @returns A parser that matches any keyword and provides hints for typos
 * 
 * @example
 * ```ts
 * const jsKeywords = ["function", "const", "let", "var", "class", "if", "else"]
 * const keywordParser = anyKeywordWithHints(jsKeywords)
 * 
 * // Parsing "functoin" will suggest "function"
 * const result = keywordParser.parse("functoin")
 * ```
 */
export function anyKeywordWithHints<Ctx = {}>(
	keywords: string[],
): Parser<string, Ctx> {
	return new Parser((state) => {
		// Try each keyword
		for (const keyword of keywords) {
			if (state.remaining.startsWith(keyword)) {
				return Parser.succeed(keyword, State.consume(state, keyword.length))
			}
		}

		// No exact match found, try to extract what was typed and generate hints
		const match = state.remaining.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)
		const found = match ? match[0] : state.remaining[0] || "end of input"

		const hints = generateHints(found, keywords)

		const error: ParseErr = {
			tag: "Unexpected",
			span: createSpan(state, found.length),
			found,
			context: state.context.labelStack || [],
			...(hints.length > 0 && { hints }),
		}

		return Parser.failRich({ errors: [error] }, state)
	})
}

/**
 * Creates a parser for string literals with hint generation for common mistakes.
 * 
 * @param validStrings - Array of valid string values
 * @returns A parser that matches quoted strings and provides hints for typos
 * 
 * @example
 * ```ts
 * const colorParser = stringWithHints(["red", "green", "blue", "yellow"])
 * 
 * // Parsing '"gren"' will suggest "green"
 * const result = colorParser.parse('"gren"')
 * ```
 */
export function stringWithHints<Ctx = {}>(
	validStrings: string[],
): Parser<string, Ctx> {
	return new Parser((state) => {
		// Must start with quote
		if (!state.remaining.startsWith('"')) {
			const error: ParseErr = {
				tag: "Expected",
				span: createSpan(state, 1),
				items: ["string literal"],
				context: state.context.labelStack || [],
			}
			return Parser.failRich({ errors: [error] }, state)
		}

		// Find the closing quote
		let i = 1
		let content = ""
		while (i < state.remaining.length && state.remaining[i] !== '"') {
			content += state.remaining[i]
			i++
		}

		if (i >= state.remaining.length) {
			const error: ParseErr = {
				tag: "Expected",
				span: createSpan(state, i),
				items: ["closing quote"],
				context: state.context.labelStack || [],
			}
			return Parser.failRich({ errors: [error] }, state)
		}

		// Check if content is valid
		if (validStrings.includes(content)) {
			return Parser.succeed(content, State.consume(state, i + 1))
		}

		// Generate hints for invalid content
		const hints = generateHints(content, validStrings)

		const error: ParseErr = {
			tag: "Unexpected",
			span: createSpan(state, i + 1),
			found: `"${content}"`,
			context: state.context.labelStack || [],
			...(hints.length > 0 && { hints: hints.map((h) => `"${h}"`) }),
		}

		return Parser.failRich({ errors: [error] }, state)
	})
}
</file>

<file path="tests/either.test.ts">
import { describe, expect, test } from "bun:test"
import { Either } from "../src/either"

const ea = (): Either<number, string> =>
  Either.gen(function* () {
    const a = yield* Either.right(5)
    const b = yield* Either.right(3)
    return a + b
  })

const eb = (): Either<number, string> =>
  Either.gen(function* () {
    const a = yield* ea()
    const aa = yield* ea()
    yield* Either.left("hi")
    return a + aa
  })

describe("either", () => {
  test("either right", () => {
    const result = ea()
    expect(Either.isRight(result)).toBe(true)
  })

  test("either left", () => {
    const result = eb()
    expect(Either.isLeft(result)).toBe(true)
  })
})
</file>

<file path="tests/error-formatter.test.ts">
import { describe, expect, test } from "bun:test"
import { ErrorFormatter, formatError, type ErrorFormatterOptions } from "../src/error-formatter"
import { type ParseErr, ParseErrorBundle, type Span } from "../src/rich-errors"

describe("error formatter", () => {
	// Sample error data for testing
	const span: Span = { offset: 8, length: 6, line: 2, column: 9 }
	const multiLineSource = `function test() {
  return functoin;
}
console.log("done");`

	const expectedError: ParseErr = {
		tag: "Expected",
		span,
		items: ["identifier", "number"],
		context: ["expression", "statement"],
	}

	const unexpectedError: ParseErr = {
		tag: "Unexpected",
		span,
		found: "functoin",
		context: ["function", "statement"],
	}

	const customErrorWithHints: ParseErr = {
		tag: "Custom",
		span,
		message: "Invalid keyword",
		hints: ["function", "return"],
		context: ["declaration"],
	}

	describe("ErrorFormatter class", () => {
		test("creates formatter with default options", () => {
			const formatter = new ErrorFormatter()
			expect(formatter).toBeInstanceOf(ErrorFormatter)
		})

		test("creates formatter with custom format", () => {
			const formatter = new ErrorFormatter("ansi")
			expect(formatter).toBeInstanceOf(ErrorFormatter)
		})

		test("creates formatter with custom options", () => {
			const options: ErrorFormatterOptions = {
				maxContextLines: 5,
				showHints: false,
				showContext: false,
			}
			const formatter = new ErrorFormatter("plain", options)
			expect(formatter).toBeInstanceOf(ErrorFormatter)
		})

		test("withOptions creates new formatter", () => {
			const original = new ErrorFormatter("plain")
			const modified = original.withOptions({ showHints: false })
			expect(modified).not.toBe(original)
		})

		test("withFormat creates new formatter", () => {
			const original = new ErrorFormatter("plain")
			const modified = original.withFormat("ansi")
			expect(modified).not.toBe(original)
		})
	})

	describe("plain text formatting", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)
		const formatter = new ErrorFormatter("plain")

		test("formats basic error message", () => {
			const result = formatter.format(bundle)

			expect(result).toContain("Error at line 2, column 9")
			expect(result).toContain("Expected: identifier or number")
			expect(result).toContain("functoin")
		})

		test("includes pointer arrow", () => {
			const result = formatter.format(bundle)
			expect(result).toContain("^")
		})

		test("includes context stack", () => {
			const result = formatter.format(bundle)
			expect(result).toContain("Context: expression > statement")
		})

		test("formats unexpected error", () => {
			const unexpectedBundle = new ParseErrorBundle([unexpectedError], multiLineSource)
			const result = formatter.format(unexpectedBundle)

			expect(result).toContain("Unexpected: functoin")
		})

		test("formats custom error with hints", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const result = formatter.format(customBundle)

			expect(result).toContain("Invalid keyword")
			expect(result).toContain("Did you mean: function?")
			expect(result).toContain("Did you mean: return?")
		})

		test("disables hints when showHints is false", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const noHintsFormatter = new ErrorFormatter("plain", { showHints: false })
			const result = noHintsFormatter.format(customBundle)

			expect(result).not.toContain("Did you mean")
		})

		test("disables context when showContext is false", () => {
			const noContextFormatter = new ErrorFormatter("plain", { showContext: false })
			const result = noContextFormatter.format(bundle)

			expect(result).not.toContain("Context:")
		})
	})

	describe("ANSI formatting", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)
		const formatter = new ErrorFormatter("ansi")

		test("includes ANSI color codes", () => {
			const result = formatter.format(bundle)

			expect(result).toContain("\x1b[31m") // Red
			expect(result).toContain("\x1b[0m")  // Reset
		})

		test("formats hints with cyan color", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const result = formatter.format(customBundle)

			expect(result).toContain("\x1b[36m") // Cyan for hints
		})

		test("formats context with gray color", () => {
			const result = formatter.format(bundle)

			expect(result).toContain("\x1b[90m") // Gray for context
		})

		test("includes colored pointer", () => {
			const result = formatter.format(bundle)
			// Should have red caret(s) - might be multiple based on span length
			expect(result).toContain("\x1b[31m")
			expect(result).toContain("\x1b[0m")
			expect(result).toContain("^")
		})
	})

	describe("HTML formatting", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)
		const formatter = new ErrorFormatter("html")

		test("wraps in HTML structure", () => {
			const result = formatter.format(bundle)

			expect(result).toContain('<div class="parse-error">')
			expect(result).toContain('</div>')
		})

		test("includes proper CSS classes", () => {
			const result = formatter.format(bundle)

			expect(result).toContain('class="error-header"')
			expect(result).toContain('class="error-context"')
			expect(result).toContain('class="error-message"')
		})

		test("escapes HTML entities", () => {
			const htmlSource = 'if (x < 5 && y > "test") {'
			const htmlError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 4, length: 1, line: 1, column: 5 },
				found: "<script>",
				context: [],
			}
			const htmlBundle = new ParseErrorBundle([htmlError], htmlSource)
			const result = formatter.format(htmlBundle)

			expect(result).toContain("&lt;")
			expect(result).toContain("&gt;")
			expect(result).not.toContain("<script>")
		})

		test("formats hints with proper HTML", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const result = formatter.format(customBundle)

			expect(result).toContain('class="error-hints"')
			expect(result).toContain('class="suggestion"')
		})

		test("formats context stack with proper HTML", () => {
			const result = formatter.format(bundle)

			expect(result).toContain('class="context-item"')
			expect(result).toContain("&gt;") // HTML encoded >
		})
	})

	describe("JSON formatting", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)
		const formatter = new ErrorFormatter("json")

		test("produces valid JSON", () => {
			const result = formatter.format(bundle)
			expect(() => JSON.parse(result)).not.toThrow()
		})

		test("includes error location", () => {
			const result = formatter.format(bundle)
			const parsed = JSON.parse(result)

			expect(parsed.error.location.line).toBe(2)
			expect(parsed.error.location.column).toBe(9)
			expect(parsed.error.location.offset).toBe(8)
		})

		test("includes context information", () => {
			const result = formatter.format(bundle)
			const parsed = JSON.parse(result)

			expect(parsed.error.context.stack).toEqual(["expression", "statement"])
			expect(parsed.error.context.lines).toBeInstanceOf(Array)
		})

		test("includes all errors", () => {
			const multiErrorBundle = new ParseErrorBundle(
				[expectedError, unexpectedError, customErrorWithHints],
				multiLineSource,
			)
			const result = formatter.format(multiErrorBundle)
			const parsed = JSON.parse(result)

			expect(parsed.allErrors).toHaveLength(3)
			expect(parsed.allErrors[0].type).toBe("Expected")
			expect(parsed.allErrors[1].type).toBe("Unexpected")
			expect(parsed.allErrors[2].type).toBe("Custom")
		})

		test("includes hints for custom errors", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const result = formatter.format(customBundle)
			const parsed = JSON.parse(result)

			expect(parsed.error.hints).toEqual(["function", "return"])
		})

		test("respects tabSize option", () => {
			const customFormatter = new ErrorFormatter("json", { tabSize: 4 })
			const result = customFormatter.format(bundle)

			// Should be formatted with 4 spaces
			expect(result).toContain("    \"error\":")
		})
	})

	describe("context lines handling", () => {
		const longSource = `line 1
line 2
line 3
ERROR LINE HERE
line 5
line 6
line 7`

		const errorInMiddle: ParseErr = {
			tag: "Unexpected",
			span: { offset: 21, length: 5, line: 4, column: 1 },
			found: "ERROR",
			context: [],
		}

		const bundle = new ParseErrorBundle([errorInMiddle], longSource)

		test("shows context lines around error", () => {
			const formatter = new ErrorFormatter("plain", { maxContextLines: 3 })
			const result = formatter.format(bundle)

			expect(result).toContain("line 3")
			expect(result).toContain("ERROR LINE HERE")
			expect(result).toContain("line 5")
		})

		test("limits context lines", () => {
			const formatter = new ErrorFormatter("plain", { maxContextLines: 1 })
			const result = formatter.format(bundle)

			expect(result).toContain("ERROR LINE HERE")
			expect(result).not.toContain("line 2")
			expect(result).not.toContain("line 6")
		})

		test("handles errors at beginning of file", () => {
			const earlyError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 0, length: 4, line: 1, column: 1 },
				found: "line",
				context: [],
			}
			const earlyBundle = new ParseErrorBundle([earlyError], longSource)
			const result = new ErrorFormatter("plain").format(earlyBundle)

			expect(result).toContain("line 1")
		})

		test("handles errors at end of file", () => {
			const lateError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 50, length: 4, line: 7, column: 1 },
				found: "line",
				context: [],
			}
			const lateBundle = new ParseErrorBundle([lateError], longSource)
			const result = new ErrorFormatter("plain").format(lateBundle)

			expect(result).toContain("line 7")
		})
	})

	describe("convenience functions", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)

		test("formatError.plain", () => {
			const result = formatError.plain(bundle)
			expect(result).toContain("Error at line 2")
			expect(result).not.toContain("\x1b[") // No ANSI codes
		})

		test("formatError.ansi", () => {
			const result = formatError.ansi(bundle)
			expect(result).toContain("\x1b[31m") // ANSI colors
		})

		test("formatError.html", () => {
			const result = formatError.html(bundle)
			expect(result).toContain('<div class="parse-error">')
		})

		test("formatError.json", () => {
			const result = formatError.json(bundle)
			expect(() => JSON.parse(result)).not.toThrow()
		})

		test("convenience functions accept options", () => {
			const result = formatError.plain(bundle, { showHints: false })
			expect(result).not.toContain("Did you mean")
		})
	})

	describe("edge cases", () => {
		test("handles empty source", () => {
			const emptyError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 0, length: 0, line: 1, column: 1 },
				found: "end of input",
				context: [],
			}
			const emptyBundle = new ParseErrorBundle([emptyError], "")
			const result = new ErrorFormatter("plain").format(emptyBundle)

			expect(result).toContain("Error at line 1")
		})

		test("handles single line source", () => {
			const singleLineError: ParseErr = {
				tag: "Expected",
				span: { offset: 5, length: 1, line: 1, column: 6 },
				items: ["semicolon"],
				context: [],
			}
			const singleLineBundle = new ParseErrorBundle([singleLineError], "const x = 5")
			const result = new ErrorFormatter("plain").format(singleLineBundle)

			expect(result).toContain("const x = 5")
		})

		test("handles very long lines", () => {
			const longLine = "x".repeat(200)
			const longLineError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 100, length: 1, line: 1, column: 101 },
				found: "x",
				context: [],
			}
			const longLineBundle = new ParseErrorBundle([longLineError], longLine)
			const result = new ErrorFormatter("plain").format(longLineBundle)

			expect(result).toContain("x".repeat(100))
		})

		test("handles zero-length spans", () => {
			const zeroLengthError: ParseErr = {
				tag: "Expected",
				span: { offset: 5, length: 0, line: 1, column: 6 },
				items: ["semicolon"],
				context: [],
			}
			const bundle = new ParseErrorBundle([zeroLengthError], "const x = 5")
			const result = new ErrorFormatter("plain").format(bundle)

			expect(result).toContain("^") // Should still show pointer
		})
	})
})
</file>

<file path="tests/rich-errors.test.ts">
import { describe, expect, test } from "bun:test"
import {
  type ParseErr,
  ParseErrorBundle,
  type Span,
  createSpan,
  legacyError
} from "../src/rich-errors"
import { ParserError } from "../src/state"

describe("rich-errors", () => {
  describe("createSpan", () => {
    test("creates span with basic position", () => {
      const state = {
        pos: { offset: 10, line: 2, column: 5 }
      }
      const span = createSpan(state)

      expect(span).toEqual({
        offset: 10,
        length: 0,
        line: 2,
        column: 5
      })
    })

    test("creates span with custom length", () => {
      const state = {
        pos: { offset: 15, line: 3, column: 8 }
      }
      const span = createSpan(state, 5)

      expect(span).toEqual({
        offset: 15,
        length: 5,
        line: 3,
        column: 8
      })
    })
  })

  describe("ParseErr types", () => {
    test("creates Expected error", () => {
      const span: Span = { offset: 0, length: 1, line: 1, column: 1 }
      const error: ParseErr = {
        tag: "Expected",
        span,
        items: ["identifier", "number"],
        context: ["expression", "term"]
      }

      expect(error.tag).toBe("Expected")
      expect(error.items).toEqual(["identifier", "number"])
      expect(error.context).toEqual(["expression", "term"])
    })

    test("creates Unexpected error", () => {
      const span: Span = { offset: 5, length: 1, line: 1, column: 6 }
      const error: ParseErr = {
        tag: "Unexpected",
        span,
        found: ";",
        context: ["statement"]
      }

      expect(error.tag).toBe("Unexpected")
      expect(error.found).toBe(";")
      expect(error.context).toEqual(["statement"])
    })

    test("creates Custom error without hints", () => {
      const span: Span = { offset: 10, length: 3, line: 2, column: 1 }
      const error: ParseErr = {
        tag: "Custom",
        span,
        message: "Invalid syntax",
        context: ["block"]
      }

      expect(error.tag).toBe("Custom")
      expect(error.message).toBe("Invalid syntax")
      expect(error.hints).toBeUndefined()
      expect(error.context).toEqual(["block"])
    })

    test("creates Custom error with hints", () => {
      const span: Span = { offset: 20, length: 6, line: 3, column: 5 }
      const error: ParseErr = {
        tag: "Custom",
        span,
        message: "Unknown keyword",
        hints: ["lambda", "let"],
        context: ["expression"]
      }

      expect(error.tag).toBe("Custom")
      expect(error.message).toBe("Unknown keyword")
      expect(error.hints).toEqual(["lambda", "let"])
      expect(error.context).toEqual(["expression"])
    })
  })

  describe("ParseErrorBundle", () => {
    const source = "hello world"

    test("single error bundle", () => {
      const error: ParseErr = {
        tag: "Expected",
        span: { offset: 5, length: 1, line: 1, column: 6 },
        items: ["space"],
        context: []
      }
      const bundle = new ParseErrorBundle([error], source)

      expect(bundle.errors).toHaveLength(1)
      expect(bundle.primary).toBe(error)
      expect(bundle.primaryErrors).toEqual([error])
    })

    test("multiple errors - primary is furthest", () => {
      const error1: ParseErr = {
        tag: "Expected",
        span: { offset: 2, length: 1, line: 1, column: 3 },
        items: ["letter"],
        context: []
      }
      const error2: ParseErr = {
        tag: "Unexpected",
        span: { offset: 8, length: 1, line: 1, column: 9 },
        found: "d",
        context: []
      }
      const error3: ParseErr = {
        tag: "Custom",
        span: { offset: 5, length: 1, line: 1, column: 6 },
        message: "Custom error",
        context: []
      }

      const bundle = new ParseErrorBundle([error1, error2, error3], source)

      expect(bundle.errors).toHaveLength(3)
      expect(bundle.primary).toBe(error2) // furthest offset (8)
      expect(bundle.primaryErrors).toEqual([error2])
    })

    test("multiple errors at same furthest offset", () => {
      const error1: ParseErr = {
        tag: "Expected",
        span: { offset: 5, length: 1, line: 1, column: 6 },
        items: ["space"],
        context: []
      }
      const error2: ParseErr = {
        tag: "Expected",
        span: { offset: 10, length: 1, line: 1, column: 11 },
        items: ["punctuation"],
        context: []
      }
      const error3: ParseErr = {
        tag: "Unexpected",
        span: { offset: 10, length: 1, line: 1, column: 11 },
        found: "d",
        context: []
      }

      const bundle = new ParseErrorBundle([error1, error2, error3], source)

      expect(bundle.primary).toBe(error2) // first one at furthest offset
      expect(bundle.primaryErrors).toEqual([error2, error3]) // both at offset 10
    })

    test("empty errors array throws", () => {
      expect(() => new ParseErrorBundle([], source).primary).toThrow()
    })
  })

  describe("legacyError adapter", () => {
    const source = "test input"

    test("converts Expected error", () => {
      const error: ParseErr = {
        tag: "Expected",
        span: { offset: 0, length: 1, line: 1, column: 1 },
        items: ["identifier", "number"],
        context: ["expression"]
      }
      const bundle = new ParseErrorBundle([error], source)
      const legacy = legacyError(bundle)

      expect(legacy).toBeInstanceOf(ParserError)
      expect(legacy.message).toBe(
        'Expected: {"tag":"Expected","span":{"offset":0,"length":1,"line":1,"column":1},"items":["identifier","number"],"context":["expression"]}'
      )
      expect(legacy.expected).toEqual(["identifier", "number"])
      expect(legacy.found).toBeUndefined()
    })

    test("converts Unexpected error", () => {
      const error: ParseErr = {
        tag: "Unexpected",
        span: { offset: 5, length: 1, line: 1, column: 6 },
        found: ";",
        context: []
      }
      const bundle = new ParseErrorBundle([error], source)
      const legacy = legacyError(bundle)

      expect(legacy).toBeInstanceOf(ParserError)
      expect(legacy.message).toBe(
        'Unexpected: {"tag":"Unexpected","span":{"offset":5,"length":1,"line":1,"column":6},"found":";","context":[]}'
      )
      expect(legacy.expected).toEqual([])
      expect(legacy.found).toBe(";")
    })

    test("converts Custom error", () => {
      const error: ParseErr = {
        tag: "Custom",
        span: { offset: 10, length: 3, line: 2, column: 1 },
        message: "Invalid syntax error",
        hints: ["lambda"],
        context: ["expression"]
      }
      const bundle = new ParseErrorBundle([error], source)
      const legacy = legacyError(bundle)

      expect(legacy).toBeInstanceOf(ParserError)
      expect(legacy.message).toBe("Invalid syntax error")
      expect(legacy.expected).toEqual([])
      expect(legacy.found).toBeUndefined()
    })
  })
})
</file>

<file path=".gitignore">
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*
# updates.md
# AGENT.md

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="AGENT.md">
# Agent Guidelines for Parserator

## Commands

- **Build**: `bun run build` (runs tsup + build.ts)
- **Test**: `bun test` (all tests) or `bun test tests/combinators.test.ts` (single test file)
- **Typecheck**: `bun run typecheck` (tsc --noEmit)
- **Lint/Format**: `bunx @biomejs/biome check --write .` (Biome handles both)

## Code Style

- **Indentation**: Tabs (not spaces)
- **Quotes**: Double quotes for strings
- **Semicolons**: As needed (omit where possible)
- **Line width**: 80 characters max
- **Imports**: Auto-organized by Biome, re-exports via src/index.ts

## Naming Conventions

- **Types**: PascalCase (e.g., `ParserState`, `ParserOutput`)
- **Functions/Variables**: camelCase (e.g., `parseOrThrow`, `printErrorContext`)
- **Constants**: camelCase (e.g., `stringParser`, not UPPER_CASE)

## Architecture Patterns

- **Parser class**: Functional monadic design with chaining methods (.then, .map, .bind)
- **Error handling**: Custom ParserError with position tracking and context
- **State management**: Immutable ParserState with position tracking
- **Exports**: All public APIs re-exported through src/index.ts

## Advanced Error Handling Roadmap

Implement rich error system with: span-based errors, label/context tracking, automatic hint generation, error recovery combinators, multiple output formats (plain/ansi/html/json), and generator-friendly try/catch support. See full implementation guide for details on ParseErr types, ErrorFormatter, and migration strategy.
</file>

<file path="index.ts">
export * from "./src/chain"
export * from "./src/combinators"
export * from "./src/debug"
export * from "./src/either"
export * from "./src/errors"
export * from "./src/parser"
export * from "./src/state"
export * from "./src/types"
export * from "./src/utils"
</file>

<file path="tsup.config.ts">
import { defineConfig } from "tsup"

export default defineConfig({
  format: ["esm", "cjs"],
  entry: {
    index: "src/index.ts"
  },
  outDir: "dist",
  sourcemap: true,
  clean: true,
  dts: {
    resolve: true,
    entry: "src/index.ts"
  }
})
</file>

<file path="updates.md">
# Advanced Error Handling Implementation Guide for Parserator

Based on the error handling report, here's a detailed implementation guide for the most impactful improvements to parserator's error system.

## 1. Rich Error Value System

### Current State

```ts
class ParserError {
  constructor(
    public message: string,
    public expected: string[],
    public found?: string
  ) {}
}
```

### Target Implementation

```ts
export type Span = {
  offset: number;
  length: number;
  line: number;
  column: number;
};

export type ParseErr =
  | { tag: "Expected"; span: Span; items: string[]; context: string[] }
  | { tag: "Unexpected"; span: Span; found: string; context: string[] }
  | {
      tag: "Custom";
      span: Span;
      message: string;
      hints?: string[];
      context: string[];
    };

export class ParseErrorBundle {
  constructor(
    public errors: ParseErr[],
    public source: string
  ) {}

  // Get the primary error (furthest right)
  get primary(): ParseErr {
    return this.errors.reduce((furthest, current) =>
      current.span.offset > furthest.span.offset ? current : furthest
    );
  }

  // Get all errors at the same furthest offset
  get primaryErrors(): ParseErr[] {
    const maxOffset = this.primary.span.offset;
    return this.errors.filter((err) => err.span.offset === maxOffset);
  }
}
```

**Benefits:**

- Precise error location with spans
- Multiple error types for different scenarios
- Context stack for nested parsing structures
- Support for hints and suggestions

## 2. Label System & Context Tracking

### Implementation

```ts
export class Parser<T, Ctx = {}> {
  // Add to existing Parser class
  label(name: string): Parser<T, Ctx> {
    return new Parser((state) => {
      const newState = {
        ...state,
        context: {
          ...state.context,
          labelStack: [...(state.context.labelStack || []), name],
        },
      };

      const result = this.run(newState);

      if (Either.isLeft(result.result)) {
        // Convert generic errors to labeled expectations
        const error = result.result.left;
        const labeledError: ParseErr = {
          tag: "Expected",
          span: createSpan(state),
          items: [name],
          context: newState.context.labelStack || [],
        };

        return Parser.fail({ errors: [labeledError] }, result.state);
      }

      return result;
    });
  }

  // Helper for creating semantic expectations
  expect(description: string): Parser<T, Ctx> {
    return this.withError(() => `Expected ${description}`).label(description);
  }
}

// Usage examples
const identifier = regex(/[a-zA-Z_][a-zA-Z0-9_]*/).label("identifier");
const number = regex(/\d+/).label("number").expect("a numeric value");
const functionCall = sequence([
  identifier.label("function name"),
  char("(").label("opening parenthesis"),
  sepBy(char(","), expression).label("arguments"),
  char(")").label("closing parenthesis"),
]).label("function call");
```

**End Result:**

```
Error at line 3, column 5:
  Expected function call
    Expected closing parenthesis
    Found: ';'

  Context: expression > function call > closing parenthesis
```

## 3. Automatic Hint Generation

### Implementation

```ts
function generateHints(found: string, expected: string[]): string[] {
  const maxDistance = 2;
  const hints: Array<{ word: string; distance: number }> = [];

  for (const candidate of expected) {
    const distance = levenshteinDistance(found, candidate);
    if (distance <= maxDistance && distance > 0) {
      hints.push({ word: candidate, distance });
    }
  }

  return hints
    .sort((a, b) => a.distance - b.distance)
    .slice(0, 3)
    .map((h) => h.word);
}

function levenshteinDistance(a: string, b: string): number {
  const matrix = Array(b.length + 1)
    .fill(null)
    .map(() => Array(a.length + 1).fill(null));

  for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
  for (let j = 0; j <= b.length; j++) matrix[j][0] = j;

  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[j][i] = Math.min(
        matrix[j][i - 1] + 1, // deletion
        matrix[j - 1][i] + 1, // insertion
        matrix[j - 1][i - 1] + indicator // substitution
      );
    }
  }

  return matrix[b.length][a.length];
}

// Enhanced string combinator with hints
export const keywordWithHints = (keywords: string[]) => (keyword: string) =>
  new Parser((state) => {
    if (state.remaining.startsWith(keyword)) {
      return Parser.succeed(keyword, State.consume(state, keyword.length));
    }

    // Try to extract what the user actually typed
    const match = state.remaining.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
    const found = match ? match[0] : state.remaining[0] || "end of input";

    const hints = generateHints(found, keywords);

    const error: ParseErr = {
      tag: "Unexpected",
      span: createSpan(state, found.length),
      found,
      context: state.context.labelStack || [],
      ...(hints.length > 0 && { hints }),
    };

    return Parser.fail({ errors: [error] }, state);
  });

// Usage for Scheme keywords
const schemeKeywords = ["lambda", "let", "if", "cond", "define", "quote"];
const lambda =
  keywordWithHints(schemeKeywords)("lambda").label("lambda keyword");
```

**End Result:**

```
Error at line 2, column 8:
  Unexpected symbol "lamdba"
  Expected: lambda keyword

  Did you mean: lambda?
```

## 4. Advanced Error Recovery Combinators

### Implementation

```ts
// Attempt combinator - backtrack on failure without consuming input
export function attempt<T, Ctx = {}>(parser: Parser<T, Ctx>): Parser<T, Ctx> {
  return new Parser((state) => {
    const result = parser.run(state);
    if (Either.isLeft(result.result)) {
      // Return failure but with original state (no consumption)
      return Parser.fail(result.result.left, state);
    }
    return result;
  });
}

// Recovery combinator
export function recover<T, R, Ctx = {}>(
  parser: Parser<T, Ctx>,
  recovery: Parser<R, Ctx>,
  errorNode: (error: ParseErr, recovered: R) => T
): Parser<T, Ctx> {
  return new Parser((state) => {
    const result = parser.run(state);
    if (Either.isLeft(result.result)) {
      // Try recovery
      const recoveryResult = recovery.run(result.state);
      if (Either.isRight(recoveryResult.result)) {
        const recovered = errorNode(
          result.result.left,
          recoveryResult.result.right
        );
        return Parser.succeed(recovered, recoveryResult.state);
      }
      // Recovery also failed
      return result;
    }
    return result;
  });
}

// Skip until synchronization point
export function skipUntilSync<T, Ctx = {}>(
  syncParser: Parser<T, Ctx>
): Parser<undefined, Ctx> {
  return new Parser((state) => {
    let currentState = state;

    while (!State.isAtEnd(currentState)) {
      const syncResult = syncParser.run(currentState);
      if (Either.isRight(syncResult.result)) {
        return Parser.succeed(undefined, currentState);
      }
      currentState = State.consume(currentState, 1);
    }

    return Parser.succeed(undefined, currentState);
  });
}

// Usage example for Scheme
type SchemeExpr = LispExpr.LispExpr | ErrorExpr;
type ErrorExpr = { type: "Error"; message: string; recovered?: SchemeExpr };

const expressionWithRecovery = recover(
  expr,
  skipUntilSync(or(char(")"), char("\n"), Parser.pure(undefined))),
  (error, _) => ({
    type: "Error" as const,
    message: error.message,
  })
).label("expression");
```

**End Result:**

```ts
// Input: "(lambda (x) (+ x y) (bad-syntax here) (define z 42))"
// Result: Successfully parses with error nodes for bad parts
[
  { type: "Lambda", params: ["x"], body: { type: "List", ... } },
  { type: "Error", message: "Unexpected token 'bad-syntax'" },
  { type: "Define", name: "z", value: { type: "Number", value: 42 } }
]
```

## 5. Context-Aware Error Formatting

### Implementation

```ts
export type ErrorFormat = "plain" | "ansi" | "html" | "json";

export class ErrorFormatter {
  constructor(
    private format: ErrorFormat = "plain",
    private options: {
      maxContextLines?: number;
      showHints?: boolean;
      colorize?: boolean;
    } = {}
  ) {}

  format(bundle: ParseErrorBundle): string {
    switch (this.format) {
      case "ansi":
        return this.formatAnsi(bundle);
      case "html":
        return this.formatHtml(bundle);
      case "json":
        return this.formatJson(bundle);
      default:
        return this.formatPlain(bundle);
    }
  }

  private formatAnsi(bundle: ParseErrorBundle): string {
    const primary = bundle.primary;
    const lines = bundle.source.split("\n");
    const errorLine = lines[primary.span.line - 1];

    return [
      `\x1b[31mError\x1b[0m at line ${primary.span.line}, column ${primary.span.column}:`,
      `  ${errorLine}`,
      `  ${" ".repeat(primary.span.column - 1)}\x1b[31m^\x1b[0m`,
      this.formatErrorMessage(primary),
      ...(primary.hints
        ? primary.hints.map((h) => `  \x1b[36mDid you mean: ${h}?\x1b[0m`)
        : []),
    ].join("\n");
  }

  private formatErrorMessage(error: ParseErr): string {
    switch (error.tag) {
      case "Expected":
        return `  Expected: ${error.items.join(" or ")}`;
      case "Unexpected":
        return `  Unexpected: ${error.found}`;
      case "Custom":
        return `  ${error.message}`;
    }
  }
}

// Usage
const formatter = new ErrorFormatter("ansi", { showHints: true });
const errorMessage = formatter.format(errorBundle);
console.log(errorMessage);
```

## 6. Generator-Friendly Error Handling

### Implementation

```ts
// Enhanced generator syntax with try/catch support
export function parserWithTryCatch<T, Ctx = {}>(
  f: () => Generator<Parser<any, Ctx>, T, any>
): Parser<T, Ctx> {
  return new Parser((state) => {
    const iterator = f();
    let current = iterator.next();
    let currentState = state;
    const errors: ParseErr[] = [];

    while (!current.done) {
      try {
        const { result, state: newState } = current.value.run(currentState);
        if (Either.isLeft(result)) {
          errors.push(result.left);
          // Allow generator to handle error
          current = iterator.throw(result.left);
          continue;
        }
        currentState = newState;
        current = iterator.next(result.right);
      } catch (error) {
        if (error instanceof ParseErr) {
          errors.push(error);
          return Parser.fail({ errors }, currentState);
        }
        throw error; // Re-throw non-parser errors
      }
    }

    return Parser.succeed(current.value, currentState);
  });
}

// Usage
const robustParser = parserWithTryCatch(function* () {
  try {
    const name = yield* identifier.label("function name");
    yield* char("(").label("opening paren");

    const args = yield* sepBy(char(","), expression).label("arguments");

    yield* char(")").label("closing paren");

    return { type: "FunctionCall", name, args };
  } catch (error: ParseErr) {
    // Add context and re-throw
    const contextualError: ParseErr = {
      ...error,
      context: [...error.context, "function call"],
    };
    throw contextualError;
  }
});
```

## 7. Usage Examples & Integration

### Enhanced Scheme Parser with Rich Errors

```ts
// Enhanced parser with all error improvements
const enhancedExpr = Parser.lazy(() =>
  or(
    boolean.label("boolean literal"),
    number.label("number literal"),
    stringLiteral.label("string literal"),
    symbol.label("symbol"),
    listParser.label("list expression")
  ).label("expression")
);

const enhancedLambda = parserWithTryCatch(function* () {
  try {
    yield* char("(").label("opening parenthesis");
    yield* keywordWithHints(["lambda", "let", "if"])("lambda");

    yield* char("(").label("parameter list start");
    const params = yield* many0(symbol).label("parameters");
    yield* char(")").label("parameter list end");

    const body = yield* enhancedExpr.label("lambda body");
    yield* char(")").label("closing parenthesis");

    return LispExpr.lambda(
      params.map((p) => p.name),
      body
    );
  } catch (error: ParseErr) {
    throw {
      ...error,
      context: [...error.context, "lambda expression"],
    };
  }
});

// Usage with comprehensive error reporting
const result = enhancedLambda.parse("(lamdba (x) (+ x y))");
if (result.result._tag === "Left") {
  const formatter = new ErrorFormatter("ansi");
  console.log(formatter.format(result.result.left));
}
```

**Expected Output:**

```
Error at line 1, column 2:
  (lamdba (x) (+ x y))
   ^
  Unexpected: lamdba
  Expected: lambda keyword

  Did you mean: lambda?

  Context: expression > lambda expression > lambda keyword
```

## 8. Migration Strategy

### Phase 1: Internal Error System

1. Implement `ParseErr` and `ParseErrorBundle` alongside existing `ParserError`
2. Add feature flag to switch between old/new error systems
3. Migrate core combinators to use new system internally

### Phase 2: Enhanced Combinators

1. Add `.label()` and `.expect()` methods
2. Implement `attempt()`, `recover()`, `skipUntilSync()`
3. Add hint generation for string/keyword parsers

### Phase 3: User-Facing Improvements

1. Expose `ErrorFormatter` with multiple output formats
2. Add `parserWithTryCatch` for generator syntax
3. Provide migration guide and examples

### Backwards Compatibility

```ts
// Adapter to maintain compatibility
export function legacyError(bundle: ParseErrorBundle): ParserError {
  const primary = bundle.primary;
  return new ParserError(
    primary.tag === "Custom"
      ? primary.message
      : `${primary.tag}: ${JSON.stringify(primary)}`,
    primary.tag === "Expected" ? primary.items : [],
    primary.tag === "Unexpected" ? primary.found : undefined
  );
}
```

This implementation provides a world-class error system that rivals Haskell's megaparsec while maintaining parserator's TypeScript-first, generator-friendly API. The improvements offer precise error locations, intelligent suggestions, graceful error recovery, and beautiful formattingâ€”all while keeping the migration path smooth for existing users.
</file>

<file path="examples/scheme/ast.ts">
export namespace LispExpr {
  export type LispExpr =
    | Symbol
    | Number
    | String
    | Boolean
    | List
    | If
    | Lambda
    | Let

  export type Symbol = {
    readonly type: "Symbol"
    name: string
  }

  export type Number = {
    readonly type: "Number"
    value: number
  }

  export type String = {
    readonly type: "String"
    value: string
  }

  export type Boolean = {
    readonly type: "Boolean"
    value: boolean
  }

  export type List = {
    readonly type: "List"
    items: LispExpr[]
  }

  export type If = {
    readonly type: "If"
    condition: LispExpr
    consequent: LispExpr
    alternate: LispExpr
  }

  export type Lambda = {
    readonly type: "Lambda"
    params: string[]
    body: LispExpr
  }

  export type Let = {
    readonly type: "Let"
    bindings: Array<{ name: string; value: LispExpr }>
    body: LispExpr
  }
}

export const LispExpr = {
  symbol: (name: string): LispExpr.LispExpr => ({
    type: "Symbol",
    name
  }),

  number: (value: number): LispExpr.LispExpr => ({
    type: "Number",
    value
  }),

  string: (value: string): LispExpr.LispExpr => ({
    type: "String",
    value
  }),

  bool: (value: boolean): LispExpr.LispExpr => ({
    type: "Boolean",
    value
  }),

  list: (items: LispExpr.LispExpr[]): LispExpr.LispExpr => ({
    type: "List",
    items
  }),

  if: (
    condition: LispExpr.LispExpr,
    consequent: LispExpr.LispExpr,
    alternate: LispExpr.LispExpr
  ): LispExpr.LispExpr => ({
    type: "If",
    condition,
    consequent,
    alternate
  }),

  lambda: (params: string[], body: LispExpr.LispExpr): LispExpr.LispExpr => ({
    type: "Lambda",
    params,
    body
  }),

  let: (
    bindings: Array<{
      name: string
      value: LispExpr.LispExpr
    }>,
    body: LispExpr.LispExpr
  ): LispExpr.LispExpr => ({
    type: "Let",
    bindings,
    body
  })
}
</file>

<file path="src/either.ts">
export type Either<R, L> = Left<L, R> | Right<R, L>

export class Left<L, R = never> {
  readonly _tag = "Left"
  constructor(public readonly left: L) {}
  *[Symbol.iterator](): Generator<Either<R, L>, R, any> {
    return yield this
  }
}

export class Right<R, L> {
  readonly _tag = "Right"
  constructor(public readonly right: R) {}
  *[Symbol.iterator](): Generator<Either<R, L>, R, any> {
    return yield this
  }
}

export const Either = {
  left<L, R = never>(l: L): Either<R, L> {
    return new Left(l)
  },

  right<R, L = never>(r: R): Either<R, L> {
    return new Right(r)
  },

  isLeft<R, L>(either: Either<R, L>): either is Left<L, R> {
    return either._tag === "Left"
  },

  isRight<R, L>(either: Either<R, L>): either is Right<R, L> {
    return either._tag === "Right"
  },

  match<R, L, T>(
    either: Either<R, L>,
    patterns: {
      onLeft: (left: L) => T
      onRight: (right: R) => T
    }
  ): T {
    if (Either.isLeft(either)) {
      return patterns.onLeft(either.left)
    }
    return patterns.onRight(either.right)
  },

  gen<R, L>(f: () => Generator<Either<any, L>, R, any>): Either<R, L> {
    const iterator = f()
    let current = iterator.next()

    while (!current.done) {
      const either = current.value
      if (Either.isLeft(either)) {
        return either
      }
      current = iterator.next(either.right)
    }

    return Either.right(current.value)
  }
}
</file>

<file path="src/rich-errors.ts">
export type Span = {
  offset: number
  length: number
  line: number
  column: number
}

export type ParseErr =
  | { tag: "Expected"; span: Span; items: string[]; context: string[] }
  | {
      tag: "Unexpected"
      span: Span
      found: string
      context: string[]
      hints?: string[]
    }
  | {
      tag: "Custom"
      span: Span
      message: string
      hints?: string[]
      context: string[]
    }

export class ParseErrorBundle {
  constructor(
    public errors: ParseErr[],
    public source: string
  ) {}

  // Get the primary error (furthest right)
  get primary(): ParseErr {
    return this.errors.reduce((furthest, current) =>
      current.span.offset > furthest.span.offset ? current : furthest
    )
  }

  // Get all errors at the same furthest offset
  get primaryErrors(): ParseErr[] {
    const maxOffset = this.primary.span.offset
    return this.errors.filter(err => err.span.offset === maxOffset)
  }
}

// Helper function to create a span from parser state
export function createSpan(
  state: { pos: { offset: number; line: number; column: number } },
  length: number = 0
): Span {
  return {
    offset: state.pos.offset,
    length,
    line: state.pos.line,
    column: state.pos.column
  }
}

// Adapter to maintain backwards compatibility with existing ParserError
import { ParserError } from "./state"

export function legacyError(bundle: ParseErrorBundle): ParserError {
  const primary = bundle.primary
  return new ParserError(
    primary.tag === "Custom" ?
      primary.message
    : `${primary.tag}: ${JSON.stringify(primary)}`,
    primary.tag === "Expected" ? primary.items : [],
    primary.tag === "Unexpected" ? primary.found : undefined
  )
}
</file>

<file path="src/types.ts">
export type Prettify<T> = { [K in keyof T]: T[K] } & {}

export type Last<T> = T extends [...any[], infer L] ? L : never
</file>

<file path="tests/hints.test.ts">
import { describe, expect, test } from "bun:test"
import { Either } from "../src/either"
import {
	anyKeywordWithHints,
	generateHints,
	keywordWithHints,
	levenshteinDistance,
	stringWithHints,
} from "../src/hints"
import type { ParseErrorBundle } from "../src/rich-errors"

// Helper to get error message from ParseErrorBundle
function getErrorMessage(bundle: ParseErrorBundle): string {
	const primary = bundle.primary
	if (primary.tag === "Custom") {
		return primary.message
	} else if (primary.tag === "Unexpected") {
		return `Unexpected: ${primary.found}`
	} else {
		return `Expected: ${primary.items.join(", ")}`
	}
}

describe("hint generation", () => {
	describe("levenshteinDistance", () => {
		test("identical strings have distance 0", () => {
			expect(levenshteinDistance("hello", "hello")).toBe(0)
			expect(levenshteinDistance("", "")).toBe(0)
			expect(levenshteinDistance("a", "a")).toBe(0)
		})

		test("empty string distances", () => {
			expect(levenshteinDistance("", "hello")).toBe(5)
			expect(levenshteinDistance("hello", "")).toBe(5)
		})

		test("single character operations", () => {
			// Single insertion
			expect(levenshteinDistance("cat", "cats")).toBe(1)
			// Single deletion
			expect(levenshteinDistance("cats", "cat")).toBe(1)
			// Single substitution
			expect(levenshteinDistance("cat", "bat")).toBe(1)
		})

		test("complex transformations", () => {
			expect(levenshteinDistance("kitten", "sitting")).toBe(3)
			expect(levenshteinDistance("saturday", "sunday")).toBe(3)
			expect(levenshteinDistance("lambda", "lamdba")).toBe(2) // transpose
		})

		test("case sensitivity", () => {
			expect(levenshteinDistance("Hello", "hello")).toBe(1)
			expect(levenshteinDistance("TEST", "test")).toBe(4)
		})
	})

	describe("generateHints", () => {
		const keywords = ["lambda", "let", "if", "cond", "define", "quote"]

		test("exact matches are excluded", () => {
			const hints = generateHints("lambda", keywords)
			expect(hints).toEqual([])
		})

		test("close matches within distance", () => {
			const hints = generateHints("lamdba", keywords)
			expect(hints).toContain("lambda")
		})

		test("sorts by edit distance", () => {
			const hints = generateHints("lam", keywords, 3) // Increase max distance
			// "lam" -> "let" = distance 2 (substitute a->e, add t)
			// "lam" -> "lambda" = distance 3 (add b, d, a)
			// So "let" should come before "lambda"
			expect(hints.length).toBeGreaterThan(0)
			expect(hints[0]).toBe("let") // closest match first
			expect(hints).toContain("lambda")
		})

		test("respects maxDistance parameter", () => {
			const hints = generateHints("xyz", keywords, 1)
			expect(hints).toEqual([]) // no keywords within distance 1
			
			const hintsWithHigherDistance = generateHints("xyz", keywords, 3)
			expect(hintsWithHigherDistance.length).toBeGreaterThan(0)
		})

		test("respects maxHints parameter", () => {
			const hints = generateHints("x", keywords, 5, 2)
			expect(hints.length).toBeLessThanOrEqual(2)
		})

		test("common programming typos", () => {
			const jsKeywords = ["function", "const", "let", "var", "class", "return"]
			
			expect(generateHints("functoin", jsKeywords)).toContain("function")
			expect(generateHints("calss", jsKeywords)).toContain("class")
			expect(generateHints("retrun", jsKeywords)).toContain("return")
		})

		test("empty expected array", () => {
			const hints = generateHints("test", [])
			expect(hints).toEqual([])
		})
	})

	describe("keywordWithHints", () => {
		const schemeKeywords = ["lambda", "let", "if", "cond", "define", "quote"]
		const lambdaParser = keywordWithHints(schemeKeywords)("lambda")

		test("matches exact keyword", () => {
			const result = lambdaParser.parse("lambda")
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("lambda")
			}
		})

		test("provides hints for typos", () => {
			const result = lambdaParser.parse("lamdba")
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				const primary = error.primary
				if (primary.tag === "Unexpected") {
					expect(primary.found).toBe("lamdba")
					expect(primary.hints).toContain("lambda")
				} else if (primary.tag === "Custom") {
					expect(primary.message).toContain("Unexpected")
					expect(primary.message).toContain("lamdba")
				}
			}
		})

		test("handles non-alphabetic characters", () => {
			const result = lambdaParser.parse("123")
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("Unexpected")
			}
		})

		test("handles end of input", () => {
			const result = lambdaParser.parse("")
			expect(Either.isLeft(result.result)).toBe(true)
		})

		test("keyword boundary handling", () => {
			const result = lambdaParser.parse("lambdaXYZ")
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("lambda")
				expect(result.state.remaining).toBe("XYZ")
			}
		})
	})

	describe("anyKeywordWithHints", () => {
		const keywords = ["red", "green", "blue", "yellow"]
		const colorParser = anyKeywordWithHints(keywords)

		test("matches any valid keyword", () => {
			for (const keyword of keywords) {
				const result = colorParser.parse(keyword)
				expect(Either.isRight(result.result)).toBe(true)
				if (Either.isRight(result.result)) {
					expect(result.result.right).toBe(keyword)
				}
			}
		})

		test("provides hints for invalid input", () => {
			const result = colorParser.parse("gren")
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("gren")
			}
		})

		test("chooses first matching keyword", () => {
			const overlappingKeywords = ["test", "testing", "tester"]
			const parser = anyKeywordWithHints(overlappingKeywords)
			const result = parser.parse("testing")
			
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("test")
			}
		})
	})

	describe("stringWithHints", () => {
		const validColors = ["red", "green", "blue", "yellow"]
		const colorStringParser = stringWithHints(validColors)

		test("matches valid quoted strings", () => {
			const result = colorStringParser.parse('"red"')
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("red")
			}
		})

		test("provides hints for invalid content", () => {
			const result = colorStringParser.parse('"gren"')
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("gren")
			}
		})

		test("requires opening quote", () => {
			const result = colorStringParser.parse("red")
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("Expected")
				expect(getErrorMessage(error)).toContain("string literal")
			}
		})

		test("requires closing quote", () => {
			const result = colorStringParser.parse('"red')
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("closing quote")
			}
		})

		test("handles empty strings", () => {
			const parserWithEmpty = stringWithHints(["", "test"])
			const result = parserWithEmpty.parse('""')
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("")
			}
		})
	})

	describe("integration with labels", () => {
		test("hints work with labeled parsers", () => {
			const keywords = ["lambda", "let", "if"]
			const parser = keywordWithHints(keywords)("lambda").label("lambda keyword")
			
			const result = parser.parse("lamdba")
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("Expected")
			}
		})

		test("context is preserved in hints", () => {
			const keywords = ["function", "method", "procedure"]
			const parser = anyKeywordWithHints(keywords)
				.label("declaration keyword")
				.label("function declaration")
			
			// This should preserve the context stack
			const result = parser.parse("functin")
			expect(Either.isLeft(result.result)).toBe(true)
		})
	})

	describe("real-world scenarios", () => {
		test("JavaScript keyword suggestions", () => {
			const jsKeywords = [
				"function", "const", "let", "var", "class", "if", "else", 
				"for", "while", "return", "import", "export", "default"
			]
			
			const testCases = [
				{ input: "functoin", expected: "function" },
				{ input: "retrun", expected: "return" },
				{ input: "calss", expected: "class" },
				{ input: "ipmort", expected: "import" },
			]

			for (const { input, expected } of testCases) {
				const hints = generateHints(input, jsKeywords)
				expect(hints).toContain(expected)
			}
		})

		test("SQL keyword suggestions", () => {
			const sqlKeywords = ["SELECT", "FROM", "WHERE", "ORDER", "GROUP", "INSERT", "UPDATE", "DELETE"]
			
			const hints = generateHints("SLECT", sqlKeywords)
			expect(hints).toContain("SELECT")
		})

		test("HTML tag suggestions", () => {
			const htmlTags = ["div", "span", "p", "h1", "h2", "button", "input", "form"]
			
			const hints = generateHints("botton", htmlTags)
			expect(hints).toContain("button")
		})
	})
})
</file>

<file path="tests/label-system.test.ts">
import { describe, expect, test } from "bun:test"
import { char, regex } from "../src/combinators"
import { Either } from "../src/either"
import { Parser } from "../src/parser"
import type { ParseErrorBundle } from "../src/rich-errors"

// Helper to get error message from ParseErrorBundle
function getErrorMessage(bundle: ParseErrorBundle): string {
	const primary = bundle.primary
	if (primary.tag === "Custom") {
		return primary.message
	} else if (primary.tag === "Unexpected") {
		return `Unexpected: ${primary.found}`
	} else {
		return `Expected: ${primary.items.join(", ")}`
	}
}

describe("label system", () => {
	describe(".label() method", () => {
		test("adds label to context stack", () => {
			const parser = char("a").label("letter a")
			const result = parser.parse("b")
			
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				// The error should reference the label
				expect(getErrorMessage(error)).toContain("Expected")
			}
		})

		test("nested labels create context stack", () => {
			const identifier = regex(/[a-zA-Z_][a-zA-Z0-9_]*/).label("identifier")
			const functionCall = char("(")
				.then(identifier.label("function name"))
				.thenDiscard(char(")"))
				.label("function call")
			
			const result = functionCall.parse("(123)")
			
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("Expected")
			}
		})

		test("successful parse preserves context", () => {
			const parser = char("a").label("letter a")
			const result = parser.parse("a")
			
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("a")
			}
		})

		test("label doesn't interfere with successful parsing", () => {
			const identifierParser = regex(/[a-zA-Z_][a-zA-Z0-9_]*/).label("identifier")
			const result = identifierParser.parse("hello")
			
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("hello")
			}
		})
	})

	describe(".expect() method", () => {
		test("combines label and error message", () => {
			const parser = regex(/\d+/).expect("a numeric value")
			const result = parser.parse("abc")
			
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				// The expect method creates both a label and a withError message
				// For now, just check that it contains some expected text
				expect(getErrorMessage(error)).toContain("Expected")
			}
		})

		test("expect works with successful parsing", () => {
			const parser = regex(/\d+/).expect("a numeric value")
			const result = parser.parse("123")
			
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("123")
			}
		})
	})

	describe("complex label scenarios", () => {
		test("multiple levels of labeling", () => {
			const digit = regex(/\d/).label("digit")
			const number = regex(/\d+/).label("number")
			const expression = number.label("expression")
			
			const result = expression.parse("abc")
			
			expect(Either.isLeft(result.result)).toBe(true)
		})

		test("label with generator syntax", () => {
			const parser = Parser.gen(function* () {
				const open = yield* char("(").label("opening parenthesis")
				const content = yield* regex(/[a-z]+/).label("content")
				const close = yield* char(")").label("closing parenthesis")
				return { open, content, close }
			}).label("parenthesized expression")
			
			const result = parser.parse("(hello]")
			
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("Expected")
			}
		})

		test("labels preserve through combinators", () => {
			const letterA = char("a").label("letter A")
			const letterB = char("b").label("letter B") 
			const either = letterA.then(letterB).label("sequence AB")
			
			const result = either.parse("ac")
			
			expect(Either.isLeft(result.result)).toBe(true)
		})
	})

	describe("context stack behavior", () => {
		test("label stack accumulates correctly", () => {
			// Create a parser that we can inspect the state of
			let capturedContext: any = null
			const inspector = new Parser((state) => {
				capturedContext = state.context
				return Parser.succeed("test", state)
			})

			const labeled = inspector.label("outer").label("inner")
			labeled.parse("test")

			expect(capturedContext?.labelStack).toEqual(["outer", "inner"])
		})

		test("label stack is isolated per parse", () => {
			let firstContext: any = null
			let secondContext: any = null

			const inspector1 = new Parser((state) => {
				firstContext = state.context
				return Parser.succeed("test1", state)
			})

			const inspector2 = new Parser((state) => {
				secondContext = state.context
				return Parser.succeed("test2", state)
			})

			inspector1.label("first").parse("test")
			inspector2.label("second").parse("test")

			expect(firstContext?.labelStack).toEqual(["first"])
			expect(secondContext?.labelStack).toEqual(["second"])
		})
	})
})
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,
    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "declaration": true,
    "declarationMap": true,
    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
</file>

<file path="tsconfig.types.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "emitDeclarationOnly": true,
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*.ts"]
}
</file>

<file path="typedoc.json">
{
  "$schema": "https://typedoc.org/schema.json",
  "entryPoints": ["src/index.ts"],
  "entryPointStrategy": "expand",
  "out": "docs",
  "name": "Parserator",
  "includeVersion": true,
  "navigationLinks": {
    "GitHub": "https://github.com/saiashirwad/parserator",
    "NPM": "https://www.npmjs.com/package/parserator"
  },
  "categorizeByGroup": true,
  "searchInComments": true,
  "readme": "README.md",
  "sort": ["source-order"],
  "excludePrivate": true,
  "excludeInternal": true,
  "validation": {
    "invalidLink": true,
    "notDocumented": true
  }
}
</file>

<file path="src/index.ts">
export * from "./chain"
export * from "./combinators"
export * from "./debug"
export * from "./either"
export * from "./error-formatter"
export * from "./errors"
export * from "./hints"
export * from "./parser"
export * from "./rich-errors"
export * from "./state"
export * from "./types"
export * from "./utils"
</file>

<file path="build.ts">
import { copyFile } from "node:fs/promises"
import { join } from "node:path"

async function main() {
  await copyFile(join("dist", "index.d.ts"), join("dist", "index.d.cts"))
}

main().catch(console.error)
</file>

<file path="examples/scheme/example.ts">
import { ErrorFormatter, ParserError } from "../../src"
import { lispParser } from "./parser"

const program = `(+ 5  (+ 3 5)`

const result = lispParser.parse(program)
if (result.result._tag === "Left") {
  const error = result.result.left
  const formatter = new ErrorFormatter("ansi")
  console.log(formatter.format(error))
}
</file>

<file path="src/utils.ts">
import { Parser } from "./parser"

export const peekState = new Parser(s => {
  return Parser.succeed(s, s)
})

export const peekRemaining = new Parser(s => {
  console.log(s.remaining)
  return Parser.succeed(s.remaining, s)
})

export const peekAhead = (n: number) =>
  new Parser(s => {
    return Parser.succeed(s.remaining.slice(0, n), s)
  })

export const peekLine = new Parser(s => {
  const restOfLine = s.remaining.slice(0, s.remaining.indexOf("\n"))
  console.log(restOfLine)
  return Parser.succeed(restOfLine, s)
})

export const peekUntil = (ch: string) =>
  new Parser(s => {
    const index = s.remaining.indexOf(ch)
    return Parser.succeed(s.remaining.slice(0, index), s)
  })
</file>

<file path="biome.json">
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": []
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "tab"
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": false
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double",
      "semicolons": "asNeeded",
      "lineWidth": 80
    }
  }
}
</file>

<file path="examples/scheme/scheme.test.ts">
import { describe, expect, it } from "bun:test"
import { LispExpr } from "./ast"
import { expr } from "./parser"

describe("scheme", () => {
  it("should parse a simple expression", () => {
    const result = expr.parseOrThrow("(+ 1 2)")
    expect(result).toEqual(
      LispExpr.list([
        LispExpr.symbol("+"),
        LispExpr.number(1),
        LispExpr.number(2)
      ])
    )
  })

  it("should parse a nested expression", () => {
    const result = expr.parseOrThrow("(+ 1 (+ 2 3))")
    expect(result).toEqual(
      LispExpr.list([
        LispExpr.symbol("+"),
        LispExpr.number(1),
        LispExpr.list([
          LispExpr.symbol("+"),
          LispExpr.number(2),
          LispExpr.number(3)
        ])
      ])
    )
  })

  it("should parse a string literal", () => {
    const result = expr.parseOrThrow('"hello"')
    expect(result).toEqual(LispExpr.string("hello"))
  })

  it("should parse a boolean literal", () => {
    const result1 = expr.parseOrThrow("#t")
    expect(result1).toEqual(LispExpr.bool(true))
    const result2 = expr.parseOrThrow("#f")
    expect(result2).toEqual(LispExpr.bool(false))
  })

  it("should parse a symbol", () => {
    const result = expr.parseOrThrow("hello")
    expect(result).toEqual(LispExpr.symbol("hello"))
  })

  it("should parse a symbol with special characters", () => {
    const result = expr.parseOrThrow("hello-world!")
    expect(result).toEqual(LispExpr.symbol("hello-world!"))
  })

  it("should fail on empty symbol", () => {
    const { result } = expr.parse("")
    expect(result._tag).toEqual("Left")
  })

  it("should parse a list", () => {
    const result = expr.parseOrThrow("(1 2 3)")
    expect(result).toEqual(
      LispExpr.list([
        LispExpr.number(1),
        LispExpr.number(2),
        LispExpr.number(3)
      ])
    )
  })

  it("should fail on empty list", () => {
    const { result } = expr.parse("()")
    expect(result._tag).toEqual("Left")
  })

  it("should parse a let expression with multiple bindings", () => {
    const result = expr.parseOrThrow("(let ((x 1) (y 2)) (+ x y))")
    expect(result).toEqual(
      LispExpr.let(
        [
          { name: "x", value: LispExpr.number(1) },
          { name: "y", value: LispExpr.number(2) }
        ],
        LispExpr.list([
          LispExpr.symbol("+"),
          LispExpr.symbol("x"),
          LispExpr.symbol("y")
        ])
      )
    )
  })

  it("should parse a let expression with a nested let expression", () => {
    const result = expr.parseOrThrow("(let ((x 1)) (let ((y 2)) (+ x y)))")
    expect(result).toEqual(
      LispExpr.let(
        [{ name: "x", value: LispExpr.number(1) }],
        LispExpr.let(
          [{ name: "y", value: LispExpr.number(2) }],
          LispExpr.list([
            LispExpr.symbol("+"),
            LispExpr.symbol("x"),
            LispExpr.symbol("y")
          ])
        )
      )
    )
  })

  it("should parse a lambda expression", () => {
    const result = expr.parseOrThrow("(lambda (x) (+ x 2))")
    expect(result).toEqual(
      LispExpr.lambda(
        ["x"],
        LispExpr.list([
          LispExpr.symbol("+"),
          LispExpr.symbol("x"),
          LispExpr.number(2)
        ])
      )
    )
  })

  it("should parse a let expression with a lambda expression", () => {
    const result = expr.parseOrThrow("(let ((x (lambda (y) y))) (x))")
    expect(result).toEqual(
      LispExpr.let(
        [
          {
            name: "x",
            value: LispExpr.lambda(["y"], LispExpr.symbol("y"))
          }
        ],
        LispExpr.list([LispExpr.symbol("x")])
      )
    )
  })

  it("should parse a list", () => {
    const result = expr.parseOrThrow("(a b c)")
    expect(result).toEqual(
      LispExpr.list([
        LispExpr.symbol("a"),
        LispExpr.symbol("b"),
        LispExpr.symbol("c")
      ])
    )
  })

  it("should parse a let expression with a single binding", () => {
    const result = expr.parseOrThrow("(let ((x 1)) x)")
    expect(result).toEqual(
      LispExpr.let(
        [{ name: "x", value: LispExpr.number(1) }],
        LispExpr.symbol("x")
      )
    )
  })
})
</file>

<file path="src/chain.ts">
import { Either } from "./either"
import { Parser } from "./parser"
import type { ParseErrorBundle } from "./rich-errors"

export type Chain<Ctx = {}> = {
  <T, U>(parser: Parser<T, Ctx>, fn1: (value: T) => Parser<U>): Parser<U>
  <T1, T2, T3>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>
  ): Parser<T3>
  <T1, T2, T3, T4>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>
  ): Parser<T4>
  <T1, T2, T3, T4, T5>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>
  ): Parser<T5>
  <T1, T2, T3, T4, T5, T6>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>
  ): Parser<T6>
  <T1, T2, T3, T4, T5, T6, T7>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>,
    fn6: (value: T6) => Parser<T7, Ctx>
  ): Parser<T7>
  <T1, T2, T3, T4, T5, T6, T7, T8>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>,
    fn6: (value: T6) => Parser<T7, Ctx>,
    fn7: (value: T7) => Parser<T8, Ctx>
  ): Parser<T8>
  <T1, T2, T3, T4, T5, T6, T7, T8, T9>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>,
    fn6: (value: T6) => Parser<T7, Ctx>,
    fn7: (value: T7) => Parser<T8, Ctx>,
    fn8: (value: T8) => Parser<T9, Ctx>
  ): Parser<T9>
  <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>,
    fn6: (value: T6) => Parser<T7, Ctx>,
    fn7: (value: T7) => Parser<T8, Ctx>,
    fn8: (value: T8) => Parser<T9, Ctx>,
    fn9: (value: T9) => Parser<T10, Ctx>
  ): Parser<T10>
}

export const chain = <Ctx = {}>(
  parser: Parser<any, Ctx>,
  ...fns: Array<(value: any) => Parser<any, Ctx>>
): Chain<Ctx> => {
  return new Parser<any, Ctx>(state => {
    let result = parser.run(state)
    for (const fn of fns) {
      const { result: parserResult, state: newState } = result
      if (Either.isLeft(parserResult)) {
        return { result: parserResult as unknown as Either<any, ParseErrorBundle>, state: newState }
      }
      const value = parserResult.right
      result = fn(value).run(newState)
    }
    return result
  }) as any
}
</file>

<file path="src/errors.ts">
import type { ParserError, ParserState, SourcePosition } from "./state"

export function printPosition(position: SourcePosition) {
  return `line ${position.line}, column ${position.column}`
}

export function printArrow(position: SourcePosition) {
  const lineNumberDigits = position.line.toString().length
  return " ".repeat(lineNumberDigits + 3 + position.column - 1) + "^"
}

export function printErrorContext<Ctx = {}>(
  state: ParserState<Ctx>,
  message?: string
) {
  return (
    "Parser Error:\n" +
    printErrorLine(state) +
    "\n" +
    printArrow(state.pos) +
    `${message ? `\n${message}` : ""}`
  )
}

export function printErrorLine<Ctx = {}>(state: ParserState<Ctx>) {
  const lines = state.context.source.split("\n")
  const lineNum = state.pos.line
  const startLine = Math.max(0, lineNum - 1)
  const endLine = lineNum
  const relevantLines = lines.slice(startLine, endLine + 1)
  const padding = lineNum.toString().length

  return relevantLines
    .map((line, i) => {
      const num = startLine + i + 1
      const paddedNum = num.toString().padStart(padding, " ")
      return `${paddedNum} | ${line}`
    })
    .join("\n")
}

export function printPositionWithOffset(position: SourcePosition) {
  return `line ${position.line}, column ${position.column}, offset ${position.offset}`
}

export function getErrorLine<Ctx = {}>(
  error: ParserError,
  state: ParserState<Ctx>
) {
  const errorLine = state.context.source.slice(
    state.pos.offset,
    state.context.source.indexOf("\n", state.pos.offset)
  )
  return errorLine
}
</file>

<file path="README.md">
# Parserator

âš ï¸ **Warning**: This library is still in early development and has still got some rough edges. The API will change without notice.

[![npm version](https://badge.fury.io/js/parserator.svg)](https://badge.fury.io/js/parserator)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

An elegant parser combinators library for Typescript.

## Table of contents

- [Introduction](#introduction)
- [Installation](#installation)
- [Basic Usage](#basic-usage)
- [Primitive Parsers](#primitive-parsers)
- [Combinators](#combinators)
- [Generator Syntax](#generator-syntax)
- [Error Handling](#error-handling)
- [Debugging](#debugging)
- [Advanced Usage](#advanced-usage)

## Introduction

Parserator is a TypeScript-first parser combinator library. It allows you to build complex parsers from simple building blocks, with full type inference and a clean, generator-based syntax.

Some key features:

- Zero dependencies
- Written in TypeScript with complete type inference
- Clean, generator-based syntax similar to async/await
- Rich set of built-in parsers and combinators
- Detailed error reporting
- Extensive debugging capabilities

## Installation

```bash
npm install parserator
```

Requirements:

- TypeScript 4.5+
- `strict` mode enabled in tsconfig

## Basic Usage

```typescript
import { Parser, char, many1, digit } from "parserator"

// Create a simple number parser
const numberParser = many1(digit).map(digits => parseInt(digits.join(""), 10))

// Parse a string
numberParser.parse("123") // => 123

// Handle errors safely
numberParser.safeParse("abc")
// => { success: false, error: ParserError }
```

## Primitive Parsers

```typescript
import { char, string, regex, alphabet, digit } from "parserator"

// Single character
char("a").parse("abc") // => "a"

// Exact string
string("hello").parse("hello world") // => "hello"

// Regular expression
regex(/[0-9]+/).parse("123abc") // => "123"

// Any letter
alphabet.parse("abc") // => "a"

// Any digit
digit.parse("123") // => "1"
```

## Combinators

### Repetition

```typescript
import { many0, many1, manyN } from "parserator"

// Zero or more
many0(digit).parse("123abc") // => ["1","2","3"]

// One or more
many1(digit).parse("123abc") // => ["1","2","3"]

// Exact count
manyN(digit, 2).parse("123") // => ["1","2"]
```

### Sequencing

```typescript
import { sequence, or, between, sepBy } from "parserator"

// Sequence of parsers
sequence([char("a"), char("b")]).parse("abc") // => "b"

// Choice between parsers
or(char("a"), char("b")).parse("abc") // => "a"

// Between delimiters
between(char("("), char(")"), digit).parse("(5)") // => "5"

// Separated values
sepBy(char(","), digit).parse("1,2,3") // => ["1","2","3"]
```

### String Operations

```typescript
import { takeUntil, takeUpto, parseUntilChar } from "parserator"

// Take until parser succeeds
takeUntil(char(";")).parse("hello;world") // => "hello"

// Take until parser would succeed
takeUpto(char(";")).parse("hello;world") // => "hello"

// Parse until character
parseUntilChar(";").parse("hello;world") // => "hello"
```

## Generator Syntax

Write parsers using a clean, generator-based syntax that feels like async/await:

```typescript
import { parser, char, many1, digit, optional } from "parserator"

// Parse a floating point number
const float = parser(function* () {
  // Parse optional sign
  const sign = yield* optional(char("-"))

  // Parse integer part
  const intPart = yield* many1(digit)

  // Parse optional fractional part
  const fractionalPart = yield* optional(
    parser(function* () {
      yield* char(".")
      return yield* many1(digit)
    })
  )

  // Parse optional exponent
  const exponentPart = yield* optional(
    parser(function* () {
      yield* char("e")
      const expSign = yield* optional(char("+") || char("-"))
      const expDigits = yield* many1(digit)
      return (expSign ?? "") + expDigits.join("")
    })
  )

  // Combine parts
  const numStr =
    (sign ?? "") +
    intPart.join("") +
    (fractionalPart ? "." + fractionalPart.join("") : "") +
    (exponentPart ? "e" + exponentPart : "")

  return parseFloat(numStr)
})

float.run("123.456e-7") // Right([1.23456e-5, ...])
```

## Error Handling

Customize error messages and add error callbacks:

```typescript
const parser = many1(digit)
  .error("Expected at least one digit")
  .errorCallback((error, state) => {
    return `Error at ${state.pos.line}:${state.pos.column}: ${error.message}`
  })

parser.run("abc")
// Left(ParserError: Error at 1:1: Expected at least one digit)
```

## Debugging

Debug tools to inspect parser behavior:

```typescript
import { debug, trace } from "parserator"

// Add debug output
const debuggedParser = debug(parser, "number-parser")

// Add trace points
const tracedParser = trace("Before parsing number").then(parser)
```

## Advanced Usage

### JSON Array Parser

```typescript
const jsonArray = parser(function* () {
  yield* char("[")
  yield* skipSpaces

  const items = yield* sepBy(
    char(","),
    parser(function* () {
      yield* skipSpaces
      const value = yield* or(stringParser, numberParser)
      yield* skipSpaces
      return value
    })
  )

  yield* skipSpaces
  yield* char("]")
  return items
})

jsonArray.run('["hello", 123, "world"]')
// Right([["hello", 123, "world"], ...])
```

### Recursive Parsers

```typescript
const expr: Parser<number> = Parser.lazy(() =>
  parser(function* () {
    yield* char("(")
    const left = yield* number
    const op = yield* or(char("+"), char("-"))
    const right = yield* expr
    yield* char(")")

    return op === "+" ? left + right : left - right
  })
)

expr.run("(1+(2-(3+4)))")
// Right([-4, ...])
```

## API Reference

### Parser<T>

The core Parser class that represents a parsing computation.

### Methods

#### run(input: string): ParserResult<T>

Run the parser on an input string

#### parseOrError(input: string): T | ParserError

Run parser and return result or error

#### parseOrThrow(input: string): T

Run parser and throw on error

#### map<B>(f: (a: T) => B): Parser<B>

Transform parser result

#### flatMap<B>(f: (a: T) => Parser<B>): Parser<B>

Chain parsers

#### error(message: string): Parser<T>

Set error message

#### errorCallback(cb: (error: ParserError, state: ParserState) => string): Parser<T>

Custom error handling

#### tap(callback: (state: ParserState, result: ParserResult<T>) => void): Parser<T>

Adds a tap point to observe the current state and result during parsing

#### withName(name: string): Parser<T>

Name the parser for better errors

### Static Methods

#### parser<T>(f: () => Generator<Parser<any>, T>): Parser<T>

Create parser using generator syntax

#### Parser.succeed<T>(value: T): Parser<T>

Create always-succeeding parser

#### Parser.fail(message: string): Parser<never>

Create always-failing parser

#### Parser.lazy<T>(f: () => Parser<T>): Parser<T>

Creates a new parser that lazily evaluates the given function. This is useful for creating recursive parsers.

### Basic Parsers

#### char(ch: string): Parser<string>

Creates a parser that matches a single character.

```ts
const parser = char("a")
parser.parse("abc") // => "a"
parser.parse("xyz") // throws error
```

#### string(str: string): Parser<string>

Creates a parser that matches an exact string in the input.

```ts
const parser = string("hello")
parser.parse("hello world") // => "hello"
parser.parse("goodbye") // throws error
```

#### regex(re: RegExp): Parser<string>

Creates a parser that matches input against a regular expression. The regex must match at the start of the input.

```ts
const parser = regex(/[0-9]+/)
parser.parse("123abc") // => "123"
```

#### alphabet: Parser<string>

A parser that matches any single alphabetic character (a-z, A-Z).

```ts
const parser = alphabet
parser.parse("abc") // => "a"
parser.parse("123") // throws error
```

#### digit: Parser<string>

A parser that matches any single digit character (0-9).

```ts
const parser = digit
parser.parse("123") // => "1"
parser.parse("abc") // throws error
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT
</file>

<file path="package.json">
{
  "name": "parserator",
  "version": "0.1.33",
  "description": "An elegant parser combinators library for Typescript",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "require": {
        "types": "./dist/index.d.cts",
        "default": "./dist/index.cjs"
      }
    }
  },
  "files": [
    "dist",
    "README.md"
  ],
  "scripts": {
    "build": "tsup && bun build.ts",
    "test": "bun test",
    "typecheck": "tsc --noEmit",
    "prepublishOnly": "bun run build && bun test",
    "publish:patch": "bun run build && npm version patch && npm publish --access public",
    "publish:minor": "bun run build && npm version minor && npm publish --access public",
    "publish:major": "bun run build && npm version major && npm publish --access public",
    "release:patch": "bun run build && bun test && bun run publish:patch",
    "release:minor": "bun run build && bun test && bun run publish:minor",
    "release:major": "bun run build && bun test && bun run publish:major",
    "format": "prettier --write ."
  },
  "keywords": [
    "parser",
    "parser-combinators",
    "typescript",
    "functional-programming"
  ],
  "author": "Sai (https://bsky.app/profile/texoport.in)",
  "license": "MIT",
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@types/bun": "^1.1.10",
    "prettier": "^3.5.3",
    "tsup": "^8.3.5",
    "typescript": "^5.0.0",
    "vitest": "^1.2.1"
  },
  "peerDependencies": {
    "typescript": "^5.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/saiashirwad/parserator.git"
  },
  "bugs": {
    "url": "https://github.com/saiashirwad/parserator/issues"
  },
  "homepage": "https://github.com/saiashirwad/parserator#readme",
  "prettier": {
    "printWidth": 80,
    "useTabs": false,
    "semi": false,
    "trailingComma": "none",
    "experimentalTernaries": true,
    "experimentalOperatorPosition": "end",
    "arrowParens": "avoid"
  }
}
</file>

<file path="tests/combinators.test.ts">
import { describe, expect, test } from "bun:test"
import {
  alphabet,
  between,
  char,
  digit,
  lookAhead,
  many0,
  many1,
  manyN,
  manyNExact,
  optional,
  or,
  regex,
  sepBy,
  sequence,
  skipSpaces,
  takeUntil
} from "../src/combinators"
import { Either } from "../src/either"
import { Parser } from "../src/parser"
import type { ParseErrorBundle } from "../src/rich-errors"

// Helper to get error message from ParseErrorBundle
function getErrorMessage(bundle: ParseErrorBundle): string {
	const primary = bundle.primary
	if (primary.tag === "Custom") {
		return primary.message
	} else if (primary.tag === "Unexpected") {
		return `Unexpected: ${primary.found}`
	} else {
		return `Expected: ${primary.items.join(", ")}`
	}
}

const stringParser = skipSpaces
  .then(char('"'))
  .then(many1(or(alphabet, digit)))
  .thenDiscard(char('"'))
  .map(s => s.join(""))

const integerParser = skipSpaces
  .then(many1(digit))
  .map(s => parseInt(s.join("")))
  .withError(() => "Expected an integer")

test("sepBy string array", () => {
  const p = char("[")
    .then(sepBy(char(","), or(stringParser, integerParser)))
    .thenDiscard(char("]"))
  expect(p.parseOrThrow('["hello", 2, "foo"]')).toEqual(["hello", 2, "foo"])
})

test("optional", () => {
  const p = optional(or(stringParser, integerParser))
  expect(p.parseOrThrow('"hello"')).toEqual("hello")
  expect(p.parseOrThrow("123")).toEqual(123)
})

test("sequence", () => {
  const p = sequence([
    stringParser,
    skipSpaces,
    char(","),
    skipSpaces,
    integerParser,
    skipSpaces,
    char(","),
    skipSpaces,
    integerParser
  ])
  expect(p.parseOrThrow('"hello", 123, 23')).toEqual(23)
})

describe("regex", () => {
  test("should match at the start of the input", () => {
    const p = regex(/foo/)
    expect(p.parseOrThrow("foo")).toEqual("foo")
  })

  test("should not match at the start of the input", () => {
    const p = regex(/foo/)
    expect(Either.isLeft(p.parse("bar").result)).toEqual(true)
  })

  test("should match at the start of the input with global flag", () => {
    const p = regex(/foo/g)
    expect(p.parseOrThrow("foo")).toEqual("foo")
  })
})

describe("basic combinators", () => {
  test("char", () => {
    const p = char("a")
    expect(p.parseOrThrow("a")).toBe("a")
    expect(Either.isLeft(p.parse("b").result)).toBe(true)
    expect(Either.isLeft(p.parse("").result)).toBe(true)
  })

  test("digit", () => {
    expect(digit.parseOrThrow("1")).toBe("1")
    expect(digit.parseOrThrow("9")).toBe("9")
    expect(Either.isLeft(digit.parse("a").result)).toBe(true)
    expect(Either.isLeft(digit.parse("").result)).toBe(true)
  })

  test("alphabet", () => {
    expect(alphabet.parseOrThrow("a")).toBe("a")
    expect(alphabet.parseOrThrow("Z")).toBe("Z")
    expect(Either.isLeft(alphabet.parse("1").result)).toBe(true)
    expect(Either.isLeft(alphabet.parse("").result)).toBe(true)
  })
})

describe("many combinators", () => {
  test("many1 requires at least one match", () => {
    const digits = many1(digit)
    expect(digits.parseOrThrow("123")).toEqual(["1", "2", "3"])
    expect(digits.parseOrThrow("1")).toEqual(["1"])
    expect(Either.isLeft(digits.parse("").result)).toBe(true)
    expect(Either.isLeft(digits.parse("abc").result)).toBe(true)
  })

  test("manyNExact requires exactly n matches", () => {
    const threeDigits = manyNExact(digit, 3)
    const t1 = threeDigits.parseOrError("123")
    expect(t1).toEqual(["1", "2", "3"])
    expect(Either.isLeft(threeDigits.parse("12").result)).toBe(true)
    const t2 = threeDigits.parse("1234")
    expect(Either.isLeft(t2.result)).toBe(true)
    expect(Either.isLeft(threeDigits.parse("").result)).toBe(true)
  })

  test("manyN with separator", () => {
    const threeDigitsComma = manyN(digit, 3, char(",")).thenDiscard(
      lookAhead(or(char("\n"), Parser.pure(undefined)))
    )
    expect(threeDigitsComma.parseOrThrow("1,2,3")).toEqual(["1", "2", "3"])
    expect(Either.isLeft(threeDigitsComma.parse("1,2").result)).toBe(true)
  })
})

describe("complex combinations", () => {
  test("nested array of numbers", () => {
    type Value = number | Value[]
    const value = Parser.lazy(() => or(number, array))
    const number = many1(digit).map(s => parseInt(s.join("")))
    const array: Parser<Value[]> = char("[")
      .then(sepBy(char(","), value))
      .thenDiscard(char("]"))

    expect(value.parseOrError("[1,2,[3,4],5]")).toEqual([1, 2, [3, 4], 5])
    expect(Either.isLeft(value.parse("[1,2,[3,4],]").result)).toBe(true)
  })

  test("simple expression parser", () => {
    type Expr = number
    const expr: Parser<Expr> = Parser.lazy(() => or(number, parens))
    const number = many1(digit).map(s => parseInt(s.join("")))
    const parens: Parser<number> = char("(")
      .then(expr)
      .thenDiscard(char(")"))
      .map((n: number) => n * 2)
    expect(expr.parseOrThrow("123")).toBe(123)
    expect(expr.parseOrThrow("(123)")).toBe(246)
    expect(expr.parseOrThrow("((123))")).toBe(492)
    expect(Either.isLeft(expr.parse("(123").result)).toBe(true)
  })

  test("key-value parser", () => {
    const key = many1(alphabet).map(s => s.join(""))
    const value = many1(digit).map(s => parseInt(s.join("")))
    const pair = key
      .thenDiscard(char(":"))
      .flatMap(k => value.map(v => [k, v] as const))
    const object = char("{")
      .then(sepBy(char(","), pair))
      .thenDiscard(char("}"))
      .map(Object.fromEntries)
    expect(object.parseOrThrow("{foo:123,bar:456}")).toEqual({
      foo: 123,
      bar: 456
    })
    expect(Either.isLeft(object.parse("{foo:123,}").result)).toBe(true)
  })
})

describe("error handling", () => {
  test("custom error messages", () => {
    const p = digit.withError(
      ({ state }) => `Expected a digit at position ${state.pos.offset}`
    )
    const { result } = p.parse("a")
    expect(Either.isLeft(result)).toBe(true)
  })

  test("error callback", () => {
    const p = digit.withError(
      ({ state }) => `Expected a digit at position ${state.pos.offset}`
    )
    const { result } = p.parse("a")
    expect(Either.isLeft(result)).toBe(true)
  })
})

describe("parser composition", () => {
  test("map transformation", () => {
    const p = digit.map(Number)
    expect(p.parseOrThrow("5")).toBe(5)
  })

  test("flatMap chaining", () => {
    const p = digit.flatMap(d => digit.map(d2 => Number(d + d2)))
    expect(p.parseOrThrow("12")).toBe(12)
  })

  test("then sequencing", () => {
    const p = char("[").then(digit).thenDiscard(char("]"))
    expect(p.parseOrThrow("[5]")).toBe("5")
  })
})

describe("advanced combinators", () => {
  test("lookAhead without consuming", () => {
    const p = lookAhead(char("a")).then(char("a"))
    expect(p.parseOrThrow("a")).toBe("a")
    expect(Either.isLeft(p.parse("b").result)).toBe(true)
  })

  test("sequence with type inference", () => {
    const p = sequence([digit.map(Number), char("+"), digit.map(Number)])
    expect(p.parseOrThrow("1+2")).toBe(2) // returns last value
  })

  test("sepBy with empty input", () => {
    const p = sepBy(char(","), digit)
    // expect(p.parseOrThrow("")).toEqual([])
    // expect(p.parseOrThrow("1")).toEqual(["1"])
    // expect(p.parseOrThrow("1,2,3")).toEqual(["1", "2", "3"])
  })

  test("optional with chaining", () => {
    const p = optional(char("-")).flatMap(sign =>
      many1(digit).map(digits => ({
        sign: sign === "-" ? -1 : 1,
        value: Number(digits.join(""))
      }))
    )

    expect(p.parseOrThrow("123")).toEqual({
      sign: 1,
      value: 123
    })
    expect(p.parseOrThrow("-123")).toEqual({
      sign: -1,
      value: 123
    })
  })
})

describe("error recovery", () => {
  test("custom error with context", () => {
    const identifier = regex(/[a-z]+/).withError(
      () => "Expected lowercase identifier"
    )
    const number = regex(/[0-9]+/).withError(() => "Expected number")
    const assignment = identifier
      .thenDiscard(char("=").thenDiscard(skipSpaces))
      .then(number)
      .withError(({ error }) => getErrorMessage(error))

    const { result } = assignment.parse("foo = bar")
    expect(Either.isLeft(result)).toBe(true)
  })

  test("error position tracking", () => {
    const p = many1(digit).thenDiscard(char(";"))
    const { result, state } = p.parse("123x")
    expect(Either.isLeft(result)).toBe(true)
  })
})

describe("between", () => {
  test("between parser", () => {
    const p = between(char("("), char(")"), many1(digit))
    expect(p.parseOrThrow("(123)")).toEqual(["1", "2", "3"])
  })

  test("between with nested parsers", () => {
    const strParser = char('"')
      .then(many1(or(alphabet, digit)))
      .thenDiscard(char('"'))
      .map(s => s.join(""))
    const p = between(
      char("["),
      char("]"),
      sepBy(
        many0(char(" "))
          .then(char(","))
          .then(many0(char(" "))),
        strParser
      )
    )
    const result = p.parseOrThrow('["hello", "world"]')
    expect(result).toEqual(["hello", "world"])
  })
})

describe("takeUntil", () => {
  test("takeUntil 1", () => {
    const p = takeUntil(char("a"))
    expect(p.parseOrThrow("123142abc")).toBe("123142")
  })

  test("takeUntil 2", () => {
    const strParser = char('"')
      .then(many1(or(alphabet, digit)))
      .thenDiscard(char('"'))
      .map(s => s.join(""))
    const p = takeUntil(strParser)
    expect(p.parseOrThrow('this is a "hello"')).toBe("this is a ")
  })
})
</file>

<file path="src/debug.ts">
import { Either } from "./either"
import { Parser } from "./parser"
import { type ParserOutput, type ParserState, State } from "./state"
/**
 * Creates a debug output for a parser's current state and result
 */
export function debugState<Ctx = {}>(
  label: string,
  state: ParserState<Ctx>,
  result: ParserOutput<any, Ctx>,
  options: {
    inputPreviewLength?: number
    separator?: string
  } = {}
) {
  const { inputPreviewLength = 20, separator = "=".repeat(40) } = options

  console.log(`\n=== ${label} ===`)
  console.log("Position:", State.printPosition(state))
  console.log(
    "Input:",
    JSON.stringify(
      state.remaining.slice(0, inputPreviewLength) +
        (state.remaining.length > inputPreviewLength ? "..." : "")
    )
  )
  console.log(
    "Result:",
    Either.isRight(result.result) ?
      `Success: ${JSON.stringify(result.result.right.value)}`
    : `Error: ${result.result.left.primary.tag === "Custom" ? 
        result.result.left.primary.message : 
        `${result.result.left.primary.tag}: ${JSON.stringify(result.result.left.primary)}`}`
  )
  console.log(separator)
}

/**
 * Adds debug output to a parser
 */
export function debug<T, Ctx = {}>(
  parser: Parser<T, Ctx>,
  label: string
): Parser<T, Ctx> {
  return parser.tap(({ state, result }) => debugState(label, state, result))
}

/**
 * Creates a parser that logs its input state and continues
 */
export function trace<Ctx = {}>(label: string): Parser<void, Ctx> {
  return new Parser(state => {
    console.log(`\n[TRACE] ${label}`)
    console.log("Position:", State.printPosition(state))
    console.log("Remaining:", JSON.stringify(state.remaining))
    return Parser.succeed(undefined, state)
  })
}

/**
 * Adds breakpoints to a parser for step-by-step debugging
 */
export function breakpoint<T, Ctx = {}>(
  parser: Parser<T, Ctx>,
  label: string
): Parser<T, Ctx> {
  return parser.tap(({ state, result }) => {
    debugState(label, state, result)
    // eslint-disable-next-line no-debugger
    debugger
  })
}

/**
 * Times how long a parser takes to run
 */
export function benchmark<T, Ctx = {}>(
  parser: Parser<T, Ctx>,
  label: string
): Parser<T, Ctx> {
  return new Parser(state => {
    const start = performance.now()
    const result = parser.run(state)
    const end = performance.now()
    console.log(`\n[BENCHMARK] ${label}: ${(end - start).toFixed(2)}ms`)
    return result
  })
}
</file>

<file path="src/state.ts">
import type { Either } from "./either"
import type { Prettify } from "./types"
import type { ParseErrorBundle } from "./rich-errors"

export type ParserContext<Ctx = {}> = Prettify<
  Ctx & {
    debug?: boolean
    source: string
    labelStack?: string[]
  }
>

export type ParserOptions = { name?: string }

export class ParserError {
  constructor(
    public message: string,
    public expected: string[],
    public found?: string
  ) {}
}

export type ParserOutput<T, Ctx = {}> = {
  state: ParserState<Ctx>
  result: Either<T, ParseErrorBundle>
}

export type SourcePosition = {
  line: number
  column: number
  offset: number
}

export type ParserState<Ctx = {}> = {
  remaining: string
  pos: SourcePosition
  context: ParserContext<Ctx>
}

/**
 * Utility object containing static methods for creating and manipulating parser state.
 */
export const State = {
  /**
   * Creates a new parser state from an input string.
   *
   * @param input - The input string to parse
   * @returns A new parser state initialized at the start of the input
   */
  fromInput<Ctx = {}>(
    input: string,
    context: ParserContext<Ctx>
  ): ParserState<Ctx> {
    return {
      remaining: input,
      pos: { line: 1, column: 1, offset: 0 },
      context
    }
  },

  /**
   * Creates a new state by consuming n characters from the current state.
   *
   * @param state - The current parser state
   * @param n - Number of characters to consume
   * @returns A new state with n characters consumed and position updated
   * @throws Error if attempting to consume more characters than remaining
   */
  consume<Ctx = {}>(state: ParserState<Ctx>, n: number): ParserState<Ctx> {
    if (n === 0) return state
    if (n > state.remaining.length) {
      throw new Error("Cannot consume more characters than remaining")
    }

    const consumed = state.remaining.slice(0, n)
    let { line, column, offset } = state.pos

    for (const char of consumed) {
      if (char === "\n") {
        line++
        column = 1
      } else {
        column++
      }
      offset++
    }

    return {
      remaining: state.remaining.slice(n),
      pos: { line, column, offset },
      context: state.context
    }
  },

  /**
   * Creates a new state by consuming a specific string from the current state.
   *
   * @param state - The current parser state
   * @param str - The string to consume
   * @returns A new state with the string consumed and position updated
   * @throws Error if the input doesn't start with the specified string
   */
  consumeString<Ctx = {}>(
    state: ParserState<Ctx>,
    str: string
  ): ParserState<Ctx> {
    if (!state.remaining.startsWith(str)) {
      throw new Error(
        `Cannot consume "${str}" - input "${state.remaining}" doesn't start with it`
      )
    }
    return State.consume(state, str.length)
  },

  move<Ctx = {}>(state: ParserState<Ctx>, moveBy: number) {
    return State.consume(
      {
        ...state,
        remaining: state.context.source,
        pos: { line: 1, column: 1, offset: 0 }
      },
      state.pos.offset + moveBy
    )
  },

  /**
   * Creates a new state by consuming characters while a predicate is true.
   *
   * @param state - The current parser state
   * @param predicate - Function that tests each character
   * @returns A new state with matching characters consumed
   */
  consumeWhile<Ctx = {}>(
    state: ParserState<Ctx>,
    predicate: (char: string) => boolean
  ): ParserState<Ctx> {
    let i = 0
    while (i < state.remaining.length && predicate(state.remaining[i])) {
      i++
    }
    return State.consume(state, i)
  },

  /**
   * Gets the next n characters from the input without consuming them.
   *
   * @param state - The current parser state
   * @param n - Number of characters to peek (default: 1)
   * @returns The next n characters as a string
   */
  peek<Ctx = {}>(state: ParserState<Ctx>, n: number = 1): string {
    return state.remaining.slice(0, n)
  },

  /**
   * Checks if the parser has reached the end of input.
   *
   * @param state - The current parser state
   * @returns True if at end of input, false otherwise
   */
  isAtEnd<Ctx = {}>(state: ParserState<Ctx>): boolean {
    return state.remaining.length === 0
  },

  printPosition<Ctx = {}>(state: ParserState<Ctx>): string {
    return `line ${state.pos.line}, column ${state.pos.column}, offset ${state.pos.offset}`
  }
}
</file>

<file path="examples/scheme/parser.ts">
import {
  char,
  digit,
  many0,
  many1,
  optional,
  or,
  Parser,
  parser,
  skipMany0,
  string,
  takeUpto
} from "../../src"
import { peekAhead, peekState } from "../../src/utils"
import { LispExpr } from "./ast"

const whitespace = skipMany0(or(char(" "), char("\n"), char("\t")))
const optionalWhitespace = optional(whitespace)

export let expr: Parser<LispExpr.LispExpr>

const symbol = parser(function* () {
  const name = yield* takeUpto(
    or(char(" "), char("\n"), char("\t"), char(")"), char("("))
  )
  if (name === "") return yield* Parser.error("Empty symbol")
  return LispExpr.symbol(name)
})

const number = parser(function* () {
  const sign = (yield* optional(char("-"))) ?? ""
  const digits = yield* many1(digit)
  const value = parseInt(sign + digits.join(""))
  return LispExpr.number(value)
})

const stringLiteral = parser(function* () {
  yield* char('"')
  const value = yield* takeUpto(char('"'))
  yield* char('"')
  return LispExpr.string(value)
})

const boolean = parser(function* () {
  const val = yield* or(string("#t"), string("#f"))
  return LispExpr.bool(val === "#t")
})

const atom = or(boolean, number, stringLiteral, symbol)

const list = parser(function* () {
  yield* char("(")
  yield* optionalWhitespace

  const items = yield* many0(parser(function* () {
    yield* optionalWhitespace
    const item = yield* expr
    yield* optionalWhitespace
    return item
  }))
  
  if (items.length === 0) {
    return yield* Parser.error("Empty list not allowed")
  }

  yield* char(")").withError(() => "Missing closing parenthesis ')'")
  return items
})

const listParser = list.flatMap(list =>
  parser(function* () {
    if (list.length === 3) {
      const [first, paramsExpr, bodyExpr] = list
      if (first.type === "Symbol" && paramsExpr.type === "List") {
        if (first.name === "lambda") {
          return yield* lambdaParser(paramsExpr, bodyExpr)
        }
        if (first.name === "let") {
          return yield* letParser(paramsExpr, bodyExpr)
        }
      }
    }
    return LispExpr.list(list)
  })
)

const lambdaParser = (paramsExpr: LispExpr.List, bodyExpr: LispExpr.LispExpr) =>
  parser(function* () {
    const params: string[] = []
    for (const item of paramsExpr.items) {
      if (item.type !== "Symbol") {
        return yield* Parser.error(
          "Invalid param definition for lambda expression"
        )
      }
      params.push(item.name)
    }

    return LispExpr.lambda(params, bodyExpr)
  })

const letParser = (bindingsExpr: LispExpr.List, bodyExpr: LispExpr.LispExpr) =>
  parser(function* () {
    const bindings: LispExpr.Let["bindings"] = []
    for (const item of bindingsExpr.items) {
      if (!(item.type === "List" && item.items.length === 2)) {
        return yield* Parser.error("Invalid let expression")
      }
      const [keyExpr, valExpr] = item.items
      if (keyExpr.type !== "Symbol") {
        return yield* Parser.error("Invalid let expression")
      }

      bindings.push({
        name: keyExpr.name,
        value: valExpr
      })
    }

    return LispExpr.let(bindings, bodyExpr)
  })

expr = Parser.lazy(() =>
  parser(function* () {
    yield* optionalWhitespace
    const isList = yield* peekAhead(1).map(x => x === "(")
    const result = yield* isList ? listParser : atom
    yield* optionalWhitespace
    return result
  })
)

export const lispParser = expr
</file>

<file path="src/parser.ts">
import { debug } from "./debug"
import { Either } from "./either"
import { type ParseErr, ParseErrorBundle, createSpan } from "./rich-errors"
import {
  type ParserContext,
  type ParserOptions,
  type ParserOutput,
  type ParserState,
  State
} from "./state"
import type { Prettify } from "./types"

type BindResult<T, K extends string, B> = Prettify<
  T & {
    [k in K]: B
  }
>

export class Parser<T, Ctx = {}> {
  constructor(
    /**
     * @internal
     */
    public run: (state: ParserState<Ctx>) => ParserOutput<T, Ctx>,
    public options?: ParserOptions
  ) {}

  name(name: string) {
    this.options = { ...this.options, name }
    return this
  }

  static succeed<T, Ctx = {}>(
    value: T,
    state: ParserState<Ctx>
  ): ParserOutput<T, Ctx> {
    return {
      state,
      result: Either.right(value)
    }
  }

  static fail<Ctx = {}>(
    error: {
      message: string
      expected?: string[]
      found?: string
    },
    state: ParserState<Ctx>
  ): ParserOutput<never, Ctx> {
    const span = createSpan({
      pos: {
        offset: state.pos.offset,
        line: state.pos.line,
        column: state.pos.column
      }
    })

    const parseErr: ParseErr = {
      tag: "Custom",
      span,
      message: error.message,
      context: state.context?.labelStack ?? [],
      hints: []
    }

    const bundle = new ParseErrorBundle([parseErr], state.context?.source ?? state.remaining)

    return {
      state,
      result: Either.left(bundle)
    }
  }

  static error<Ctx = {}>(
    message: string,
    expected: string[] = [],
    stateCallback?: (state: ParserState<Ctx>) => ParserState<Ctx>
  ): Parser<never, Ctx> {
    return new Parser(state => {
      return Parser.fail(
        { message, expected },
        stateCallback ? stateCallback(state) : state
      )
    })
  }

  /**
   * Adds an error message to the parser
   * @param makeMessage - A function that returns an error message
   * @returns A new parser with the error message added
   */
  withError(
    makeMessage: (errorCtx: {
      error: ParseErrorBundle
      state: ParserState<Ctx>
    }) => string
  ): Parser<T, Ctx> {
    return new Parser<T, Ctx>(state => {
      const output = this.run(state)
      if (Either.isLeft(output.result)) {
        return Parser.fail(
          {
            message: makeMessage({
              error: output.result.left,
              state: output.state
            })
          },
          output.state
        )
      }
      return output
    }, this.options)
  }

  parse(
    input: string,
    context = { source: input } as ParserContext<Ctx>
  ): ParserOutput<T, Ctx> {
    const { result, state } = this.run(State.fromInput(input, context))
    return { result, state }
  }

  withTrace(label: string): Parser<T, Ctx> {
    return new Parser<T, Ctx>(state => {
      if (!state.context?.debug) {
        return this.run(state)
      }
      return debug(this, label).run(state)
    }, this.options)
  }

  parseOrError(
    input: string,
    context = { source: input } as ParserContext<Ctx>
  ) {
    const { result } = this.run(State.fromInput(input, context))
    if (Either.isRight(result)) {
      return result.right
    }
    return result.left
  }

  parseOrThrow(
    input: string,
    context = { source: input } as ParserContext<Ctx>
  ): T {
    const { result } = this.parse(
      input,
      context ?? {
        source: input
      }
    )

    if (Either.isLeft(result)) {
      throw result.left
    }
    return result.right
  }

  map<B>(f: (a: T) => B): Parser<B, Ctx> {
    return new Parser<B, Ctx>(state => {
      const { result, state: newState } = this.run(state)
      if (Either.isLeft(result)) {
        return { state, result: result as unknown as Either<B, ParseErrorBundle> }
      }
      return Parser.succeed(f(result.right), newState)
    })
  }

  flatMap<B>(f: (a: T) => Parser<B, Ctx>): Parser<B, Ctx> {
    return new Parser<B, Ctx>(state => {
      const { result, state: newState } = this.run(state)
      if (Either.isLeft(result)) {
        return { state: newState, result: result as unknown as Either<B, ParseErrorBundle> }
      }
      const nextParser = f(result.right)
      return nextParser.run(newState)
    })
  }

  static pure = <A>(a: A): Parser<A> =>
    new Parser(state => Parser.succeed(a, state))

  static Do = Parser.pure({})

  /**
   * Creates a new parser that lazily evaluates the given function.
   * This is useful for creating recursive parsers.
   *
   * @param fn - A function that returns a parser
   * @returns A new parser that evaluates the function when parsing
   * @template T The type of value produced by the parser
   *
   * @example
   * ```ts
   * // Create a recursive parser for nested parentheses
   * const parens: Parser<string> = Parser.lazy(() =>
   *   between(
   *     char('('),
   *     char(')'),
   *     parens
   *   )
   * )
   * ```
   */
  static lazy<T>(fn: () => Parser<T>): Parser<T> {
    return new Parser(state => {
      const parser = fn()
      return parser.run(state)
    })
  }

  zip<B>(parserB: Parser<B, Ctx>): Parser<[T, B], Ctx> {
    return new Parser(state => {
      const { result: a, state: stateA } = this.run(state)
      if (Either.isLeft(a)) {
        return { result: a as unknown as Either<[T, B], ParseErrorBundle>, state: stateA }
      }
      const { result: b, state: stateB } = parserB.run(stateA)
      if (Either.isLeft(b)) {
        return { result: b as unknown as Either<[T, B], ParseErrorBundle>, state: stateB }
      }
      return Parser.succeed([a.right, b.right], stateB)
    })
  }

  then<B>(parserB: Parser<B, Ctx>): Parser<B, Ctx> {
    return this.zip(parserB).map(([_, b]) => b)
  }

  zipRight = this.then

  thenDiscard<B>(parserB: Parser<B, Ctx>): Parser<T, Ctx> {
    return this.zip(parserB).map(([a, _]) => a)
  }

  zipLeft = this.thenDiscard

  bind<K extends string, B>(
    k: K,
    other: Parser<B, Ctx> | ((a: T) => Parser<B, Ctx>)
  ): Parser<BindResult<T, K, B>, Ctx> {
    return new Parser<BindResult<T, K, B>, Ctx>(state => {
      const { result: resultA, state: stateA } = this.run(state)
      if (Either.isLeft(resultA)) {
        return { result: resultA as unknown as Either<BindResult<T, K, B>, ParseErrorBundle>, state: stateA }
      }
      const nextParser = other instanceof Parser ? other : other(resultA.right)
      const { result: resultB, state: stateB } = nextParser.run(stateA)
      if (Either.isLeft(resultB)) {
        return { result: resultB as unknown as Either<BindResult<T, K, B>, ParseErrorBundle>, state: stateB }
      }
      return Parser.succeed(
        { ...resultA.right, [k]: resultB.right } as BindResult<T, K, B>,
        stateB
      )
    }, this.options)
  }

  *[Symbol.iterator](): Generator<Parser<T, Ctx>, T, any> {
    return yield this
  }

  /**
   * Adds a tap point to observe the current state and result during parsing.
   * Useful for debugging parser behavior.
   *
   * @param callback - Function called with current state and result
   * @returns The same parser with the tap point added
   */
  tap(
    callback: (args: {
      state: ParserState<Ctx>
      result: ParserOutput<T, Ctx>
    }) => void
  ): Parser<T, Ctx> {
    return new Parser(state => {
      const result = this.run(state)
      callback({ state, result })
      return result
    }, this.options)
  }

  static gen<T, Ctx = unknown>(
    f: () => Generator<Parser<any, Ctx>, T, any>
  ): Parser<T, Ctx> {
    return new Parser<T, Ctx>(state => {
      const iterator = f()
      let current = iterator.next()
      let currentState: ParserState<Ctx> = state
      while (!current.done) {
        const { result, state: updatedState } = current.value.run(currentState)
        if (Either.isLeft(result)) {
          return { result: result as unknown as Either<T, ParseErrorBundle>, state: updatedState }
        }
        currentState = updatedState
        current = iterator.next(result.right)
      }
      return Parser.succeed(current.value, currentState)
    })
  }

  trim(parser: Parser<any, Ctx>) {
    return parser.then(this).thenDiscard(parser)
  }

  trimLeft(parser: Parser<any, Ctx>): Parser<T, Ctx> {
    return parser.then(this)
  }

  trimRight(parser: Parser<any, Ctx>): Parser<T, Ctx> {
    return this.thenDiscard(parser)
  }

  /**
   * Adds a label to this parser for better error messages
   * @param name - The label name to add to the context stack
   * @returns A new parser with the label added
   */
  label(name: string): Parser<T, Ctx> {
    return new Parser((state) => {
      const newState = {
        ...state,
        context: {
          ...state.context,
          labelStack: [name, ...(state.context.labelStack || [])],
        },
      }

      const result = this.run(newState)

      if (Either.isLeft(result.result)) {
        // Convert generic errors to labeled expectations
        const labeledError: ParseErr = {
          tag: "Expected",
          span: createSpan(state),
          items: [name],
          context: newState.context.labelStack || [],
        }

        return Parser.failRich({ errors: [labeledError] }, result.state)
      }

      return result
    }, this.options)
  }

  /**
   * Helper for creating semantic expectations with both label and error message
   * @param description - The description for both the label and error message
   * @returns A new parser with both labeling and error message
   */
  expect(description: string): Parser<T, Ctx> {
    return this.withError(() => `Expected ${description}`).label(description)
  }

  static failRich<Ctx = {}>(
    errorBundle: { errors: ParseErr[] },
    state: ParserState<Ctx>
  ): ParserOutput<never, Ctx> {
    const bundle = new ParseErrorBundle(
      errorBundle.errors,
      state.context?.source ?? state.remaining
    )

    return {
      state,
      result: Either.left(bundle)
    }
  }
}

export function parser<T, Ctx = unknown>(
  f: () => Generator<Parser<any, Ctx>, T, any>
): Parser<T, Ctx> {
  return new Parser<T, Ctx>(state => {
    const iterator = f()
    let current = iterator.next()
    let currentState: ParserState<Ctx> = state
    while (!current.done) {
      const { result, state: updatedState } = current.value.run(currentState)
      if (Either.isLeft(result)) {
        return { result: result as unknown as Either<T, ParseErrorBundle>, state: updatedState }
      }
      currentState = updatedState
      current = iterator.next(result.right)
    }
    return Parser.succeed(current.value, currentState)
  })
}
</file>

<file path="src/combinators.ts">
import { Either } from "./either"
import { Parser } from "./parser"
import type { ParseErrorBundle } from "./rich-errors"
import { type ParserState, State } from "./state"

/**
 * Creates a parser that looks ahead in the input stream without consuming any input.
 * The parser will succeed with the result of the given parser but won't advance the input position.
 *
 * @param parser - The parser to look ahead with
 * @returns A new parser that peeks at the input without consuming it
 * ```ts
 * const parser = lookAhead(char('a'))
 * parser.run('abc') // Right(['a', {...}])
 * // Input position remains at 'abc', 'a' is not consumed
 * ```
 */
export function lookAhead<T, Ctx = {}>(
  parser: Parser<T, Ctx>
): Parser<T | undefined, Ctx> {
  return new Parser(state => {
    const { result } = parser.run(state)
    if (Either.isRight(result)) {
      return Parser.succeed(result.right, state)
    }
    return Parser.succeed(undefined, state)
  })
}

/**
 * Creates a parser that succeeds only if the given parser fails to match.
 * If the parser succeeds, this parser fails with an error message.
 *
 * @param parser - The parser that should not match
 * @returns A new parser that succeeds only if the input parser fails
 * ```ts
 * const notA = notFollowedBy(char('a'))
 * notA.run('bcd') // Right([true, {...}]) - Succeeds because 'a' is not found
 * notA.run('abc') // Left(error) - Fails because 'a' is found
 * ```
 */
export function notFollowedBy<T, Ctx = {}>(
  parser: Parser<T, Ctx>
): Parser<boolean, Ctx> {
  return new Parser(state => {
    const { result, state: newState } = parser.run(state)
    if (Either.isRight(result)) {
      if (parser.options?.name) {
        const message = `Found ${parser.options.name} when it should not appear here`
        return Parser.fail({ message, expected: [] }, newState)
      }
      return Parser.fail(
        {
          message: "Expected not to follow",
          expected: [],
          found: state.remaining.at(0)
        },
        newState
      )
    }
    return Parser.succeed(true, newState)
  })
}

/**
 * Creates a parser that matches an exact string in the input.
 *
 * @param str - The string to match
 * @returns A parser that matches and consumes the exact string
 * ```ts
 * const parser = string("hello")
 * parser.run("hello world") // Right(["hello", {...}])
 * parser.run("goodbye") // Left(error)
 * ```
 */
export const string = <Ctx = {}>(str: string): Parser<string, Ctx> =>
  new Parser(
    state => {
      if (state.remaining.startsWith(str)) {
        return Parser.succeed(str, State.consume(state, str.length))
      }

      const message =
        `Expected '${str}', ` +
        `but found '${state.remaining.slice(0, str.length)}'`

      return Parser.fail(
        {
          message,
          expected: [str],
          found: state.remaining.slice(0, str.length)
        },
        state
      )
    },
    { name: str }
  )

/**
 * Creates a parser that matches an exact string literal type.
 * Similar to string parser but preserves the literal type information.
 *
 * @param str - The string literal to match
 * @returns A parser that matches and consumes the exact string with preserved type
 * ```ts
 * const parser = narrowedString("hello") // Parser<"hello">
 * parser.run("hello world") // Right(["hello", {...}])
 * parser.run("goodbye") // Left(error)
 * ```
 */
export function narrowedString<const T extends string, Ctx>(
  str: T
): Parser<T, Ctx> {
  return string(str) as any
}

/**
 * Creates a parser that matches a single character.
 *
 * @param ch - The character to match
 * @returns A parser that matches and consumes a single character
 * ```ts
 * const parser = char("a")
 * parser.run("abc") // Right(["a", {...}])
 * parser.run("xyz") // Left(error)
 * ```
 */
export const char = <T extends string, Ctx = {}>(ch: T): Parser<T, Ctx> => {
  return new Parser(
    state => {
      if (ch.length !== 1) {
        return Parser.fail(
          { message: "Incorrect usage of char parser.", expected: [ch] },
          state
        )
      }
      if (state.remaining[0] === ch) {
        return Parser.succeed(ch, State.consume(state, 1))
      }

      const message = `Expected ${ch} but found ${state.remaining.at(0)}.`
      return Parser.fail(
        { message, expected: [ch], found: state.remaining.at(0) },
        state
      )
    },
    { name: ch }
  )
}

/**
 * A parser that matches any single alphabetic character (a-z, A-Z).
 *
 * ```ts
 * const parser = alphabet
 * parser.run("abc") // Right(["a", {...}])
 * parser.run("123") // Left(error)
 * ```
 */
export const alphabet = new Parser(
  state => {
    if (State.isAtEnd(state)) {
      return Parser.fail(
        { message: "Unexpected end of input", expected: [] },
        state
      )
    }
    const first = state.remaining[0]
    if (first && /^[a-zA-Z]$/.test(first)) {
      return Parser.succeed(first, State.consume(state, 1))
    }
    const message = `Expected alphabetic character, but got '${first}'`
    return Parser.fail(
      { message, expected: [], found: state.remaining[0] },
      state
    )
  },
  { name: "alphabet" }
)

/**
 * A parser that matches any single digit character (0-9).
 *
 * ```ts
 * const parser = digit
 * parser.run("123") // Right(["1", {...}])
 * parser.run("abc") // Left(error)
 * ```
 */
export const digit = new Parser(
  state => {
    if (State.isAtEnd(state)) {
      return Parser.fail(
        { message: "Unexpected end of input", expected: [] },
        state
      )
    }
    const first = state.remaining[0]
    if (first && /^[0-9]$/.test(first)) {
      return Parser.succeed(first, State.consume(state, 1))
    }
    const message = `Expected digit, but got '${first}'`
    return Parser.fail(
      { message, expected: [], found: state.remaining[0] },
      state
    )
  },
  { name: "digit" }
)

/**
 * Creates a parser that matches zero or more occurrences of elements separated by a separator.
 *
 * @param sepParser - Parser for the separator between elements
 * @param parser - Parser for the elements
 * @returns A parser that produces an array of matched elements
 *
 * ```ts
 * const parser = sepBy(char(','), digit)
 * parser.run("1,2,3") // Right([["1", "2", "3"], {...}])
 * parser.run("") // Right([[], {...}])
 * ```
 */
// TODO: fix this
export function sepBy<S, T, Ctx>(
  sepParser: Parser<S, Ctx>,
  parser: Parser<T, Ctx>
): Parser<T[], Ctx> {
  return new Parser(state => {
    const results: T[] = []
    let currentState = state

    const { result: firstResult, state: firstState } = parser.run(currentState)
    if (Either.isLeft(firstResult)) {
      return { result: firstResult as unknown as Either<T[], ParseErrorBundle>, state: firstState }
    }

    results.push(firstResult.right)
    currentState = firstState

    while (true) {
      const { result: sepResult, state: sepState } = sepParser.run(currentState)
      if (Either.isLeft(sepResult)) {
        break
      }
      currentState = sepState

      const { result: itemResult, state: itemResultState } =
        parser.run(currentState)
      if (Either.isLeft(itemResult)) {
        return { result: itemResult as unknown as Either<T[], ParseErrorBundle>, state: itemResultState }
      }
      results.push(itemResult.right)
      currentState = itemResultState
    }

    return Parser.succeed(results, currentState)
  })
}

/**
 * Creates a parser that matches content between two string delimiters.
 *
 * @param start - The opening delimiter string
 * @param end - The closing delimiter string
 * @param parser - The parser for the content between delimiters
 * @returns A parser that matches content between delimiters
 *
 * ```ts
 * const parser = between('(', ')', digit)
 * parser.run('(5)') // Right(['5', {...}])
 * parser.run('5') // Left(error)
 * ```
 */
export function between<T, Ctx = {}>(
  start: Parser<any, Ctx>,
  end: Parser<any, Ctx>,
  parser: Parser<T, Ctx>
): Parser<any, Ctx> {
  return new Parser(state => {
    // Parse opening delimiter
    const startResult = start.run(state)
    if (Either.isLeft(startResult.result)) {
      return startResult
    }

    // Parse content
    const contentResult = parser.run(startResult.state)
    if (Either.isLeft(contentResult.result)) {
      return contentResult
    }

    // Parse closing delimiter
    const endResult = end.run(contentResult.state)
    if (Either.isLeft(endResult.result)) {
      return endResult
    }

    // Return the content and final state
    return Parser.succeed(contentResult.result.right, endResult.state)
  })
}

export function anyChar<Ctx = {}>() {
  return new Parser<string, Ctx>(state => {
    if (State.isAtEnd(state)) {
      return Parser.fail(
        { message: "Unexpected end of input", expected: [] },
        state
      )
    }
    return Parser.succeed(state.remaining[0], State.consume(state, 1))
  })
}

/**
 * Internal helper function for creating repetition parsers.
 *
 * @param count - Minimum number of repetitions required
 * @returns A function that creates a parser matching multiple occurrences
 */
function many_<S, T, Ctx = {}>(count: number) {
  return (
    parser: Parser<T, Ctx>,
    separator?: Parser<S, Ctx>
  ): Parser<T[], Ctx> => {
    return new Parser(state => {
      const results: T[] = []
      let currentState = state

      while (true) {
        // Try to parse the next item
        const itemResult = parser.run(currentState)
        if (Either.isLeft(itemResult.result)) {
          // If we have enough items, return success
          if (results.length >= count) {
            return Parser.succeed(results, currentState)
          }
          const message = `Expected at least ${count} occurrences, but only found ${results.length}`
          return Parser.fail({ message, expected: [] }, itemResult.state)
        }

        // Add the item and update state
        const { result: value, state: newState } = itemResult
        results.push(value.right)
        currentState = newState

        // If we have a separator, try to parse it
        if (separator) {
          const { result: sepResult, state } = separator.run(currentState)
          if (Either.isLeft(sepResult)) {
            break
          }
          currentState = state
        }
      }

      if (results.length >= count) {
        return Parser.succeed(results, currentState)
      }

      const message = `Expected at least ${count} occurrences, but only found ${results.length}`
      return Parser.fail({ message, expected: [] }, currentState)
    })
  }
}

/**
 * Creates a parser that matches zero or more occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @returns A parser that produces an array of all matches
 */
export const many0 = <S, T, Ctx = {}>(
  parser: Parser<T, Ctx>,
  separator?: Parser<S, Ctx>
) => many_<S, T, Ctx>(0)(parser, separator)

/**
 * Creates a parser that matches one or more occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @returns A parser that produces an array of all matches (at least one)
 */
export const many1 = <S, T, Ctx>(
  parser: Parser<T, Ctx>,
  separator?: Parser<S, Ctx>
) => many_<S, T, Ctx>(1)(parser, separator)

/**
 * Creates a parser that matches at least n occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @param n - Number of required repetitions
 * @returns A parser that produces an array of at least n matches
 */
export const manyN = <S, T, Ctx>(
  parser: Parser<T, Ctx>,
  n: number,
  separator?: Parser<S, Ctx>
) => many_<S, T, Ctx>(n)(parser, separator)

/**
 * Creates a parser that matches exactly n occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @param n - Number of required repetitions
 * @param separator - Optional parser to match between occurrences
 * @returns A parser that produces an array of exactly n matches
 */

export const manyNExact = <S, T, Ctx>(
  parser: Parser<T, Ctx>,
  n: number,
  separator?: Parser<S, Ctx>
) =>
  Parser.gen(function* () {
    const results = yield* manyN(parser, n, separator)
    if (results.length !== n) {
      const message = `Expected exactly ${n} occurrences, but found ${results.length}`
      return yield* Parser.error<Ctx>(message)
    }
    return results
  })

/**
 * Internal helper function for creating skipping repetition parsers.
 *
 * @param count - Minimum number of repetitions required
 * @returns A function that creates a parser skipping multiple occurrences
 */
function skipMany_<T, Ctx>(count: number) {
  return (parser: Parser<T, Ctx>): Parser<undefined, Ctx> => {
    return new Parser(state => {
      let currentState = state
      let successes = 0

      while (true) {
        const { result, state: newState } = parser.run(currentState)
        if (Either.isLeft(result)) {
          break
        }
        successes++
        currentState = newState
      }

      if (successes >= count) {
        return Parser.succeed(undefined, currentState)
      }
      const message = `Expected at least ${count} occurrences, but only found ${successes}`
      return Parser.fail({ message, expected: [] }, state)
    })
  }
}

/**
 * Creates a parser that skips zero or more occurrences of the input parser.
 *
 * @param parser - The parser to skip
 * @returns A parser that skips all matches
 */
export const skipMany0 = <T, Ctx = {}>(parser: Parser<T, Ctx>) =>
  skipMany_<T, Ctx>(0)(parser)

/**
 * Creates a parser that skips one or more occurrences of the input parser.
 *
 * @param parser - The parser to skip
 * @returns A parser that skips all matches (requires at least one)
 */
export const skipMany1 = <T, Ctx>(parser: Parser<T, Ctx>) =>
  skipMany_<T, Ctx>(1)(parser)

/**
 * Creates a parser that skips exactly n occurrences of the input parser.
 *
 * @param parser - The parser to skip
 * @param n - Number of required repetitions to skip
 * @returns A parser that skips exactly n matches
 */
export const skipManyN = <T, Ctx>(parser: Parser<T, Ctx>, n: number) =>
  skipMany_<T, Ctx>(n)(parser)

/**
 * Creates a parser that skips input until the given parser succeeds.
 *
 * @param parser - The parser to look for
 * @returns A parser that skips input until a match is found
 */
export function skipUntil<T, Ctx = {}>(
  parser: Parser<T, Ctx>
): Parser<undefined, Ctx> {
  return new Parser(state => {
    let currentState = state

    while (!State.isAtEnd(currentState)) {
      const { result, state: newState } = parser.run(currentState)
      if (Either.isRight(result)) {
        return Parser.succeed(undefined, newState)
      }
      currentState = State.consume(currentState, 1)
    }

    return Parser.succeed(undefined, currentState)
  })
}

/**
 * Creates a parser that takes input until the given parser succeeds.
 *
 * @param parser - The parser to look for
 * @returns A parser that takes input until a match is found
 */
export function takeUntil<T, Ctx = {}>(
  parser: Parser<T, Ctx>
): Parser<string, Ctx> {
  return new Parser(state => {
    let currentState = state
    let collected = ""

    while (!State.isAtEnd(currentState)) {
      const { result, state: newState } = parser.run(currentState)
      if (Either.isRight(result)) {
        return Parser.succeed(collected, newState)
      }
      collected += currentState.remaining[0]
      currentState = State.consume(currentState, 1)
    }

    return Parser.succeed(collected, currentState)
  })
}

/**
 * Creates a parser that takes input until the given character is found.
 *
 * @param char - The character to look for
 * @returns A parser that takes input until the character is found
 */
export function parseUntilChar<Ctx = {}>(char: string): Parser<string, Ctx> {
  return new Parser(state => {
    if (char.length !== 1) {
      return Parser.fail(
        {
          message: "Incorrect usage of parseUntilChar parser.",
          expected: [char]
        },
        state
      )
    }
    let currentState = state
    let collected = ""

    while (!State.isAtEnd(currentState)) {
      if (currentState.remaining[0] === char) {
        return Parser.succeed(collected, currentState)
      }
      collected += currentState.remaining[0]
      currentState = State.consume(currentState, 1)
    }

    const message = `Expected character ${char} but found ${collected}`
    return Parser.fail({ message, expected: [char] }, currentState)
  })
}

/**
 * A parser that skips any number of space characters.
 */
export const skipSpaces = new Parser(
  state =>
    Parser.succeed(
      undefined,
      State.consumeWhile(state, char => char === " ")
    ),
  { name: "skipSpaces" }
)

/**
 * Creates a parser that tries multiple parsers in order until one succeeds.
 *
 * @param parsers - Array of parsers to try
 * @returns A parser that succeeds if any of the input parsers succeed
 */
export function or<Parsers extends Parser<any, any>[], Ctx = {}>(
  ...parsers: Parsers
): Parser<Parsers[number] extends Parser<infer T, Ctx> ? T : never, Ctx> {
  return new Parser(state => {
    // const expectedNames: string[] = []
    for (const parser of parsers) {
      const { result, state: newState } = parser.run(state)
      if (Either.isRight(result)) {
        return Parser.succeed(result.right, newState)
      }
      // if (parser.options?.name) {
      // 	expectedNames.push(parser.options.name)
      // }
    }

    const message = `None of the ${parsers.length} choices could be satisfied`
    return Parser.fail({ message }, state)
  })
}

/**
 * Creates a parser that optionally matches the input parser.
 * If the parser fails, returns undefined without consuming input.
 *
 * @param parser - The parser to make optional
 * @returns A parser that either succeeds with a value or undefined
 */
export function optional<T, Ctx = {}>(parser: Parser<T, Ctx>) {
  return new Parser((state: ParserState<Ctx>) => {
    const { result, state: newState } = parser.run(state)
    if (Either.isLeft(result)) {
      return Parser.succeed(undefined, newState)
    }
    // return result
    return Parser.succeed(result.right, newState)
  })
}

type LastParser<T, Ctx = {}> =
  T extends [...any[], Parser<infer L, Ctx>] ? L : never

/**
 * Creates a parser that runs multiple parsers in sequence.
 * Returns the result of the last parser in the sequence.
 *
 * @param parsers - Array of parsers to run in sequence
 * @returns A parser that succeeds if all parsers succeed in sequence
 */
export function sequence<Parsers extends Parser<any>[], Ctx = {}>(
  parsers: [...Parsers]
): Parser<LastParser<Parsers, Ctx>, Ctx> {
  return new Parser((state: ParserState<Ctx>) => {
    const results: Parsers[] = []
    let currentState = state

    for (const parser of parsers) {
      const { result, state: newState } = parser.run(currentState)
      if (Either.isLeft(result)) {
        return { result: result as unknown as Either<LastParser<Parsers, Ctx>, ParseErrorBundle>, state: newState }
      }
      results.push(result.right)
      // TODO: fix this
      // @ts-expect-error this should be fine
      currentState = newState
    }

    return Parser.succeed(results.at(-1), currentState) as any
  })
}

/**
 * Creates a parser that matches input against a regular expression.
 * The regex must match at the start of the input.
 *
 * @param re - The regular expression to match against
 * @returns A parser that matches the regex pattern
 */
export const regex = <Ctx = {}>(re: RegExp): Parser<string, Ctx> => {
  // Create a new RegExp without global flag to ensure consistent behavior
  const nonGlobalRe = new RegExp(re.source, re.flags.replace("g", ""))

  return new Parser(
    state => {
      const match = nonGlobalRe.exec(state.remaining)
      if (match && match.index === 0) {
        const value = match[0]
        return Parser.succeed(value, state)
      }
      const message = `Expected ${re} but found ${state.remaining.slice(0, 10)}...`
      return Parser.fail(
        {
          message,
          expected: [re.toString()]
        },
        state
      )
    },
    { name: re.toString() }
  )
}

export function zip<A, B>(
  parserA: Parser<A>,
  parserB: Parser<B>
): Parser<[A, B]> {
  return parserA.zip(parserB)
}

export function then<A, B>(parserA: Parser<A>, parserB: Parser<B>): Parser<B> {
  return parserA.then(parserB)
}

export const zipRight = then

export function thenDiscard<A, B>(
  parserA: Parser<A>,
  parserB: Parser<B>
): Parser<A> {
  return parserA.thenDiscard(parserB)
}
export const zipLeft = thenDiscard

/**
 * Creates a parser that takes input until the given parser would succeed, without consuming the parser.
 *
 * @param parser - The parser to look for
 * @returns A parser that takes input until before a match would be found
 */
export function takeUpto<T>(parser: Parser<T>): Parser<string> {
  return new Parser(state => {
    let currentState = state
    let collected = ""

    while (!State.isAtEnd(currentState)) {
      const { result } = parser.run(currentState)
      if (Either.isRight(result)) {
        return Parser.succeed(collected, currentState)
      }
      collected += currentState.remaining[0]
      currentState = State.consume(currentState, 1)
    }

    return Parser.succeed(collected, currentState)
  })
}
</file>

</files>
