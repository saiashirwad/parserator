This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
examples/
  scheme/
    ast.ts
    error-debug.ts
    example.ts
    parser.ts
    scheme.test.ts
  ini-parser.ts
src/
  chain.ts
  combinators.ts
  debug.ts
  either.ts
  error-formatter.ts
  errors.ts
  hints.ts
  index.ts
  parser.ts
  rich-errors.ts
  state.ts
  types.ts
  utils.ts
tests/
  combinators.test.ts
  either.test.ts
  error-formatter.test.ts
  hints.test.ts
  label-system.test.ts
  regex-parsers.test.ts
  rich-errors.test.ts
  runtime-fixes.test.ts
.gitignore
.npmignore
AGENT.md
biome.json
build.ts
index.ts
LICENSE
package.json
README.md
todo.md
tsconfig.json
tsconfig.types.json
tsup.config.ts
typedoc.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".npmignore">
.git
.gitignore
node_modules
src
tsconfig.json
biome.json
.vscode
.cursorrules
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Texoport

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="examples/scheme/error-debug.ts">
import { lispParser } from "./parser"
import { ErrorFormatter } from "../../src"

const originalInput = "(+ 5  (+ 3 5)"
console.log("=== ParseErrorBundle Debug ===")
console.log(`Input: "${originalInput}"`)
console.log(`Length: ${originalInput.length}`)

const result = lispParser.parse(originalInput)
if (result.result._tag === "Left") {
  const bundle = result.result.left
  
  console.log("\n--- ParseErrorBundle Structure ---")
  console.log("Bundle type:", bundle.constructor.name)
  console.log("Number of errors:", bundle.errors.length)
  console.log("Source length:", bundle.source.length)
  console.log("Source matches input:", bundle.source === originalInput)
  
  console.log("\n--- Primary Error Analysis ---")
  const primary = bundle.primary
  console.log("Primary error tag:", primary.tag)
  console.log("Primary error span:", primary.span)
  console.log("Primary error message:", primary.tag === "Custom" ? primary.message : "N/A")
  console.log("Primary error context:", primary.context)
  
  console.log("\n--- All Errors Analysis ---")
  bundle.errors.forEach((error, i) => {
    console.log(`Error ${i + 1}:`)
    console.log(`  Tag: ${error.tag}`)
    console.log(`  Span: offset=${error.span.offset}, length=${error.span.length}, line=${error.span.line}, column=${error.span.column}`)
    if (error.tag === "Custom") {
      console.log(`  Message: ${error.message}`)
    } else if (error.tag === "Expected") {
      console.log(`  Expected: ${error.items}`)
    } else if (error.tag === "Unexpected") {
      console.log(`  Found: ${error.found}`)
    }
    console.log(`  Context: [${error.context.join(" > ")}]`)
  })
  
  console.log("\n--- Position Verification ---")
  const span = primary.span
  console.log(`Reported position: line ${span.line}, column ${span.column}`)
  console.log(`Reported offset: ${span.offset}`)
  console.log(`Input length: ${originalInput.length}`)
  console.log(`Expected offset: ${originalInput.length} (at end of input)`)
  console.log(`Offset matches expectation: ${span.offset === originalInput.length}`)
  
  // Manual position calculation
  let line = 1
  let column = 1
  for (let i = 0; i < span.offset && i < originalInput.length; i++) {
    if (originalInput[i] === '\n') {
      line++
      column = 1
    } else {
      column++
    }
  }
  console.log(`Manual calculation: line ${line}, column ${column}`)
  console.log(`Manual matches reported: line=${line === span.line}, column=${column === span.column}`)
  
  console.log("\n--- ErrorFormatter Output ---")
  const formatter = new ErrorFormatter("ansi")
  const formatted = formatter.format(bundle)
  console.log(formatted)
  
  console.log("\n--- Character-by-character position map ---")
  console.log("Index: 0123456789012345")
  console.log("       1         2")
  console.log(`Input: ${originalInput}`)
  console.log(`Error: ${" ".repeat(span.offset)}^`)
  console.log(`Should:${" ".repeat(originalInput.length)}^`)
  
} else {
  console.log("âŒ Unexpected success - parser should have failed!")
}
</file>

<file path="src/hints.ts">
import { Either } from "./either"
import { Parser } from "./parser"
import { type ParseErr, createSpan } from "./rich-errors"
import { State } from "./state"

/**
 * Calculate the Levenshtein distance between two strings.
 * This measures the minimum number of single-character edits (insertions, deletions, or substitutions)
 * required to change one string into another.
 * 
 * @param a - The first string
 * @param b - The second string
 * @returns The edit distance between the strings
 */
export function levenshteinDistance(a: string, b: string): number {
	const matrix = Array(b.length + 1)
		.fill(null)
		.map(() => Array(a.length + 1).fill(null))

	// Initialize first row and column
	for (let i = 0; i <= a.length; i++) matrix[0][i] = i
	for (let j = 0; j <= b.length; j++) matrix[j][0] = j

	// Fill the matrix
	for (let j = 1; j <= b.length; j++) {
		for (let i = 1; i <= a.length; i++) {
			const indicator = a[i - 1] === b[j - 1] ? 0 : 1
			matrix[j][i] = Math.min(
				matrix[j][i - 1] + 1, // deletion
				matrix[j - 1][i] + 1, // insertion
				matrix[j - 1][i - 1] + indicator, // substitution
			)
		}
	}

	return matrix[b.length][a.length]
}

/**
 * Generate helpful hints for a user's input based on a list of expected values.
 * Uses edit distance to find the closest matches and suggests them as "Did you mean..." options.
 * 
 * @param found - The string the user actually typed
 * @param expected - Array of valid/expected strings
 * @param maxDistance - Maximum edit distance to consider (default: 2)
 * @param maxHints - Maximum number of hints to return (default: 3)
 * @returns Array of suggested strings, sorted by edit distance
 */
export function generateHints(
	found: string,
	expected: string[],
	maxDistance: number = 2,
	maxHints: number = 3,
): string[] {
	const hints: Array<{ word: string; distance: number }> = []

	for (const candidate of expected) {
		const distance = levenshteinDistance(found, candidate)
		if (distance <= maxDistance && distance > 0) {
			hints.push({ word: candidate, distance })
		}
	}

	return hints
		.sort((a, b) => a.distance - b.distance)
		.slice(0, maxHints)
		.map((h) => h.word)
}

/**
 * Enhanced keyword parser that provides intelligent hints when the user types something similar.
 * 
 * @param keywords - Array of valid keywords to match against
 * @returns A function that creates a parser for a specific keyword with hint generation
 * 
 * @example
 * ```ts
 * const schemeKeywords = ["lambda", "let", "if", "cond", "define", "quote"]
 * const lambdaParser = keywordWithHints(schemeKeywords)("lambda")
 * 
 * // Parsing "lamdba" will suggest "lambda" as a hint
 * const result = lambdaParser.parse("lamdba")
 * ```
 */
export const keywordWithHints = (keywords: string[]) => (keyword: string) =>
	new Parser((state) => {
		if (state.remaining.startsWith(keyword)) {
			return Parser.succeed(keyword, State.consume(state, keyword.length))
		}

		// Try to extract what the user actually typed
		const match = state.remaining.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)
		const found = match ? match[0] : state.remaining[0] || "end of input"

		const hints = generateHints(found, keywords)

		const error: ParseErr = {
			tag: "Unexpected",
			span: createSpan(state, found.length),
			found,
			context: state.context.labelStack || [],
			...(hints.length > 0 && { hints }),
		}

		return Parser.failRich({ errors: [error] }, state)
	})

/**
 * Creates a parser that matches any of the provided keywords with hint generation.
 * 
 * @param keywords - Array of valid keywords
 * @returns A parser that matches any keyword and provides hints for typos
 * 
 * @example
 * ```ts
 * const jsKeywords = ["function", "const", "let", "var", "class", "if", "else"]
 * const keywordParser = anyKeywordWithHints(jsKeywords)
 * 
 * // Parsing "functoin" will suggest "function"
 * const result = keywordParser.parse("functoin")
 * ```
 */
export function anyKeywordWithHints<Ctx = {}>(
	keywords: string[],
): Parser<string, Ctx> {
	return new Parser((state) => {
		// Try each keyword
		for (const keyword of keywords) {
			if (state.remaining.startsWith(keyword)) {
				return Parser.succeed(keyword, State.consume(state, keyword.length))
			}
		}

		// No exact match found, try to extract what was typed and generate hints
		const match = state.remaining.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)
		const found = match ? match[0] : state.remaining[0] || "end of input"

		const hints = generateHints(found, keywords)

		const error: ParseErr = {
			tag: "Unexpected",
			span: createSpan(state, found.length),
			found,
			context: state.context.labelStack || [],
			...(hints.length > 0 && { hints }),
		}

		return Parser.failRich({ errors: [error] }, state)
	})
}

/**
 * Creates a parser for string literals with hint generation for common mistakes.
 * 
 * @param validStrings - Array of valid string values
 * @returns A parser that matches quoted strings and provides hints for typos
 * 
 * @example
 * ```ts
 * const colorParser = stringWithHints(["red", "green", "blue", "yellow"])
 * 
 * // Parsing '"gren"' will suggest "green"
 * const result = colorParser.parse('"gren"')
 * ```
 */
export function stringWithHints<Ctx = {}>(
	validStrings: string[],
): Parser<string, Ctx> {
	return new Parser((state) => {
		// Must start with quote
		if (!state.remaining.startsWith('"')) {
			const error: ParseErr = {
				tag: "Expected",
				span: createSpan(state, 1),
				items: ["string literal"],
				context: state.context.labelStack || [],
			}
			return Parser.failRich({ errors: [error] }, state)
		}

		// Find the closing quote
		let i = 1
		let content = ""
		while (i < state.remaining.length && state.remaining[i] !== '"') {
			content += state.remaining[i]
			i++
		}

		if (i >= state.remaining.length) {
			const error: ParseErr = {
				tag: "Expected",
				span: createSpan(state, i),
				items: ["closing quote"],
				context: state.context.labelStack || [],
			}
			return Parser.failRich({ errors: [error] }, state)
		}

		// Check if content is valid
		if (validStrings.includes(content)) {
			return Parser.succeed(content, State.consume(state, i + 1))
		}

		// Generate hints for invalid content
		const hints = generateHints(content, validStrings)

		const error: ParseErr = {
			tag: "Unexpected",
			span: createSpan(state, i + 1),
			found: `"${content}"`,
			context: state.context.labelStack || [],
			...(hints.length > 0 && { hints: hints.map((h) => `"${h}"`) }),
		}

		return Parser.failRich({ errors: [error] }, state)
	})
}
</file>

<file path="tests/either.test.ts">
import { describe, expect, test } from "bun:test"
import { Either } from "../src/either"

const ea = (): Either<number, string> =>
  Either.gen(function* () {
    const a = yield* Either.right(5)
    const b = yield* Either.right(3)
    return a + b
  })

const eb = (): Either<number, string> =>
  Either.gen(function* () {
    const a = yield* ea()
    const aa = yield* ea()
    yield* Either.left("hi")
    return a + aa
  })

describe("either", () => {
  test("either right", () => {
    const result = ea()
    expect(Either.isRight(result)).toBe(true)
  })

  test("either left", () => {
    const result = eb()
    expect(Either.isLeft(result)).toBe(true)
  })
})
</file>

<file path="tests/error-formatter.test.ts">
import { describe, expect, test } from "bun:test"
import { ErrorFormatter, formatError, type ErrorFormatterOptions } from "../src/error-formatter"
import { type ParseErr, ParseErrorBundle, type Span } from "../src/rich-errors"

describe("error formatter", () => {
	// Sample error data for testing
	const span: Span = { offset: 8, length: 6, line: 2, column: 9 }
	const multiLineSource = `function test() {
  return functoin;
}
console.log("done");`

	const expectedError: ParseErr = {
		tag: "Expected",
		span,
		items: ["identifier", "number"],
		context: ["expression", "statement"],
	}

	const unexpectedError: ParseErr = {
		tag: "Unexpected",
		span,
		found: "functoin",
		context: ["function", "statement"],
	}

	const customErrorWithHints: ParseErr = {
		tag: "Custom",
		span,
		message: "Invalid keyword",
		hints: ["function", "return"],
		context: ["declaration"],
	}

	describe("ErrorFormatter class", () => {
		test("creates formatter with default options", () => {
			const formatter = new ErrorFormatter()
			expect(formatter).toBeInstanceOf(ErrorFormatter)
		})

		test("creates formatter with custom format", () => {
			const formatter = new ErrorFormatter("ansi")
			expect(formatter).toBeInstanceOf(ErrorFormatter)
		})

		test("creates formatter with custom options", () => {
			const options: ErrorFormatterOptions = {
				maxContextLines: 5,
				showHints: false,
				showContext: false,
			}
			const formatter = new ErrorFormatter("plain", options)
			expect(formatter).toBeInstanceOf(ErrorFormatter)
		})

		test("withOptions creates new formatter", () => {
			const original = new ErrorFormatter("plain")
			const modified = original.withOptions({ showHints: false })
			expect(modified).not.toBe(original)
		})

		test("withFormat creates new formatter", () => {
			const original = new ErrorFormatter("plain")
			const modified = original.withFormat("ansi")
			expect(modified).not.toBe(original)
		})
	})

	describe("plain text formatting", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)
		const formatter = new ErrorFormatter("plain")

		test("formats basic error message", () => {
			const result = formatter.format(bundle)

			expect(result).toContain("Error at line 2, column 9")
			expect(result).toContain("Expected: identifier or number")
			expect(result).toContain("functoin")
		})

		test("includes pointer arrow", () => {
			const result = formatter.format(bundle)
			expect(result).toContain("^")
		})

		test("includes context stack", () => {
			const result = formatter.format(bundle)
			expect(result).toContain("Context: expression > statement")
		})

		test("formats unexpected error", () => {
			const unexpectedBundle = new ParseErrorBundle([unexpectedError], multiLineSource)
			const result = formatter.format(unexpectedBundle)

			expect(result).toContain("Unexpected: functoin")
		})

		test("formats custom error with hints", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const result = formatter.format(customBundle)

			expect(result).toContain("Invalid keyword")
			expect(result).toContain("Did you mean: function?")
			expect(result).toContain("Did you mean: return?")
		})

		test("disables hints when showHints is false", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const noHintsFormatter = new ErrorFormatter("plain", { showHints: false })
			const result = noHintsFormatter.format(customBundle)

			expect(result).not.toContain("Did you mean")
		})

		test("disables context when showContext is false", () => {
			const noContextFormatter = new ErrorFormatter("plain", { showContext: false })
			const result = noContextFormatter.format(bundle)

			expect(result).not.toContain("Context:")
		})
	})

	describe("ANSI formatting", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)
		const formatter = new ErrorFormatter("ansi")

		test("includes ANSI color codes", () => {
			const result = formatter.format(bundle)

			expect(result).toContain("\x1b[31m") // Red
			expect(result).toContain("\x1b[0m")  // Reset
		})

		test("formats hints with cyan color", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const result = formatter.format(customBundle)

			expect(result).toContain("\x1b[36m") // Cyan for hints
		})

		test("formats context with gray color", () => {
			const result = formatter.format(bundle)

			expect(result).toContain("\x1b[90m") // Gray for context
		})

		test("includes colored pointer", () => {
			const result = formatter.format(bundle)
			// Should have red caret(s) - might be multiple based on span length
			expect(result).toContain("\x1b[31m")
			expect(result).toContain("\x1b[0m")
			expect(result).toContain("^")
		})
	})

	describe("HTML formatting", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)
		const formatter = new ErrorFormatter("html")

		test("wraps in HTML structure", () => {
			const result = formatter.format(bundle)

			expect(result).toContain('<div class="parse-error">')
			expect(result).toContain('</div>')
		})

		test("includes proper CSS classes", () => {
			const result = formatter.format(bundle)

			expect(result).toContain('class="error-header"')
			expect(result).toContain('class="error-context"')
			expect(result).toContain('class="error-message"')
		})

		test("escapes HTML entities", () => {
			const htmlSource = 'if (x < 5 && y > "test") {'
			const htmlError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 4, length: 1, line: 1, column: 5 },
				found: "<script>",
				context: [],
			}
			const htmlBundle = new ParseErrorBundle([htmlError], htmlSource)
			const result = formatter.format(htmlBundle)

			expect(result).toContain("&lt;")
			expect(result).toContain("&gt;")
			expect(result).not.toContain("<script>")
		})

		test("formats hints with proper HTML", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const result = formatter.format(customBundle)

			expect(result).toContain('class="error-hints"')
			expect(result).toContain('class="suggestion"')
		})

		test("formats context stack with proper HTML", () => {
			const result = formatter.format(bundle)

			expect(result).toContain('class="context-item"')
			expect(result).toContain("&gt;") // HTML encoded >
		})
	})

	describe("JSON formatting", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)
		const formatter = new ErrorFormatter("json")

		test("produces valid JSON", () => {
			const result = formatter.format(bundle)
			expect(() => JSON.parse(result)).not.toThrow()
		})

		test("includes error location", () => {
			const result = formatter.format(bundle)
			const parsed = JSON.parse(result)

			expect(parsed.error.location.line).toBe(2)
			expect(parsed.error.location.column).toBe(9)
			expect(parsed.error.location.offset).toBe(8)
		})

		test("includes context information", () => {
			const result = formatter.format(bundle)
			const parsed = JSON.parse(result)

			expect(parsed.error.context.stack).toEqual(["expression", "statement"])
			expect(parsed.error.context.lines).toBeInstanceOf(Array)
		})

		test("includes all errors", () => {
			const multiErrorBundle = new ParseErrorBundle(
				[expectedError, unexpectedError, customErrorWithHints],
				multiLineSource,
			)
			const result = formatter.format(multiErrorBundle)
			const parsed = JSON.parse(result)

			expect(parsed.allErrors).toHaveLength(3)
			expect(parsed.allErrors[0].type).toBe("Expected")
			expect(parsed.allErrors[1].type).toBe("Unexpected")
			expect(parsed.allErrors[2].type).toBe("Custom")
		})

		test("includes hints for custom errors", () => {
			const customBundle = new ParseErrorBundle([customErrorWithHints], multiLineSource)
			const result = formatter.format(customBundle)
			const parsed = JSON.parse(result)

			expect(parsed.error.hints).toEqual(["function", "return"])
		})

		test("respects tabSize option", () => {
			const customFormatter = new ErrorFormatter("json", { tabSize: 4 })
			const result = customFormatter.format(bundle)

			// Should be formatted with 4 spaces
			expect(result).toContain("    \"error\":")
		})
	})

	describe("context lines handling", () => {
		const longSource = `line 1
line 2
line 3
ERROR LINE HERE
line 5
line 6
line 7`

		const errorInMiddle: ParseErr = {
			tag: "Unexpected",
			span: { offset: 21, length: 5, line: 4, column: 1 },
			found: "ERROR",
			context: [],
		}

		const bundle = new ParseErrorBundle([errorInMiddle], longSource)

		test("shows context lines around error", () => {
			const formatter = new ErrorFormatter("plain", { maxContextLines: 3 })
			const result = formatter.format(bundle)

			expect(result).toContain("line 3")
			expect(result).toContain("ERROR LINE HERE")
			expect(result).toContain("line 5")
		})

		test("limits context lines", () => {
			const formatter = new ErrorFormatter("plain", { maxContextLines: 1 })
			const result = formatter.format(bundle)

			expect(result).toContain("ERROR LINE HERE")
			expect(result).not.toContain("line 2")
			expect(result).not.toContain("line 6")
		})

		test("handles errors at beginning of file", () => {
			const earlyError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 0, length: 4, line: 1, column: 1 },
				found: "line",
				context: [],
			}
			const earlyBundle = new ParseErrorBundle([earlyError], longSource)
			const result = new ErrorFormatter("plain").format(earlyBundle)

			expect(result).toContain("line 1")
		})

		test("handles errors at end of file", () => {
			const lateError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 50, length: 4, line: 7, column: 1 },
				found: "line",
				context: [],
			}
			const lateBundle = new ParseErrorBundle([lateError], longSource)
			const result = new ErrorFormatter("plain").format(lateBundle)

			expect(result).toContain("line 7")
		})
	})

	describe("convenience functions", () => {
		const bundle = new ParseErrorBundle([expectedError], multiLineSource)

		test("formatError.plain", () => {
			const result = formatError.plain(bundle)
			expect(result).toContain("Error at line 2")
			expect(result).not.toContain("\x1b[") // No ANSI codes
		})

		test("formatError.ansi", () => {
			const result = formatError.ansi(bundle)
			expect(result).toContain("\x1b[31m") // ANSI colors
		})

		test("formatError.html", () => {
			const result = formatError.html(bundle)
			expect(result).toContain('<div class="parse-error">')
		})

		test("formatError.json", () => {
			const result = formatError.json(bundle)
			expect(() => JSON.parse(result)).not.toThrow()
		})

		test("convenience functions accept options", () => {
			const result = formatError.plain(bundle, { showHints: false })
			expect(result).not.toContain("Did you mean")
		})
	})

	describe("edge cases", () => {
		test("handles empty source", () => {
			const emptyError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 0, length: 0, line: 1, column: 1 },
				found: "end of input",
				context: [],
			}
			const emptyBundle = new ParseErrorBundle([emptyError], "")
			const result = new ErrorFormatter("plain").format(emptyBundle)

			expect(result).toContain("Error at line 1")
		})

		test("handles single line source", () => {
			const singleLineError: ParseErr = {
				tag: "Expected",
				span: { offset: 5, length: 1, line: 1, column: 6 },
				items: ["semicolon"],
				context: [],
			}
			const singleLineBundle = new ParseErrorBundle([singleLineError], "const x = 5")
			const result = new ErrorFormatter("plain").format(singleLineBundle)

			expect(result).toContain("const x = 5")
		})

		test("handles very long lines", () => {
			const longLine = "x".repeat(200)
			const longLineError: ParseErr = {
				tag: "Unexpected",
				span: { offset: 100, length: 1, line: 1, column: 101 },
				found: "x",
				context: [],
			}
			const longLineBundle = new ParseErrorBundle([longLineError], longLine)
			const result = new ErrorFormatter("plain").format(longLineBundle)

			expect(result).toContain("x".repeat(100))
		})

		test("handles zero-length spans", () => {
			const zeroLengthError: ParseErr = {
				tag: "Expected",
				span: { offset: 5, length: 0, line: 1, column: 6 },
				items: ["semicolon"],
				context: [],
			}
			const bundle = new ParseErrorBundle([zeroLengthError], "const x = 5")
			const result = new ErrorFormatter("plain").format(bundle)

			expect(result).toContain("^") // Should still show pointer
		})
	})
})
</file>

<file path="tests/regex-parsers.test.ts">
/**
 * Comprehensive test suite for regex parsers in the parserator library.
 *
 * This file contains extensive tests covering:
 * - Basic regex matching functionality
 * - Regex flags handling (case-insensitive, global, multiline, etc.)
 * - Character classes and special patterns
 * - Quantifiers (*, +, ?, {n}, {n,m})
 * - Groups and alternation
 * - Anchors and boundaries
 * - Integration with other combinators
 * - Complex real-world patterns (emails, URLs, etc.)
 * - Error handling and edge cases
 * - Performance and memory considerations
 * - Context preservation
 * - Pattern escaping
 *
 * These tests ensure that the regex parser properly advances state,
 * integrates correctly with combinators, and handles all edge cases
 * after the runtime fixes were applied.
 */

import { describe, expect, it } from "bun:test"
import {
  char,
  lookAhead,
  many0,
  many1,
  notFollowedBy,
  optional,
  or,
  regex,
  sepBy,
  sequence
} from "../src/combinators"
import { Either } from "../src/either"
import { State } from "../src/state"

describe("regex parsers", () => {
  describe("basic regex matching", () => {
    it("should match simple literal patterns", () => {
      const parser = regex(/hello/)
      expect(parser.parseOrThrow("hello")).toBe("hello")
      expect(parser.parseOrThrow("hello world")).toBe("hello")
    })

    it("should match at start of input only", () => {
      const parser = regex(/foo/)
      expect(Either.isLeft(parser.parse("bar foo").result)).toBe(true)
    })

    it("should handle empty matches correctly", () => {
      const parser = regex(/a*/) // Can match empty string
      expect(parser.parseOrThrow("")).toBe("")
      expect(parser.parseOrThrow("aaa")).toBe("aaa")
      expect(parser.parseOrThrow("bbb")).toBe("")
    })

    it("should properly advance state after matching", () => {
      const parser = regex(/abc/)
      const state = State.fromInput("abcdef", { source: "abcdef" })
      const result = parser.run(state)

      expect(Either.isRight(result.result)).toBe(true)
      expect(result.state.pos.offset).toBe(3)
      expect(result.state.remaining).toBe("def")
    })

    it("should handle zero-length matches", () => {
      const parser = regex(/(?=a)/) // Positive lookahead
      const state = State.fromInput("abc", { source: "abc" })
      const result = parser.run(state)

      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("")
      }
      expect(result.state.pos.offset).toBe(0) // Should not advance for zero-length match
    })
  })

  describe("regex flags handling", () => {
    it("should handle case-insensitive flag", () => {
      const parser = regex(/hello/i)
      expect(parser.parseOrThrow("HELLO")).toBe("HELLO")
      expect(parser.parseOrThrow("Hello")).toBe("Hello")
      expect(parser.parseOrThrow("hello")).toBe("hello")
    })

    it("should strip global flag to prevent side effects", () => {
      const globalRegex = /\d+/g
      const parser = regex(globalRegex)

      // First parse
      expect(parser.parseOrThrow("123abc")).toBe("123")
      // Second parse should work the same way (global flag removed)
      expect(parser.parseOrThrow("456def")).toBe("456")
    })

    it("should handle multiline flag", () => {
      const parser = regex(/^hello/m)
      expect(parser.parseOrThrow("hello\nworld")).toBe("hello")
    })

    it("should handle dot-all flag", () => {
      const parser = regex(/a.b/s)
      expect(parser.parseOrThrow("a\nb")).toBe("a\nb")
    })
  })

  describe("character classes and special patterns", () => {
    it("should match digit patterns", () => {
      const parser = regex(/\d+/)
      expect(parser.parseOrThrow("123")).toBe("123")
      expect(parser.parseOrThrow("456abc")).toBe("456")
    })

    it("should match word patterns", () => {
      const parser = regex(/\w+/)
      expect(parser.parseOrThrow("hello123")).toBe("hello123")
      expect(parser.parseOrThrow("test_var")).toBe("test_var")
    })

    it("should match whitespace patterns", () => {
      const parser = regex(/\s+/)
      expect(parser.parseOrThrow("   hello")).toBe("   ")
      expect(parser.parseOrThrow("\t\n hello")).toBe("\t\n ")
    })

    it("should match custom character classes", () => {
      const parser = regex(/[a-z]+/)
      expect(parser.parseOrThrow("hello")).toBe("hello")
      expect(Either.isLeft(parser.parse("123").result)).toBe(true)
    })

    it("should match negated character classes", () => {
      const parser = regex(/[^0-9]+/)
      expect(parser.parseOrThrow("abc")).toBe("abc")
      expect(Either.isLeft(parser.parse("123").result)).toBe(true)
    })
  })

  describe("quantifiers", () => {
    it("should handle asterisk quantifier", () => {
      const parser = regex(/a*/)
      expect(parser.parseOrThrow("")).toBe("")
      expect(parser.parseOrThrow("aaa")).toBe("aaa")
      expect(parser.parseOrThrow("bbb")).toBe("")
    })

    it("should handle plus quantifier", () => {
      const parser = regex(/a+/)
      expect(parser.parseOrThrow("aaa")).toBe("aaa")
      expect(Either.isLeft(parser.parse("bbb").result)).toBe(true)
      expect(Either.isLeft(parser.parse("").result)).toBe(true)
    })

    it("should handle question mark quantifier", () => {
      const parser = regex(/colou?r/)
      expect(parser.parseOrThrow("color")).toBe("color")
      expect(parser.parseOrThrow("colour")).toBe("colour")
    })

    it("should handle specific count quantifiers", () => {
      const parser = regex(/\d{3}/)
      expect(parser.parseOrThrow("123")).toBe("123")
      expect(parser.parseOrThrow("1234")).toBe("123")
      expect(Either.isLeft(parser.parse("12").result)).toBe(true)
    })

    it("should handle range quantifiers", () => {
      const parser = regex(/\d{2,4}/)
      expect(parser.parseOrThrow("12")).toBe("12")
      expect(parser.parseOrThrow("123")).toBe("123")
      expect(parser.parseOrThrow("1234")).toBe("1234")
      expect(parser.parseOrThrow("12345")).toBe("1234")
      expect(Either.isLeft(parser.parse("1").result)).toBe(true)
    })
  })

  describe("groups and alternation", () => {
    it("should handle capturing groups", () => {
      const parser = regex(/(hello|hi) world/)
      expect(parser.parseOrThrow("hello world")).toBe("hello world")
      expect(parser.parseOrThrow("hi world")).toBe("hi world")
    })

    it("should handle non-capturing groups", () => {
      const parser = regex(/(?:cat|dog)s/)
      expect(parser.parseOrThrow("cats")).toBe("cats")
      expect(parser.parseOrThrow("dogs")).toBe("dogs")
    })

    it("should handle alternation", () => {
      const parser = regex(/foo|bar|baz/)
      expect(parser.parseOrThrow("foo")).toBe("foo")
      expect(parser.parseOrThrow("bar")).toBe("bar")
      expect(parser.parseOrThrow("baz")).toBe("baz")
    })
  })

  describe("anchors and boundaries", () => {
    it("should handle start anchor (implicit at beginning)", () => {
      const parser = regex(/hello/)
      expect(parser.parseOrThrow("hello world")).toBe("hello")
      expect(Either.isLeft(parser.parse("say hello").result)).toBe(true)
    })

    it("should handle word boundaries", () => {
      const parser = regex(/\bcat\b/)
      expect(parser.parseOrThrow("cat")).toBe("cat")
      expect(parser.parseOrThrow("cat ")).toBe("cat")
      expect(Either.isLeft(parser.parse("catch").result)).toBe(true)
    })
  })

  describe("integration with combinators", () => {
    it("should work correctly with many0", () => {
      const parser = many0(regex(/\d/))
      expect(parser.parseOrThrow("123abc")).toEqual(["1", "2", "3"])
      expect(parser.parseOrThrow("abc")).toEqual([])
    })

    it("should work correctly with many1", () => {
      const parser = many1(regex(/\w/))
      expect(parser.parseOrThrow("hello123")).toEqual([
        "h",
        "e",
        "l",
        "l",
        "o",
        "1",
        "2",
        "3"
      ])
      expect(Either.isLeft(parser.parse("!!!").result)).toBe(true)
    })

    it("should work correctly with sepBy", () => {
      const parser = sepBy(regex(/,/), regex(/\d+/))
      expect(parser.parseOrThrow("1,2,3")).toEqual(["1", "2", "3"])
      expect(parser.parseOrThrow("42")).toEqual(["42"])
      expect(parser.parseOrThrow("")).toEqual([])
    })

    it("should work correctly with optional", () => {
      const parser = optional(regex(/hello/))
      expect(parser.parseOrThrow("hello world")).toBe("hello")
      expect(parser.parseOrThrow("world")).toBeUndefined()
    })

    it("should work correctly with sequence", () => {
      const parser = sequence([regex(/\d+/), regex(/\s+/), regex(/\w+/)])
      expect(parser.parseOrThrow("123 hello")).toBe("hello")
    })

    it("should work correctly with lookAhead", () => {
      const parser = sequence([lookAhead(regex(/\d/)), regex(/\d+/)])
      expect(parser.parseOrThrow("123")).toBe("123")
    })

    it("should work correctly with notFollowedBy", () => {
      const parser = sequence([
        regex(/hello/),
        notFollowedBy(regex(/\s+world/))
      ])
      expect(parser.parseOrThrow("hello there")).toBe(true)
      expect(Either.isLeft(parser.parse("hello world").result)).toBe(true)
    })

    it("should work correctly with or combinator", () => {
      const parser = or(regex(/\d+/), regex(/[a-z]+/), regex(/[A-Z]+/))
      expect(parser.parseOrThrow("123")).toBe("123")
      expect(parser.parseOrThrow("hello")).toBe("hello")
      expect(parser.parseOrThrow("WORLD")).toBe("WORLD")
    })
  })

  describe("complex real-world patterns", () => {
    it("should parse email addresses", () => {
      const parser = regex(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/)
      expect(parser.parseOrThrow("user@example.com")).toBe("user@example.com")
      expect(parser.parseOrThrow("test.email+tag@domain.co.uk")).toBe(
        "test.email+tag@domain.co.uk"
      )
    })

    it("should parse URLs", () => {
      const parser = regex(/https?:\/\/[^\s]+/)
      expect(parser.parseOrThrow("https://example.com")).toBe(
        "https://example.com"
      )
      expect(parser.parseOrThrow("http://test.org/path?query=value")).toBe(
        "http://test.org/path?query=value"
      )
    })

    it("should parse IP addresses", () => {
      const parser = regex(/\b(?:\d{1,3}\.){3}\d{1,3}\b/)
      expect(parser.parseOrThrow("192.168.1.1")).toBe("192.168.1.1")
      expect(parser.parseOrThrow("10.0.0.255")).toBe("10.0.0.255")
    })

    it("should parse hexadecimal colors", () => {
      const parser = regex(/#[0-9a-fA-F]{6}/)
      expect(parser.parseOrThrow("#FF0000")).toBe("#FF0000")
      expect(parser.parseOrThrow("#deadbeef")).toBe("#deadbe") // Only matches 6 digits
    })

    it("should parse ISO date format", () => {
      const parser = regex(/\d{4}-\d{2}-\d{2}/)
      expect(parser.parseOrThrow("2023-12-25")).toBe("2023-12-25")
      expect(parser.parseOrThrow("2023-12-25T10:30:00")).toBe("2023-12-25")
    })

    it("should parse JSON-like strings", () => {
      const parser = regex(/"(?:[^"\\]|\\.)*"/)
      expect(parser.parseOrThrow('"hello"')).toBe('"hello"')
      expect(parser.parseOrThrow('"hello \\"world\\""')).toBe(
        '"hello \\"world\\""'
      )
    })
  })

  describe("error handling and edge cases", () => {
    it("should provide clear error messages", () => {
      const parser = regex(/\d+/)
      const result = parser.parse("abc")
      expect(Either.isLeft(result.result)).toBe(true)
      if (Either.isLeft(result.result)) {
        console.log()
        // expect(result.result.left.primary.).toContain("Expected /\\d+/")
      }
    })

    it("should handle empty input gracefully", () => {
      const parser = regex(/hello/)
      expect(Either.isLeft(parser.parse("").result)).toBe(true)
    })

    it("should handle very long inputs", () => {
      const parser = regex(/a+/)
      const longInput = "a".repeat(10000) + "b"
      expect(parser.parseOrThrow(longInput)).toBe("a".repeat(10000))
    })

    it("should handle unicode characters", () => {
      const parser = regex(/[ðŸŒŸâ­]+/)
      expect(parser.parseOrThrow("ðŸŒŸâ­ðŸŒŸ")).toBe("ðŸŒŸâ­ðŸŒŸ")
    })

    it("should handle newlines and multiline input", () => {
      const parser = regex(/.*/)
      expect(parser.parseOrThrow("hello\nworld")).toBe("hello")

      const multilineParser = regex(/.*/s)
      expect(multilineParser.parseOrThrow("hello\nworld")).toBe("hello\nworld")
    })
  })

  describe("performance and memory", () => {
    it("should not cause infinite loops with star quantifiers", () => {
      const parser = many1(regex(/a*/))
      expect(() => parser.parse("aaa")).toThrow(
        "Parser did not advance - infinite loop prevented"
      )
    })

    it("should handle repeated parsing efficiently", () => {
      const parser = regex(/\d+/)
      const inputs = ["123", "456", "789", "000"]

      inputs.forEach(input => {
        expect(parser.parseOrThrow(input)).toBe(input)
      })
    })

    it("should work with complex nested structures", () => {
      const numberParser = regex(/\d+/)
      const commaParser = regex(/,/)
      const spaceParser = regex(/\s*/)

      const listParser = sequence([
        char("["),
        spaceParser,
        sepBy(sequence([spaceParser, commaParser, spaceParser]), numberParser),
        spaceParser,
        char("]")
      ])

      expect(listParser.parseOrThrow("[1, 2, 3]")).toBe("]")
    })
  })

  describe("regex with context", () => {
    it("should preserve context through regex parsing", () => {
      type MyContext = { debug: boolean; mode: string }
      const parser = regex<MyContext>(/hello/)

      const context = { debug: true, mode: "test", source: "hello world" }
      const state = State.fromInput("hello world", context)
      const result = parser.run(state)

      expect(Either.isRight(result.result)).toBe(true)
      expect(result.state.context.debug).toBe(true)
      expect(result.state.context.mode).toBe("test")
    })
  })

  describe("regex pattern escaping", () => {
    it("should handle escaped special characters", () => {
      const parser = regex(/\$\d+\.\d{2}/)
      expect(parser.parseOrThrow("$19.99")).toBe("$19.99")
    })

    it("should handle escaped quotes in patterns", () => {
      const parser = regex(/"[^"]*"/)
      expect(parser.parseOrThrow('"hello world"')).toBe('"hello world"')
    })

    it("should handle backslashes correctly", () => {
      const parser = regex(/\\[ntbr]/)
      expect(parser.parseOrThrow("\\n")).toBe("\\n")
      expect(parser.parseOrThrow("\\t")).toBe("\\t")
    })
  })
})
</file>

<file path="tests/rich-errors.test.ts">
import { describe, expect, test } from "bun:test"
import {
  type ParseErr,
  ParseErrorBundle,
  type Span,
  createSpan,
  legacyError
} from "../src/rich-errors"
import { ParserError } from "../src/state"

describe("rich-errors", () => {
  describe("createSpan", () => {
    test("creates span with basic position", () => {
      const state = {
        pos: { offset: 10, line: 2, column: 5 }
      }
      const span = createSpan(state)

      expect(span).toEqual({
        offset: 10,
        length: 0,
        line: 2,
        column: 5
      })
    })

    test("creates span with custom length", () => {
      const state = {
        pos: { offset: 15, line: 3, column: 8 }
      }
      const span = createSpan(state, 5)

      expect(span).toEqual({
        offset: 15,
        length: 5,
        line: 3,
        column: 8
      })
    })
  })

  describe("ParseErr types", () => {
    test("creates Expected error", () => {
      const span: Span = { offset: 0, length: 1, line: 1, column: 1 }
      const error: ParseErr = {
        tag: "Expected",
        span,
        items: ["identifier", "number"],
        context: ["expression", "term"]
      }

      expect(error.tag).toBe("Expected")
      expect(error.items).toEqual(["identifier", "number"])
      expect(error.context).toEqual(["expression", "term"])
    })

    test("creates Unexpected error", () => {
      const span: Span = { offset: 5, length: 1, line: 1, column: 6 }
      const error: ParseErr = {
        tag: "Unexpected",
        span,
        found: ";",
        context: ["statement"]
      }

      expect(error.tag).toBe("Unexpected")
      expect(error.found).toBe(";")
      expect(error.context).toEqual(["statement"])
    })

    test("creates Custom error without hints", () => {
      const span: Span = { offset: 10, length: 3, line: 2, column: 1 }
      const error: ParseErr = {
        tag: "Custom",
        span,
        message: "Invalid syntax",
        context: ["block"]
      }

      expect(error.tag).toBe("Custom")
      expect(error.message).toBe("Invalid syntax")
      expect(error.hints).toBeUndefined()
      expect(error.context).toEqual(["block"])
    })

    test("creates Custom error with hints", () => {
      const span: Span = { offset: 20, length: 6, line: 3, column: 5 }
      const error: ParseErr = {
        tag: "Custom",
        span,
        message: "Unknown keyword",
        hints: ["lambda", "let"],
        context: ["expression"]
      }

      expect(error.tag).toBe("Custom")
      expect(error.message).toBe("Unknown keyword")
      expect(error.hints).toEqual(["lambda", "let"])
      expect(error.context).toEqual(["expression"])
    })
  })

  describe("ParseErrorBundle", () => {
    const source = "hello world"

    test("single error bundle", () => {
      const error: ParseErr = {
        tag: "Expected",
        span: { offset: 5, length: 1, line: 1, column: 6 },
        items: ["space"],
        context: []
      }
      const bundle = new ParseErrorBundle([error], source)

      expect(bundle.errors).toHaveLength(1)
      expect(bundle.primary).toBe(error)
      expect(bundle.primaryErrors).toEqual([error])
    })

    test("multiple errors - primary is furthest", () => {
      const error1: ParseErr = {
        tag: "Expected",
        span: { offset: 2, length: 1, line: 1, column: 3 },
        items: ["letter"],
        context: []
      }
      const error2: ParseErr = {
        tag: "Unexpected",
        span: { offset: 8, length: 1, line: 1, column: 9 },
        found: "d",
        context: []
      }
      const error3: ParseErr = {
        tag: "Custom",
        span: { offset: 5, length: 1, line: 1, column: 6 },
        message: "Custom error",
        context: []
      }

      const bundle = new ParseErrorBundle([error1, error2, error3], source)

      expect(bundle.errors).toHaveLength(3)
      expect(bundle.primary).toBe(error2) // furthest offset (8)
      expect(bundle.primaryErrors).toEqual([error2])
    })

    test("multiple errors at same furthest offset", () => {
      const error1: ParseErr = {
        tag: "Expected",
        span: { offset: 5, length: 1, line: 1, column: 6 },
        items: ["space"],
        context: []
      }
      const error2: ParseErr = {
        tag: "Expected",
        span: { offset: 10, length: 1, line: 1, column: 11 },
        items: ["punctuation"],
        context: []
      }
      const error3: ParseErr = {
        tag: "Unexpected",
        span: { offset: 10, length: 1, line: 1, column: 11 },
        found: "d",
        context: []
      }

      const bundle = new ParseErrorBundle([error1, error2, error3], source)

      expect(bundle.primary).toBe(error2) // first one at furthest offset
      expect(bundle.primaryErrors).toEqual([error2, error3]) // both at offset 10
    })

    test("empty errors array throws", () => {
      expect(() => new ParseErrorBundle([], source).primary).toThrow()
    })
  })

  describe("legacyError adapter", () => {
    const source = "test input"

    test("converts Expected error", () => {
      const error: ParseErr = {
        tag: "Expected",
        span: { offset: 0, length: 1, line: 1, column: 1 },
        items: ["identifier", "number"],
        context: ["expression"]
      }
      const bundle = new ParseErrorBundle([error], source)
      const legacy = legacyError(bundle)

      expect(legacy).toBeInstanceOf(ParserError)
      expect(legacy.message).toBe(
        'Expected: {"tag":"Expected","span":{"offset":0,"length":1,"line":1,"column":1},"items":["identifier","number"],"context":["expression"]}'
      )
      expect(legacy.expected).toEqual(["identifier", "number"])
      expect(legacy.found).toBeUndefined()
    })

    test("converts Unexpected error", () => {
      const error: ParseErr = {
        tag: "Unexpected",
        span: { offset: 5, length: 1, line: 1, column: 6 },
        found: ";",
        context: []
      }
      const bundle = new ParseErrorBundle([error], source)
      const legacy = legacyError(bundle)

      expect(legacy).toBeInstanceOf(ParserError)
      expect(legacy.message).toBe(
        'Unexpected: {"tag":"Unexpected","span":{"offset":5,"length":1,"line":1,"column":6},"found":";","context":[]}'
      )
      expect(legacy.expected).toEqual([])
      expect(legacy.found).toBe(";")
    })

    test("converts Custom error", () => {
      const error: ParseErr = {
        tag: "Custom",
        span: { offset: 10, length: 3, line: 2, column: 1 },
        message: "Invalid syntax error",
        hints: ["lambda"],
        context: ["expression"]
      }
      const bundle = new ParseErrorBundle([error], source)
      const legacy = legacyError(bundle)

      expect(legacy).toBeInstanceOf(ParserError)
      expect(legacy.message).toBe("Invalid syntax error")
      expect(legacy.expected).toEqual([])
      expect(legacy.found).toBeUndefined()
    })
  })
})
</file>

<file path="tests/runtime-fixes.test.ts">
import { describe, expect, it } from "bun:test"
import { Parser } from "../src/parser"
import { regex, many0, many1, notFollowedBy, optional, sepBy, sequence } from "../src/combinators"
import { State } from "../src/state"
import { Either } from "../src/either"

describe("runtime fixes", () => {
  describe("regex state advancement (issue #1)", () => {
    it("should advance state after successful match", () => {
      const parser = regex(/abc/)
      const state = State.fromInput("abcdef", { source: "abcdef" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("abc")
      }
      expect(result.state.pos.offset).toBe(3)
      expect(result.state.remaining).toBe("def")
    })

    it("should prevent infinite loops in many0 with regex", () => {
      const parser = many0(regex(/a/)) // Match single 'a' characters
      const state = State.fromInput("aaa", { source: "aaa" })
      
      const result = parser.run(state)
      
      // Should match each 'a' individually
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toEqual(["a", "a", "a"])
      }
      expect(result.state.remaining).toBe("")
    })

    it("should work correctly with many1 and regex", () => {
      const parser = many1(regex(/\d/))
      const state = State.fromInput("123abc", { source: "123abc" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toEqual(["1", "2", "3"])
      }
      expect(result.state.remaining).toBe("abc")
    })
  })

  describe("notFollowedBy state preservation (issue #2)", () => {
    it("should not advance state on success (when inner parser fails)", () => {
      const parser = notFollowedBy(regex(/xyz/))
      const state = State.fromInput("abc", { source: "abc" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe(true)
      }
      expect(result.state.pos.offset).toBe(0) // Should not advance
      expect(result.state.remaining).toBe("abc")
    })

    it("should not advance state even if inner parser would consume input", () => {
      const innerParser = regex(/ab/)
      const parser = notFollowedBy(innerParser)
      const state = State.fromInput("xyz", { source: "xyz" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe(true)
      }
      expect(result.state.pos.offset).toBe(0) // Should not advance
      expect(result.state.remaining).toBe("xyz")
    })

    it("should fail when inner parser matches", () => {
      const parser = notFollowedBy(regex(/abc/))
      const state = State.fromInput("abc", { source: "abc" })
      
      const result = parser.run(state)
      
      expect(Either.isLeft(result.result)).toBe(true)
    })
  })

  describe("optional state preservation (issue #3)", () => {
    it("should not advance state when inner parser fails", () => {
      const parser = optional(regex(/xyz/))
      const state = State.fromInput("abc", { source: "abc" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBeUndefined()
      }
      expect(result.state.pos.offset).toBe(0) // Should not advance
      expect(result.state.remaining).toBe("abc")
    })

    it("should advance state when inner parser succeeds", () => {
      const parser = optional(regex(/abc/))
      const state = State.fromInput("abc", { source: "abc" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("abc")
      }
      expect(result.state.pos.offset).toBe(3) // Should advance
      expect(result.state.remaining).toBe("")
    })
  })

  describe("infinite loop prevention (issue #4)", () => {
    it("should prevent infinite loop in many0 with non-advancing parser", () => {
      // Create a parser that succeeds but doesn't advance
      const nonAdvancingParser = new Parser(state => {
        return Parser.succeed("x", state) // Returns same state
      })
      
      const parser = many0(nonAdvancingParser)
      const state = State.fromInput("test", { source: "test" })
      
      expect(() => parser.run(state)).toThrow("Parser did not advance - infinite loop prevented")
    })

    it("should prevent infinite loop in many1 with non-advancing parser", () => {
      const nonAdvancingParser = new Parser(state => {
        return Parser.succeed("x", state)
      })
      
      const parser = many1(nonAdvancingParser)
      const state = State.fromInput("test", { source: "test" })
      
      expect(() => parser.run(state)).toThrow("Parser did not advance - infinite loop prevented")
    })

    it("should prevent infinite loop with non-advancing separator", () => {
      const advancingParser = regex(/\d/)
      const nonAdvancingSeparator = new Parser(state => {
        return Parser.succeed(",", state) // Separator doesn't advance
      })
      
      const parser = many1(advancingParser, nonAdvancingSeparator)
      const state = State.fromInput("1,2,3", { source: "1,2,3" })
      
      expect(() => parser.run(state)).toThrow("Separator parser did not advance - infinite loop prevented")
    })

    it("should work correctly with properly advancing parsers", () => {
      const parser = many0(regex(/\d/))
      const state = State.fromInput("123abc", { source: "123abc" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toEqual(["1", "2", "3"])
      }
      expect(result.state.remaining).toBe("abc")
    })
  })

  describe("sepBy empty list handling (issue #5)", () => {
    it("should return empty array when first element fails", () => {
      const parser = sepBy(regex(/,/), regex(/\d/))
      const state = State.fromInput("abc", { source: "abc" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toEqual([])
      }
      expect(result.state.pos.offset).toBe(0) // Should not advance
      expect(result.state.remaining).toBe("abc")
    })

    it("should parse single element without separator", () => {
      const parser = sepBy(regex(/,/), regex(/\d/))
      const state = State.fromInput("1abc", { source: "1abc" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toEqual(["1"])
      }
      expect(result.state.remaining).toBe("abc")
    })

    it("should parse multiple elements with separators", () => {
      const parser = sepBy(regex(/,/), regex(/\d/))
      const state = State.fromInput("1,2,3abc", { source: "1,2,3abc" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toEqual(["1", "2", "3"])
      }
      expect(result.state.remaining).toBe("abc")
    })

    it("should stop at first separator failure", () => {
      const parser = sepBy(regex(/,/), regex(/\d/))
      const state = State.fromInput("1;2,3", { source: "1;2,3" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toEqual(["1"]) // Stops at ';'
      }
      expect(result.state.remaining).toBe(";2,3")
    })
  })

  describe("sequence implementation cleanup (issue #6)", () => {
    it("should return last parser result", () => {
      const parser1 = regex(/a/)
      const parser2 = regex(/b/)
      const parser3 = regex(/c/)
      
      const parser = sequence([parser1, parser2, parser3])
      const state = State.fromInput("abc", { source: "abc" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("c") // Should be last result
      }
      expect(result.state.remaining).toBe("")
    })

    it("should fail on first parser failure", () => {
      const parser1 = regex(/x/) // Will fail
      const parser2 = regex(/b/)
      
      const parser = sequence([parser1, parser2])
      const state = State.fromInput("abc", { source: "abc" })
      
      const result = parser.run(state)
      
      expect(Either.isLeft(result.result)).toBe(true)
    })

    it("should fail on middle parser failure", () => {
      const parser1 = regex(/a/)
      const parser2 = regex(/x/) // Will fail
      const parser3 = regex(/c/)
      
      const parser = sequence([parser1, parser2, parser3])
      const state = State.fromInput("abc", { source: "abc" })
      
      const result = parser.run(state)
      
      expect(Either.isLeft(result.result)).toBe(true)
    })

    it("should properly advance state through all parsers", () => {
      const parser1 = regex(/ab/)
      const parser2 = regex(/cd/)
      
      const parser = sequence([parser1, parser2])
      const state = State.fromInput("abcdef", { source: "abcdef" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("cd")
      }
      expect(result.state.pos.offset).toBe(4)
      expect(result.state.remaining).toBe("ef")
    })
  })

  describe("comprehensive integration tests", () => {
    it("should handle complex nested parsing without infinite loops", () => {
      // Test that combines multiple fixed combinators
      const digit = regex(/\d/)
      const comma = regex(/,/)
      const numberList = sepBy(comma, digit)
      const optionalList = optional(numberList)
      
      const parser = optionalList // Just use the optional list directly
      const state = State.fromInput("1,2,3", { source: "1,2,3" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toEqual(["1", "2", "3"])
      }
      expect(result.state.remaining).toBe("")
    })

    it("should handle empty input gracefully", () => {
      const parser = sepBy(regex(/,/), regex(/\d/))
      const state = State.fromInput("", { source: "" })
      
      const result = parser.run(state)
      
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toEqual([])
      }
      expect(result.state.remaining).toBe("")
    })

    it("should handle negative lookahead in complex scenarios", () => {
      const notNumber = notFollowedBy(regex(/\d/))
      const letter = regex(/[a-z]/)
      const letterNotNumber = sequence([notNumber, letter])
      
      const state1 = State.fromInput("a", { source: "a" })
      const result1 = letterNotNumber.run(state1)
      expect(Either.isRight(result1.result)).toBe(true)
      if (Either.isRight(result1.result)) {
        expect(result1.result.right).toBe("a")
      }
      
      const state2 = State.fromInput("1", { source: "1" })
      const result2 = letterNotNumber.run(state2)
      expect(Either.isLeft(result2.result)).toBe(true)
    })
  })
})
</file>

<file path=".gitignore">
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*
# updates.md
# AGENT.md

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="AGENT.md">
# Agent Guidelines for Parserator

## Commands

- **Build**: `bun run build` (runs tsup + build.ts)
- **Test**: `bun test` (all tests) or `bun test tests/combinators.test.ts` (single test file)
- **Typecheck**: `bun run typecheck` (tsc --noEmit)
- **Lint/Format**: `bunx @biomejs/biome check --write .` (Biome handles both)

## Code Style

- **Indentation**: Tabs (not spaces)
- **Quotes**: Double quotes for strings
- **Semicolons**: As needed (omit where possible)
- **Line width**: 80 characters max
- **Imports**: Auto-organized by Biome, re-exports via src/index.ts

## Naming Conventions

- **Types**: PascalCase (e.g., `ParserState`, `ParserOutput`)
- **Functions/Variables**: camelCase (e.g., `parseOrThrow`, `printErrorContext`)
- **Constants**: camelCase (e.g., `stringParser`, not UPPER_CASE)

## Architecture Patterns

- **Parser class**: Functional monadic design with chaining methods (.then, .map, .bind)
- **Error handling**: Custom ParserError with position tracking and context
- **State management**: Immutable ParserState with position tracking
- **Exports**: All public APIs re-exported through src/index.ts

## Advanced Error Handling Roadmap

Implement rich error system with: span-based errors, label/context tracking, automatic hint generation, error recovery combinators, multiple output formats (plain/ansi/html/json), and generator-friendly try/catch support. See full implementation guide for details on ParseErr types, ErrorFormatter, and migration strategy.
</file>

<file path="index.ts">
export * from "./src/chain"
export * from "./src/combinators"
export * from "./src/debug"
export * from "./src/either"
export * from "./src/errors"
export * from "./src/parser"
export * from "./src/state"
export * from "./src/types"
export * from "./src/utils"
</file>

<file path="todo.md">
# Todo: Runtime-Level Logical Problems to Fix

Below are the runtime-level (i.e. user-visible) logical problems found in the core combinators and helpers that need to be addressed one by one.

## Issues to Fix

### 1. `regex` never advances the state
- **Problem**: The match text is returned but `state` is returned unchanged, so the same parser can match the same slice forever (e.g. inside `many0`).
- **Location**: `src/combinators.ts`, `regex` implementation â€“ the "success" branch returns `Parser.succeed(value, state)`
- **Fix**: Pass `State.consume(state, value.length)` as the new state.
- **Status**: âœ… Fixed

### 2. `notFollowedBy` consumes input on failure
- **Problem**: The combinator says it "should not match", yet it returns `newState` (possibly advanced) both on success and failure. A negative look-ahead must never move the cursor.
- **Location**: `src/combinators.ts`, `notFollowedBy` â€“ last line returns `Parser.succeed(true, newState)`
- **Fix**: Always return the original `state` when you succeed.
- **Status**: âœ… Fixed

### 3. `optional` can also advance when the inner parser fails
- **Problem**: It mirrors the same pattern: on `Left` it still returns `newState`, leaking whatever the failing parser consumed.
- **Location**: `src/combinators.ts`, `optional` â€“ failure branch
- **Fix**: Return the untouched `state` in the failure branch.
- **Status**: âœ… Fixed

### 4. Potential infinite loop in `many_` / `skipMany_`
- **Problem**: Neither loop checks that the inner parser (or the separator) actually moved the cursor. If a parser succeeds without consumption (very easy after bug #1), the `while(true)` loop never breaks.
- **Location**: `many_` and `skipMany_` helper bodies
- **Fix**: After each successful parse, verify `newState.pos.offset > currentState.pos.offset`; if not, throw or fail.
- **Status**: âœ… Fixed

### 5. `sepBy` rejects empty lists
- **Problem**: Typical `sepBy` returns `[]` when the first element parser fails, but the current version immediately propagates that failure, so `[]` is un-parsable. A `// TODO: fix this` comment is already present.
- **Location**: `src/combinators.ts`, `sepBy` â€“ early failure on the first element
- **Fix**: If the first element fails, succeed with `[]` and the original state.
- **Status**: âœ… Fixed

### 6. `sequence` leaks a `@ts-expect-error` and stores results it never uses
- **Problem**: The generic accumulator is typed incorrectly (`results: Parsers[]`). It also keeps an unused array and contains a `// TODO: fix this` comment.
- **Location**: `sequence` implementation
- **Fix**: Change `results` to `unknown[]` or drop it entirely; remove the `@ts-expect-error`.
- **Status**: âœ… Fixed

## Secondary Observations
- Because of bug #1 the library's own unit tests that exercise `regex` inside `many1`, `takeUntil` etc. pass only thanks to implicit string slicing in those combinators; once `regex` starts consuming, double-check those tests.
- The same "state leak on failure" pattern appears anywhere a combinator re-runs a child parser and then discards the result (e.g. `lookAhead`). Only `lookAhead` deliberately keeps the original stateâ€”double-check all similar helpers.

## Completion Status
1. âœ… **COMPLETED**: Fix issues in order of severity (infinite loops first, then state consumption bugs)
2. âœ… **COMPLETED**: Run tests after each fix to ensure no regressions
3. âœ… **COMPLETED**: Add additional test cases to prevent future occurrences
4. âœ… **COMPLETED**: Review similar patterns throughout the codebase
5. âœ… **COMPLETED**: Ensure TypeScript compilation and build system works
6. âœ… **COMPLETED**: Create comprehensive documentation

## Summary
All 6 runtime-level logical problems have been successfully fixed and thoroughly tested:

### Fixes Applied:
1. âœ… **`regex` state advancement**: Changed `Parser.succeed(value, state)` to `Parser.succeed(value, State.consume(state, value.length))` in the success branch
2. âœ… **`notFollowedBy` state preservation**: Changed `Parser.succeed(true, newState)` to `Parser.succeed(true, state)` to never advance on success
3. âœ… **`optional` state preservation**: Changed failure branch to return `Parser.succeed(undefined, state)` instead of `newState`
4. âœ… **Infinite loop prevention**: Added state advancement checks in `many_` and `skipMany_` that throw errors if parsers don't advance
5. âœ… **`sepBy` empty list handling**: Changed to return `Parser.succeed([], state)` when first element fails instead of propagating failure
6. âœ… **`sequence` cleanup**: Removed unused `results` array, eliminated `@ts-expect-error`, and simplified to track only the last result

### Testing Results:
- âœ… All 141 existing tests continue to pass (no regressions)
- âœ… Added 23 new comprehensive test cases covering all fixes
- âœ… Total test suite: 164 tests passing
- âœ… Verified infinite loop prevention works correctly
- âœ… Confirmed state preservation in negative lookaheads
- âœ… Validated proper state advancement in all scenarios

### Code Review Findings:
- âœ… Reviewed all similar patterns in codebase
- âœ… Confirmed `lookAhead` is correctly implemented (properly preserves state)
- âœ… No other instances of state leakage patterns found
- âœ… All combinators now follow correct state management principles

### Recommendations:
1. **Monitor for similar patterns**: When adding new combinators, ensure negative lookaheads and optional parsers don't leak state
2. **Test with non-advancing parsers**: Always test combinators with parsers that might not consume input
3. **State advancement validation**: Consider adding runtime checks for infinite loops in other recursive combinators
4. **Documentation**: Update combinator documentation to clarify state preservation behavior

## âœ… PROJECT COMPLETED SUCCESSFULLY âœ…

The parser library is now robust against all identified runtime issues and has comprehensive test coverage to prevent regressions.

**Final Results:**
- ðŸŽ¯ **All 6 critical runtime issues fixed**
- ðŸ§ª **214 tests passing (100% success rate)**
- ðŸ”§ **TypeScript compilation successful**
- ðŸ“¦ **Build system working correctly**
- ðŸ“‹ **73 new comprehensive test cases added (23 runtime fixes + 50 regex parsers)**
- ðŸ“š **Complete documentation provided**

**Quality Assurance:**
- âœ… No regressions in existing functionality
- âœ… All edge cases covered with tests
- âœ… Infinite loop protection implemented and tested
- âœ… State management issues resolved
- âœ… Type safety maintained throughout
- âœ… Backward compatibility preserved

**Deliverables:**
- âœ… `RUNTIME_FIXES_SUMMARY.md` - Comprehensive documentation
- âœ… `tests/runtime-fixes.test.ts` - Complete runtime fix test coverage (23 tests)
- âœ… `tests/regex-parsers.test.ts` - Comprehensive regex parser test coverage (50 tests)
- âœ… Fixed `src/combinators.ts` - All runtime issues resolved

The parserator library is now production-ready with robust error handling, comprehensive test coverage, and extensive regex parser validation covering all patterns, flags, and integration scenarios.
</file>

<file path="tsup.config.ts">
import { defineConfig } from "tsup"

export default defineConfig({
  format: ["esm", "cjs"],
  entry: {
    index: "src/index.ts"
  },
  outDir: "dist",
  sourcemap: true,
  clean: true,
  dts: {
    resolve: true,
    entry: "src/index.ts"
  }
})
</file>

<file path="examples/scheme/ast.ts">
export namespace LispExpr {
  export type LispExpr =
    | Symbol
    | Number
    | String
    | Boolean
    | List
    | If
    | Lambda
    | Let

  export type Symbol = {
    readonly type: "Symbol"
    name: string
  }

  export type Number = {
    readonly type: "Number"
    value: number
  }

  export type String = {
    readonly type: "String"
    value: string
  }

  export type Boolean = {
    readonly type: "Boolean"
    value: boolean
  }

  export type List = {
    readonly type: "List"
    items: LispExpr[]
  }

  export type If = {
    readonly type: "If"
    condition: LispExpr
    consequent: LispExpr
    alternate: LispExpr
  }

  export type Lambda = {
    readonly type: "Lambda"
    params: string[]
    body: LispExpr
  }

  export type Let = {
    readonly type: "Let"
    bindings: Array<{ name: string; value: LispExpr }>
    body: LispExpr
  }
}

export const LispExpr = {
  symbol: (name: string): LispExpr.LispExpr => ({
    type: "Symbol",
    name
  }),

  number: (value: number): LispExpr.LispExpr => ({
    type: "Number",
    value
  }),

  string: (value: string): LispExpr.LispExpr => ({
    type: "String",
    value
  }),

  bool: (value: boolean): LispExpr.LispExpr => ({
    type: "Boolean",
    value
  }),

  list: (items: LispExpr.LispExpr[]): LispExpr.LispExpr => ({
    type: "List",
    items
  }),

  if: (
    condition: LispExpr.LispExpr,
    consequent: LispExpr.LispExpr,
    alternate: LispExpr.LispExpr
  ): LispExpr.LispExpr => ({
    type: "If",
    condition,
    consequent,
    alternate
  }),

  lambda: (params: string[], body: LispExpr.LispExpr): LispExpr.LispExpr => ({
    type: "Lambda",
    params,
    body
  }),

  let: (
    bindings: Array<{
      name: string
      value: LispExpr.LispExpr
    }>,
    body: LispExpr.LispExpr
  ): LispExpr.LispExpr => ({
    type: "Let",
    bindings,
    body
  })
}
</file>

<file path="examples/ini-parser.ts">
import {
  char,
  ErrorFormatter,
  optional,
  or,
  parser,
  regex,
  string,
  takeUpto
} from "../src"

// Data structures for INI file representation
interface IniSection {
  name: string
  properties: Map<string, string>
}

// Helper parsers
const whitespace = regex(/\s*/)
const horizontalSpace = regex(/[ \t]*/)
const eol = or(string("\n"), string("\r\n"), string("\r"))

// Parse section header like [database]
const sectionHeader = parser(function* () {
  yield* char("[")
  const name = yield* takeUpto(char("]"))
  yield* char("]")
  return name.trim()
})

// Parse key (left side of =)
const key = parser(function* () {
  const k = yield* takeUpto(char("="))
  return k.trim()
})

// Parse value (right side of =, until end of line)
const value = parser(function* () {
  const v = yield* takeUpto(eol)
  return v.trim()
})

// Parse key-value pair like "host=localhost"
const keyValue = parser(function* () {
  yield* horizontalSpace
  const k = yield* key
  yield* char("=")
  const v = yield* value
  return { key: k, value: v }
})

// Parse a complete section with key-value pairs
const iniSection = parser(function* () {
  // Parse section header
  yield* horizontalSpace
  const header = yield* sectionHeader
  yield* horizontalSpace
  yield* optional(eol)

  const pairs: Array<{ key: string; value: string }> = []

  // Parse key-value pairs
  while (true) {
    yield* horizontalSpace

    // Try to parse a key-value pair
    const pair = yield* optional(keyValue)
    if (!pair) {
      break
    }

    pairs.push(pair)
    yield* optional(eol)
  }

  const properties = new Map<string, string>()
  for (const pair of pairs) {
    properties.set(pair.key, pair.value)
  }

  return { name: header, properties }
})

// Test cases demonstrating the comparison with Megaparsec
console.log("=== Test 1: Valid section header ===")
const input1 = "[database]"
const result1 = sectionHeader.parse(input1)
if (result1.result._tag === "Left") {
  const formatter = new ErrorFormatter("ansi")
  console.log(formatter.format(result1.result.left))
} else {
  console.log("Success:", result1.result.right)
}

console.log("\n=== Test 2: Section with key-value pairs ===")
const input2 = `[database]
host=localhost
port=5432
user=admin`

const result2 = iniSection.parse(input2)
if (result2.result._tag === "Left") {
  const formatter = new ErrorFormatter("ansi")
  console.log(formatter.format(result2.result.left))
} else {
  console.log("Success:")
  console.log("Section name:", result2.result.right.name)
  console.log(
    "Properties:",
    Object.fromEntries(result2.result.right.properties)
  )
}

console.log("\n=== Test 3: Original failing input (malformed) ===")
const input3 = "[database\nhost=localhost"
const result3 = iniSection.parse(input3)
if (result3.result._tag === "Left") {
  const formatter = new ErrorFormatter("ansi")
  console.log("Expected error (missing closing bracket):")
  console.log(formatter.format(result3.result.left))
} else {
  console.log("Unexpected success:", result3.result.right)
}

console.log("\n=== Test 4: Section with whitespace ===")
const input4 = `[ cache ]
enabled = true
ttl = 3600`

const result4 = iniSection.parse(input4)
if (result4.result._tag === "Left") {
  const formatter = new ErrorFormatter("ansi")
  console.log(formatter.format(result4.result.left))
} else {
  console.log("Success:")
  console.log("Section name:", result4.result.right.name)
  console.log(
    "Properties:",
    Object.fromEntries(result4.result.right.properties)
  )
}

// Analysis: Missing features compared to Megaparsec Haskell version
console.log("\n=== Missing Features Analysis ===")
console.log(
  "Compared to the Haskell Megaparsec INI parser, parserator is missing:"
)
console.log("1. takeWhile/takeWhile1 combinators for character-based parsing")
console.log("2. skipLineComment combinator for handling ; and # comments")
console.log("3. lexeme combinator for automatic trailing whitespace handling")
console.log("4. notFollowedBy combinator for lookahead without consumption")
console.log("5. Built-in space consumer with comment support")
console.log("6. eof combinator to ensure complete input consumption")
console.log("7. Multiple section parsing with proper section separation")
console.log("8. Text trimming utilities integrated with parsing")
</file>

<file path="src/either.ts">
export type Either<R, L> = Left<L, R> | Right<R, L>

export class Left<L, R = never> {
  readonly _tag = "Left"
  constructor(public readonly left: L) {}
  *[Symbol.iterator](): Generator<Either<R, L>, R, any> {
    return yield this
  }
}

export class Right<R, L> {
  readonly _tag = "Right"
  constructor(public readonly right: R) {}
  *[Symbol.iterator](): Generator<Either<R, L>, R, any> {
    return yield this
  }
}

export const Either = {
  left<L, R = never>(l: L): Either<R, L> {
    return new Left(l)
  },

  right<R, L = never>(r: R): Either<R, L> {
    return new Right(r)
  },

  isLeft<R, L>(either: Either<R, L>): either is Left<L, R> {
    return either._tag === "Left"
  },

  isRight<R, L>(either: Either<R, L>): either is Right<R, L> {
    return either._tag === "Right"
  },

  match<R, L, T>(
    either: Either<R, L>,
    patterns: {
      onLeft: (left: L) => T
      onRight: (right: R) => T
    }
  ): T {
    if (Either.isLeft(either)) {
      return patterns.onLeft(either.left)
    }
    return patterns.onRight(either.right)
  },

  gen<R, L>(f: () => Generator<Either<any, L>, R, any>): Either<R, L> {
    const iterator = f()
    let current = iterator.next()

    while (!current.done) {
      const either = current.value
      if (Either.isLeft(either)) {
        return either
      }
      current = iterator.next(either.right)
    }

    return Either.right(current.value)
  }
}
</file>

<file path="src/error-formatter.ts">
import type { ParseErr, ParseErrorBundle } from "./rich-errors"

export type ErrorFormat = "plain" | "ansi" | "html" | "json"

export type ErrorFormatterOptions = {
	maxContextLines?: number
	showHints?: boolean
	colorize?: boolean
	showContext?: boolean
	tabSize?: number
}

/**
 * Formats ParseErrorBundle into human-readable error messages with multiple output formats.
 * Supports plain text, ANSI colors, HTML, and JSON formats.
 */
export class ErrorFormatter {
	private _format: ErrorFormat
	private options: ErrorFormatterOptions

	constructor(
		format: ErrorFormat = "plain",
		options: ErrorFormatterOptions = {},
	) {
		this._format = format
		// Set default options
		this.options = {
			maxContextLines: 3,
			showHints: true,
			colorize: true,
			showContext: true,
			tabSize: 2,
			...options,
		}
	}

	/**
	 * Format a ParseErrorBundle into a string based on the configured format.
	 * 
	 * @param bundle - The error bundle to format
	 * @returns Formatted error message string
	 */
	format(bundle: ParseErrorBundle): string {
		switch (this._format) {
			case "ansi":
				return this.formatAnsi(bundle)
			case "html":
				return this.formatHtml(bundle)
			case "json":
				return this.formatJson(bundle)
			default:
				return this.formatPlain(bundle)
		}
	}

	/**
	 * Format error with ANSI color codes for terminal output.
	 */
	private formatAnsi(bundle: ParseErrorBundle): string {
		const primary = bundle.primary
		const lines = bundle.source.split("\n")
		const errorLine = lines[primary.span.line - 1] || ""

		const parts: string[] = []

		// Error header with location
		parts.push(
			`\x1b[31mError\x1b[0m at line ${primary.span.line}, column ${primary.span.column}:`,
		)

		// Show context lines if enabled
		if (this.options.showContext && this.options.maxContextLines! > 0) {
			const contextLines = this.getContextLines(
				lines,
				primary.span.line - 1,
				this.options.maxContextLines!,
			)
			parts.push(...contextLines.map((line) => `  ${line}`))
		} else {
			// Just show the error line
			parts.push(`  ${errorLine}`)
		}

		// Add pointer arrow (accounting for line prefix)
		const linePrefix = `  >   ${primary.span.line.toString().padStart(3, " ")} | `
		const adjustedColumn = primary.span.column + linePrefix.length - 2 // -2 for the "  " we add
		const pointer = this.createPointer(adjustedColumn, primary.span.length)
		parts.push(`  ${pointer}`)

		// Error message
		parts.push(this.formatErrorMessage(primary))

		// Add hints if available
		const hints = this.getHints(primary)
		if (this.options.showHints && hints.length > 0) {
			parts.push("")
			for (const hint of hints) {
				parts.push(`  \x1b[36mDid you mean: ${hint}?\x1b[0m`)
			}
		}

		// Add context stack if available
		if (
			this.options.showContext &&
			primary.context &&
			primary.context.length > 0
		) {
			parts.push("")
			parts.push(`  \x1b[90mContext: ${primary.context.join(" > ")}\x1b[0m`)
		}

		return parts.join("\n")
	}

	/**
	 * Format error as plain text without colors.
	 */
	private formatPlain(bundle: ParseErrorBundle): string {
		const primary = bundle.primary
		const lines = bundle.source.split("\n")
		const errorLine = lines[primary.span.line - 1] || ""

		const parts: string[] = []

		// Error header
		parts.push(
			`Error at line ${primary.span.line}, column ${primary.span.column}:`,
		)

		// Show context lines
		if (this.options.showContext && this.options.maxContextLines! > 0) {
			const contextLines = this.getContextLines(
				lines,
				primary.span.line - 1,
				this.options.maxContextLines!,
			)
			parts.push(...contextLines.map((line) => `  ${line}`))
		} else {
			parts.push(`  ${errorLine}`)
		}

		// Add pointer (accounting for line prefix)
		const linePrefix = `  >   ${primary.span.line.toString().padStart(3, " ")} | `
		const adjustedColumn = primary.span.column + linePrefix.length - 2 // -2 for the "  " we add
		const pointer = this.createPointer(adjustedColumn, primary.span.length, false)
		parts.push(`  ${pointer}`)

		// Error message
		parts.push(this.formatErrorMessage(primary, false))

		// Add hints
		const hints = this.getHints(primary)
		if (this.options.showHints && hints.length > 0) {
			parts.push("")
			for (const hint of hints) {
				parts.push(`  Did you mean: ${hint}?`)
			}
		}

		// Add context
		if (
			this.options.showContext &&
			primary.context &&
			primary.context.length > 0
		) {
			parts.push("")
			parts.push(`  Context: ${primary.context.join(" > ")}`)
		}

		return parts.join("\n")
	}

	/**
	 * Format error as HTML with styling.
	 */
	private formatHtml(bundle: ParseErrorBundle): string {
		const primary = bundle.primary
		const lines = bundle.source.split("\n")
		const errorLine = lines[primary.span.line - 1] || ""

		const parts: string[] = []

		parts.push('<div class="parse-error">')

		// Error header
		parts.push(
			`  <div class="error-header">Error at line ${primary.span.line}, column ${primary.span.column}:</div>`,
		)

		// Code context
		parts.push('  <div class="error-context">')
		if (this.options.showContext && this.options.maxContextLines! > 0) {
			const contextLines = this.getContextLines(
				lines,
				primary.span.line - 1,
				this.options.maxContextLines!,
			)
			for (const line of contextLines) {
				parts.push(`    <div class="context-line">${this.escapeHtml(line)}</div>`)
			}
		} else {
			parts.push(
				`    <div class="error-line">${this.escapeHtml(errorLine)}</div>`,
			)
		}

		// Pointer (accounting for line prefix in plain text representation)
		const pointer = this.createPointer(primary.span.column, primary.span.length, false)
		parts.push(`    <div class="error-pointer">${pointer}</div>`)
		parts.push("  </div>")

		// Error message
		parts.push(
			`  <div class="error-message">${this.escapeHtml(this.formatErrorMessage(primary, false))}</div>`,
		)

		// Hints
		const hints = this.getHints(primary)
		if (this.options.showHints && hints.length > 0) {
			parts.push('  <div class="error-hints">')
			for (const hint of hints) {
				parts.push(
					`    <div class="hint">Did you mean: <span class="suggestion">${this.escapeHtml(hint)}</span>?</div>`,
				)
			}
			parts.push("  </div>")
		}

		// Context
		if (
			this.options.showContext &&
			primary.context &&
			primary.context.length > 0
		) {
			parts.push(
				`  <div class="error-context-stack">Context: ${primary.context.map((c) => `<span class="context-item">${this.escapeHtml(c)}</span>`).join(" &gt; ")}</div>`,
			)
		}

		parts.push("</div>")

		return parts.join("\n")
	}

	/**
	 * Format error as JSON for programmatic consumption.
	 */
	private formatJson(bundle: ParseErrorBundle): string {
		const primary = bundle.primary
		const lines = bundle.source.split("\n")

		const contextLines = this.options.showContext
			? this.getContextLines(
					lines,
					primary.span.line - 1,
					this.options.maxContextLines!,
			  )
			: [lines[primary.span.line - 1] || ""]

		return JSON.stringify(
			{
				error: {
					type: primary.tag,
					message: this.getPlainErrorMessage(primary),
					location: {
						line: primary.span.line,
						column: primary.span.column,
						offset: primary.span.offset,
						length: primary.span.length,
					},
					context: {
						lines: contextLines,
						stack: primary.context || [],
					},
					hints: this.getHints(primary),
					source: bundle.source,
				},
				allErrors: bundle.errors.map((err) => ({
					type: err.tag,
					location: {
						line: err.span.line,
						column: err.span.column,
						offset: err.span.offset,
						length: err.span.length,
					},
					context: err.context || [],
					...(err.tag === "Expected" && { items: err.items }),
					...(err.tag === "Unexpected" && { found: err.found }),
					...(err.tag === "Custom" && { 
						message: err.message,
						hints: err.hints 
					}),
				})),
			},
			null,
			this.options.tabSize,
		)
	}

	/**
	 * Format the error message based on error type.
	 */
	private formatErrorMessage(error: ParseErr, useColors: boolean = true): string {
		const red = useColors ? "\x1b[31m" : ""
		const yellow = useColors ? "\x1b[33m" : ""
		const reset = useColors ? "\x1b[0m" : ""

		switch (error.tag) {
			case "Expected":
				return `  ${yellow}Expected:${reset} ${error.items.join(" or ")}`
			case "Unexpected":
				return `  ${red}Unexpected:${reset} ${error.found}`
			case "Custom":
				return `  ${error.message}`
		}
	}

	/**
	 * Get plain error message without formatting.
	 */
	private getPlainErrorMessage(error: ParseErr): string {
		switch (error.tag) {
			case "Expected":
				return `Expected: ${error.items.join(" or ")}`
			case "Unexpected":
				return `Unexpected: ${error.found}`
			case "Custom":
				return error.message
		}
	}

	/**
	 * Create a pointer/caret pointing to the error location.
	 */
	private createPointer(
		column: number,
		length: number = 1,
		useColors: boolean = true,
	): string {
		const spaces = " ".repeat(Math.max(0, column - 1))
		const carets = "^".repeat(Math.max(1, length))
		const red = useColors ? "\x1b[31m" : ""
		const reset = useColors ? "\x1b[0m" : ""
		return `${spaces}${red}${carets}${reset}`
	}

	/**
	 * Get context lines around the error location.
	 */
	private getContextLines(
		allLines: string[],
		errorLineIndex: number,
		maxLines: number,
	): string[] {
		const contextRadius = Math.floor(maxLines / 2)
		const startLine = Math.max(0, errorLineIndex - contextRadius)
		const endLine = Math.min(allLines.length - 1, errorLineIndex + contextRadius)

		const contextLines: string[] = []
		for (let i = startLine; i <= endLine; i++) {
			const lineNum = i + 1
			const lineContent = allLines[i] || ""
			const isErrorLine = i === errorLineIndex
			const prefix = isErrorLine ? ">" : " "
			const paddedLineNum = lineNum.toString().padStart(3, " ")
			contextLines.push(`${prefix} ${paddedLineNum} | ${lineContent}`)
		}

		return contextLines
	}

	/**
	 * Escape HTML entities.
	 */
	private escapeHtml(text: string): string {
		return text
			.replace(/&/g, "&amp;")
			.replace(/</g, "&lt;")
			.replace(/>/g, "&gt;")
			.replace(/"/g, "&quot;")
			.replace(/'/g, "&#39;")
	}

	/**
	 * Create a new formatter with different options.
	 */
	withOptions(options: Partial<ErrorFormatterOptions>): ErrorFormatter {
		return new ErrorFormatter(this._format, { ...this.options, ...options })
	}

	/**
	 * Create a new formatter with a different format.
	 */
	withFormat(format: ErrorFormat): ErrorFormatter {
		return new ErrorFormatter(format, this.options)
	}

	/**
	 * Get hints from an error, handling the union type safely.
	 */
	private getHints(error: ParseErr): string[] {
		if (error.tag === "Custom" && error.hints) {
			return error.hints
		}
		if (error.tag === "Unexpected" && error.hints) {
			return error.hints
		}
		return []
	}
}

/**
 * Convenience functions for quick formatting.
 */
export const formatError = {
	plain: (bundle: ParseErrorBundle, options?: ErrorFormatterOptions) =>
		new ErrorFormatter("plain", options).format(bundle),
	ansi: (bundle: ParseErrorBundle, options?: ErrorFormatterOptions) =>
		new ErrorFormatter("ansi", options).format(bundle),
	html: (bundle: ParseErrorBundle, options?: ErrorFormatterOptions) =>
		new ErrorFormatter("html", options).format(bundle),
	json: (bundle: ParseErrorBundle, options?: ErrorFormatterOptions) =>
		new ErrorFormatter("json", options).format(bundle),
}
</file>

<file path="src/rich-errors.ts">
export type Span = {
  offset: number
  length: number
  line: number
  column: number
}

export type ParseErr =
  | { tag: "Expected"; span: Span; items: string[]; context: string[] }
  | {
      tag: "Unexpected"
      span: Span
      found: string
      context: string[]
      hints?: string[]
    }
  | {
      tag: "Custom"
      span: Span
      message: string
      hints?: string[]
      context: string[]
    }

export class ParseErrorBundle {
  constructor(
    public errors: ParseErr[],
    public source: string
  ) {}

  // Get the primary error (furthest right)
  get primary(): ParseErr {
    return this.errors.reduce((furthest, current) =>
      current.span.offset > furthest.span.offset ? current : furthest
    )
  }

  // Get all errors at the same furthest offset
  get primaryErrors(): ParseErr[] {
    const maxOffset = this.primary.span.offset
    return this.errors.filter(err => err.span.offset === maxOffset)
  }
}

// Helper function to create a span from parser state
export function createSpan(
  state: { pos: { offset: number; line: number; column: number } },
  length: number = 0
): Span {
  return {
    offset: state.pos.offset,
    length,
    line: state.pos.line,
    column: state.pos.column
  }
}

// // Adapter to maintain backwards compatibility with existing ParserError
// import { ParserError } from "./state"

// export function legacyError(bundle: ParseErrorBundle): ParserError {
//   const primary = bundle.primary
//   return new ParserError(
//     primary.tag === "Custom" ?
//       primary.message
//     : `${primary.tag}: ${JSON.stringify(primary)}`,
//     primary.tag === "Expected" ? primary.items : [],
//     primary.tag === "Unexpected" ? primary.found : undefined
//   )
// }
</file>

<file path="src/types.ts">
export type Prettify<T> = { [K in keyof T]: T[K] } & {}

export type Last<T> = T extends [...any[], infer L] ? L : never
</file>

<file path="tests/hints.test.ts">
import { describe, expect, test } from "bun:test"
import { Either } from "../src/either"
import {
  anyKeywordWithHints,
  generateHints,
  keywordWithHints,
  levenshteinDistance,
  stringWithHints
} from "../src/hints"
import type { ParseErrorBundle } from "../src/rich-errors"

// Helper to get error message from ParseErrorBundle
function getErrorMessage(bundle: ParseErrorBundle): string {
  const primary = bundle.primary
  if (primary.tag === "Custom") {
    return primary.message
  } else if (primary.tag === "Unexpected") {
    return `Unexpected: ${primary.found}`
  } else {
    return `Expected: ${primary.items.join(", ")}`
  }
}

describe("hint generation", () => {
  describe("levenshteinDistance", () => {
    test("identical strings have distance 0", () => {
      expect(levenshteinDistance("hello", "hello")).toBe(0)
      expect(levenshteinDistance("", "")).toBe(0)
      expect(levenshteinDistance("a", "a")).toBe(0)
    })

    test("empty string distances", () => {
      expect(levenshteinDistance("", "hello")).toBe(5)
      expect(levenshteinDistance("hello", "")).toBe(5)
    })

    test("single character operations", () => {
      // Single insertion
      expect(levenshteinDistance("cat", "cats")).toBe(1)
      // Single deletion
      expect(levenshteinDistance("cats", "cat")).toBe(1)
      // Single substitution
      expect(levenshteinDistance("cat", "bat")).toBe(1)
    })

    test("complex transformations", () => {
      expect(levenshteinDistance("kitten", "sitting")).toBe(3)
      expect(levenshteinDistance("saturday", "sunday")).toBe(3)
      expect(levenshteinDistance("lambda", "lamdba")).toBe(2) // transpose
    })

    test("case sensitivity", () => {
      expect(levenshteinDistance("Hello", "hello")).toBe(1)
      expect(levenshteinDistance("TEST", "test")).toBe(4)
    })
  })

  describe("generateHints", () => {
    const keywords = ["lambda", "let", "if", "cond", "define", "quote"]

    test("exact matches are excluded", () => {
      const hints = generateHints("lambda", keywords)
      expect(hints).toEqual([])
    })

    test("close matches within distance", () => {
      const hints = generateHints("lamdba", keywords)
      expect(hints).toContain("lambda")
    })

    test("sorts by edit distance", () => {
      const hints = generateHints("lam", keywords, 3) // Increase max distance
      // "lam" -> "let" = distance 2 (substitute a->e, add t)
      // "lam" -> "lambda" = distance 3 (add b, d, a)
      // So "let" should come before "lambda"
      expect(hints.length).toBeGreaterThan(0)
      expect(hints[0]).toBe("let") // closest match first
      expect(hints).toContain("lambda")
    })

    test("respects maxDistance parameter", () => {
      const hints = generateHints("xyz", keywords, 1)
      expect(hints).toEqual([]) // no keywords within distance 1

      const hintsWithHigherDistance = generateHints("xyz", keywords, 3)
      expect(hintsWithHigherDistance.length).toBeGreaterThan(0)
    })

    test("respects maxHints parameter", () => {
      const hints = generateHints("x", keywords, 5, 2)
      expect(hints.length).toBeLessThanOrEqual(2)
    })

    test("common programming typos", () => {
      const jsKeywords = ["function", "const", "let", "var", "class", "return"]

      expect(generateHints("functoin", jsKeywords)).toContain("function")
      expect(generateHints("calss", jsKeywords)).toContain("class")
      expect(generateHints("retrun", jsKeywords)).toContain("return")
    })

    test("empty expected array", () => {
      const hints = generateHints("test", [])
      expect(hints).toEqual([])
    })
  })

  describe("keywordWithHints", () => {
    const schemeKeywords = ["lambda", "let", "if", "cond", "define", "quote"]
    const lambdaParser = keywordWithHints(schemeKeywords)("lambda")

    test("matches exact keyword", () => {
      const result = lambdaParser.parse("lambda")
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("lambda")
      }
    })

    test("provides hints for typos", () => {
      const result = lambdaParser.parse("lamdba")
      expect(Either.isLeft(result.result)).toBe(true)
      if (Either.isLeft(result.result)) {
        const error = result.result.left
        const primary = error.primary
        if (primary.tag === "Unexpected") {
          expect(primary.found).toBe("lamdba")
          expect(primary.hints).toContain("lambda")
        } else if (primary.tag === "Custom") {
          expect(primary.message).toContain("Unexpected")
          expect(primary.message).toContain("lamdba")
        }
      }
    })

    test("handles non-alphabetic characters", () => {
      const result = lambdaParser.parse("123")
      expect(Either.isLeft(result.result)).toBe(true)
      if (Either.isLeft(result.result)) {
        const error = result.result.left
        expect(getErrorMessage(error)).toContain("Unexpected")
      }
    })

    test("handles end of input", () => {
      const result = lambdaParser.parse("")
      expect(Either.isLeft(result.result)).toBe(true)
    })

    test("keyword boundary handling", () => {
      const result = lambdaParser.parse("lambdaXYZ")
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("lambda")
        expect(result.state.remaining).toBe("XYZ")
      }
    })
  })

  describe("anyKeywordWithHints", () => {
    const keywords = ["red", "green", "blue", "yellow"]
    const colorParser = anyKeywordWithHints(keywords)

    test("matches any valid keyword", () => {
      for (const keyword of keywords) {
        const result = colorParser.parse(keyword)
        expect(Either.isRight(result.result)).toBe(true)
        if (Either.isRight(result.result)) {
          expect(result.result.right).toBe(keyword)
        }
      }
    })

    test("provides hints for invalid input", () => {
      const result = colorParser.parse("gren")
      expect(Either.isLeft(result.result)).toBe(true)
      if (Either.isLeft(result.result)) {
        const error = result.result.left
        expect(getErrorMessage(error)).toContain("gren")
      }
    })

    test("chooses first matching keyword", () => {
      const overlappingKeywords = ["test", "testing", "tester"]
      const parser = anyKeywordWithHints(overlappingKeywords)
      const result = parser.parse("testing")

      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("test")
      }
    })
  })

  describe("stringWithHints", () => {
    const validColors = ["red", "green", "blue", "yellow"]
    const colorStringParser = stringWithHints(validColors)

    test("matches valid quoted strings", () => {
      const result = colorStringParser.parse('"red"')
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("red")
      }
    })

    test("provides hints for invalid content", () => {
      const result = colorStringParser.parse('"gren"')
      expect(Either.isLeft(result.result)).toBe(true)
      if (Either.isLeft(result.result)) {
        const error = result.result.left
        expect(getErrorMessage(error)).toContain("gren")
      }
    })

    test("requires opening quote", () => {
      const result = colorStringParser.parse("red")
      expect(Either.isLeft(result.result)).toBe(true)
      if (Either.isLeft(result.result)) {
        const error = result.result.left
        expect(getErrorMessage(error)).toContain("Expected")
        expect(getErrorMessage(error)).toContain("string literal")
      }
    })

    test("requires closing quote", () => {
      const result = colorStringParser.parse('"red')
      expect(Either.isLeft(result.result)).toBe(true)
      if (Either.isLeft(result.result)) {
        const error = result.result.left
        expect(getErrorMessage(error)).toContain("closing quote")
      }
    })

    test("handles empty strings", () => {
      const parserWithEmpty = stringWithHints(["", "test"])
      const result = parserWithEmpty.parse('""')
      expect(Either.isRight(result.result)).toBe(true)
      if (Either.isRight(result.result)) {
        expect(result.result.right).toBe("")
      }
    })
  })

  describe("integration with labels", () => {
    test("hints work with labeled parsers", () => {
      const keywords = ["lambda", "let", "if"]
      const parser =
        keywordWithHints(keywords)("lambda").label("lambda keyword")

      const result = parser.parse("lamdba")
      expect(Either.isLeft(result.result)).toBe(true)
      if (Either.isLeft(result.result)) {
        const error = result.result.left
        expect(getErrorMessage(error)).toContain("Expected")
      }
    })

    test("context is preserved in hints", () => {
      const keywords = ["function", "method", "procedure"]
      const parser = anyKeywordWithHints(keywords)
        .label("declaration keyword")
        .label("function declaration")

      // This should preserve the context stack
      const result = parser.parse("functin")
      expect(Either.isLeft(result.result)).toBe(true)
    })
  })

  describe("real-world scenarios", () => {
    test("JavaScript keyword suggestions", () => {
      const jsKeywords = [
        "function",
        "const",
        "let",
        "var",
        "class",
        "if",
        "else",
        "for",
        "while",
        "return",
        "import",
        "export",
        "default"
      ]

      const testCases = [
        { input: "functoin", expected: "function" },
        { input: "retrun", expected: "return" },
        { input: "calss", expected: "class" },
        { input: "ipmort", expected: "import" }
      ]

      for (const { input, expected } of testCases) {
        const hints = generateHints(input, jsKeywords)
        expect(hints).toContain(expected)
      }
    })

    test("SQL keyword suggestions", () => {
      const sqlKeywords = [
        "SELECT",
        "FROM",
        "WHERE",
        "ORDER",
        "GROUP",
        "INSERT",
        "UPDATE",
        "DELETE"
      ]

      const hints = generateHints("SLECT", sqlKeywords)
      expect(hints).toContain("SELECT")
    })

    test("HTML tag suggestions", () => {
      const htmlTags = [
        "div",
        "span",
        "p",
        "h1",
        "h2",
        "button",
        "input",
        "form"
      ]

      const hints = generateHints("botton", htmlTags)
      expect(hints).toContain("button")
    })
  })
})
</file>

<file path="tests/label-system.test.ts">
import { describe, expect, test } from "bun:test"
import { char, regex } from "../src/combinators"
import { Either } from "../src/either"
import { Parser } from "../src/parser"
import type { ParseErrorBundle } from "../src/rich-errors"

// Helper to get error message from ParseErrorBundle
function getErrorMessage(bundle: ParseErrorBundle): string {
	const primary = bundle.primary
	if (primary.tag === "Custom") {
		return primary.message
	} else if (primary.tag === "Unexpected") {
		return `Unexpected: ${primary.found}`
	} else {
		return `Expected: ${primary.items.join(", ")}`
	}
}

describe("label system", () => {
	describe(".label() method", () => {
		test("adds label to context stack", () => {
			const parser = char("a").label("letter a")
			const result = parser.parse("b")
			
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				// The error should reference the label
				expect(getErrorMessage(error)).toContain("Expected")
			}
		})

		test("nested labels create context stack", () => {
			const identifier = regex(/[a-zA-Z_][a-zA-Z0-9_]*/).label("identifier")
			const functionCall = char("(")
				.then(identifier.label("function name"))
				.thenDiscard(char(")"))
				.label("function call")
			
			const result = functionCall.parse("(123)")
			
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("Expected")
			}
		})

		test("successful parse preserves context", () => {
			const parser = char("a").label("letter a")
			const result = parser.parse("a")
			
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("a")
			}
		})

		test("label doesn't interfere with successful parsing", () => {
			const identifierParser = regex(/[a-zA-Z_][a-zA-Z0-9_]*/).label("identifier")
			const result = identifierParser.parse("hello")
			
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("hello")
			}
		})
	})

	describe(".expect() method", () => {
		test("combines label and error message", () => {
			const parser = regex(/\d+/).expect("a numeric value")
			const result = parser.parse("abc")
			
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				// The expect method creates both a label and a withError message
				// For now, just check that it contains some expected text
				expect(getErrorMessage(error)).toContain("Expected")
			}
		})

		test("expect works with successful parsing", () => {
			const parser = regex(/\d+/).expect("a numeric value")
			const result = parser.parse("123")
			
			expect(Either.isRight(result.result)).toBe(true)
			if (Either.isRight(result.result)) {
				expect(result.result.right).toBe("123")
			}
		})
	})

	describe("complex label scenarios", () => {
		test("multiple levels of labeling", () => {
			const digit = regex(/\d/).label("digit")
			const number = regex(/\d+/).label("number")
			const expression = number.label("expression")
			
			const result = expression.parse("abc")
			
			expect(Either.isLeft(result.result)).toBe(true)
		})

		test("label with generator syntax", () => {
			const parser = Parser.gen(function* () {
				const open = yield* char("(").label("opening parenthesis")
				const content = yield* regex(/[a-z]+/).label("content")
				const close = yield* char(")").label("closing parenthesis")
				return { open, content, close }
			}).label("parenthesized expression")
			
			const result = parser.parse("(hello]")
			
			expect(Either.isLeft(result.result)).toBe(true)
			if (Either.isLeft(result.result)) {
				const error = result.result.left
				expect(getErrorMessage(error)).toContain("Expected")
			}
		})

		test("labels preserve through combinators", () => {
			const letterA = char("a").label("letter A")
			const letterB = char("b").label("letter B") 
			const either = letterA.then(letterB).label("sequence AB")
			
			const result = either.parse("ac")
			
			expect(Either.isLeft(result.result)).toBe(true)
		})
	})

	describe("context stack behavior", () => {
		test("label stack accumulates correctly", () => {
			// Create a parser that we can inspect the state of
			let capturedContext: any = null
			const inspector = new Parser((state) => {
				capturedContext = state.context
				return Parser.succeed("test", state)
			})

			const labeled = inspector.label("outer").label("inner")
			labeled.parse("test")

			expect(capturedContext?.labelStack).toEqual(["outer", "inner"])
		})

		test("label stack is isolated per parse", () => {
			let firstContext: any = null
			let secondContext: any = null

			const inspector1 = new Parser((state) => {
				firstContext = state.context
				return Parser.succeed("test1", state)
			})

			const inspector2 = new Parser((state) => {
				secondContext = state.context
				return Parser.succeed("test2", state)
			})

			inspector1.label("first").parse("test")
			inspector2.label("second").parse("test")

			expect(firstContext?.labelStack).toEqual(["first"])
			expect(secondContext?.labelStack).toEqual(["second"])
		})
	})
})
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,
    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "declaration": true,
    "declarationMap": true,
    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
</file>

<file path="tsconfig.types.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "emitDeclarationOnly": true,
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*.ts"]
}
</file>

<file path="typedoc.json">
{
  "$schema": "https://typedoc.org/schema.json",
  "entryPoints": ["src/index.ts"],
  "entryPointStrategy": "expand",
  "out": "docs",
  "name": "Parserator",
  "includeVersion": true,
  "navigationLinks": {
    "GitHub": "https://github.com/saiashirwad/parserator",
    "NPM": "https://www.npmjs.com/package/parserator"
  },
  "categorizeByGroup": true,
  "searchInComments": true,
  "readme": "README.md",
  "sort": ["source-order"],
  "excludePrivate": true,
  "excludeInternal": true,
  "validation": {
    "invalidLink": true,
    "notDocumented": true
  }
}
</file>

<file path="src/index.ts">
export * from "./chain"
export * from "./combinators"
export * from "./debug"
export * from "./either"
export * from "./error-formatter"
export * from "./errors"
export * from "./hints"
export * from "./parser"
export * from "./rich-errors"
export * from "./state"
export * from "./types"
export * from "./utils"
</file>

<file path="build.ts">
import { copyFile } from "node:fs/promises"
import { join } from "node:path"

async function main() {
  await copyFile(join("dist", "index.d.ts"), join("dist", "index.d.cts"))
}

main().catch(console.error)
</file>

<file path="src/utils.ts">
import { Parser } from "./parser"

export const peekState = new Parser(s => {
  return Parser.succeed(s, s)
})

export const peekRemaining = new Parser(s => {
  console.log(s.remaining)
  return Parser.succeed(s.remaining, s)
})

export const peekAhead = (n: number) =>
  new Parser(s => {
    return Parser.succeed(s.remaining.slice(0, n), s)
  })

export const peekLine = new Parser(s => {
  const restOfLine = s.remaining.slice(0, s.remaining.indexOf("\n"))
  console.log(restOfLine)
  return Parser.succeed(restOfLine, s)
})

export const peekUntil = (ch: string) =>
  new Parser(s => {
    const index = s.remaining.indexOf(ch)
    return Parser.succeed(s.remaining.slice(0, index), s)
  })
</file>

<file path="biome.json">
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": []
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "tab"
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": false
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double",
      "semicolons": "asNeeded",
      "lineWidth": 80
    }
  }
}
</file>

<file path="examples/scheme/example.ts">
import { ErrorFormatter } from "../../src"
import { lispParser } from "./parser"

const program = `(+ 5  (+ 3 5)`

const result = lispParser.parse(program)
if (result.result._tag === "Left") {
  const error = result.result.left
  const formatter = new ErrorFormatter("json")
  console.log(formatter.format(error))
}
</file>

<file path="examples/scheme/scheme.test.ts">
import { describe, expect, it } from "bun:test"
import { LispExpr } from "./ast"
import { expr } from "./parser"

describe("scheme", () => {
  it("should parse a simple expression", () => {
    const result = expr.parseOrThrow("(+ 1 2)")
    expect(result).toEqual(
      LispExpr.list([
        LispExpr.symbol("+"),
        LispExpr.number(1),
        LispExpr.number(2)
      ])
    )
  })

  it("should parse a nested expression", () => {
    const result = expr.parseOrThrow("(+ 1 (+ 2 3))")
    expect(result).toEqual(
      LispExpr.list([
        LispExpr.symbol("+"),
        LispExpr.number(1),
        LispExpr.list([
          LispExpr.symbol("+"),
          LispExpr.number(2),
          LispExpr.number(3)
        ])
      ])
    )
  })

  it("should parse a string literal", () => {
    const result = expr.parseOrThrow('"hello"')
    expect(result).toEqual(LispExpr.string("hello"))
  })

  it("should parse a boolean literal", () => {
    const result1 = expr.parseOrThrow("#t")
    expect(result1).toEqual(LispExpr.bool(true))
    const result2 = expr.parseOrThrow("#f")
    expect(result2).toEqual(LispExpr.bool(false))
  })

  it("should parse a symbol", () => {
    const result = expr.parseOrThrow("hello")
    expect(result).toEqual(LispExpr.symbol("hello"))
  })

  it("should parse a symbol with special characters", () => {
    const result = expr.parseOrThrow("hello-world!")
    expect(result).toEqual(LispExpr.symbol("hello-world!"))
  })

  it("should fail on empty symbol", () => {
    const { result } = expr.parse("")
    expect(result._tag).toEqual("Left")
  })

  it("should parse a list", () => {
    const result = expr.parseOrThrow("(1 2 3)")
    expect(result).toEqual(
      LispExpr.list([
        LispExpr.number(1),
        LispExpr.number(2),
        LispExpr.number(3)
      ])
    )
  })

  it("should fail on empty list", () => {
    const { result } = expr.parse("()")
    expect(result._tag).toEqual("Left")
  })

  it("should parse a let expression with multiple bindings", () => {
    const result = expr.parseOrThrow("(let ((x 1) (y 2)) (+ x y))")
    expect(result).toEqual(
      LispExpr.let(
        [
          { name: "x", value: LispExpr.number(1) },
          { name: "y", value: LispExpr.number(2) }
        ],
        LispExpr.list([
          LispExpr.symbol("+"),
          LispExpr.symbol("x"),
          LispExpr.symbol("y")
        ])
      )
    )
  })

  it("should parse a let expression with a nested let expression", () => {
    const result = expr.parseOrThrow("(let ((x 1)) (let ((y 2)) (+ x y)))")
    expect(result).toEqual(
      LispExpr.let(
        [{ name: "x", value: LispExpr.number(1) }],
        LispExpr.let(
          [{ name: "y", value: LispExpr.number(2) }],
          LispExpr.list([
            LispExpr.symbol("+"),
            LispExpr.symbol("x"),
            LispExpr.symbol("y")
          ])
        )
      )
    )
  })

  it("should parse a lambda expression", () => {
    const result = expr.parseOrThrow("(lambda (x) (+ x 2))")
    expect(result).toEqual(
      LispExpr.lambda(
        ["x"],
        LispExpr.list([
          LispExpr.symbol("+"),
          LispExpr.symbol("x"),
          LispExpr.number(2)
        ])
      )
    )
  })

  it("should parse a let expression with a lambda expression", () => {
    const result = expr.parseOrThrow("(let ((x (lambda (y) y))) (x))")
    expect(result).toEqual(
      LispExpr.let(
        [
          {
            name: "x",
            value: LispExpr.lambda(["y"], LispExpr.symbol("y"))
          }
        ],
        LispExpr.list([LispExpr.symbol("x")])
      )
    )
  })

  it("should parse a list", () => {
    const result = expr.parseOrThrow("(a b c)")
    expect(result).toEqual(
      LispExpr.list([
        LispExpr.symbol("a"),
        LispExpr.symbol("b"),
        LispExpr.symbol("c")
      ])
    )
  })

  it("should parse a let expression with a single binding", () => {
    const result = expr.parseOrThrow("(let ((x 1)) x)")
    expect(result).toEqual(
      LispExpr.let(
        [{ name: "x", value: LispExpr.number(1) }],
        LispExpr.symbol("x")
      )
    )
  })
})
</file>

<file path="src/chain.ts">
import { Either } from "./either"
import { Parser } from "./parser"
import type { ParseErrorBundle } from "./rich-errors"

export type Chain<Ctx = {}> = {
  <T, U>(parser: Parser<T, Ctx>, fn1: (value: T) => Parser<U>): Parser<U>
  <T1, T2, T3>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>
  ): Parser<T3>
  <T1, T2, T3, T4>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>
  ): Parser<T4>
  <T1, T2, T3, T4, T5>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>
  ): Parser<T5>
  <T1, T2, T3, T4, T5, T6>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>
  ): Parser<T6>
  <T1, T2, T3, T4, T5, T6, T7>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>,
    fn6: (value: T6) => Parser<T7, Ctx>
  ): Parser<T7>
  <T1, T2, T3, T4, T5, T6, T7, T8>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>,
    fn6: (value: T6) => Parser<T7, Ctx>,
    fn7: (value: T7) => Parser<T8, Ctx>
  ): Parser<T8>
  <T1, T2, T3, T4, T5, T6, T7, T8, T9>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>,
    fn6: (value: T6) => Parser<T7, Ctx>,
    fn7: (value: T7) => Parser<T8, Ctx>,
    fn8: (value: T8) => Parser<T9, Ctx>
  ): Parser<T9>
  <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
    parser: Parser<T1, Ctx>,
    fn1: (value: T1) => Parser<T2, Ctx>,
    fn2: (value: T2) => Parser<T3, Ctx>,
    fn3: (value: T3) => Parser<T4, Ctx>,
    fn4: (value: T4) => Parser<T5, Ctx>,
    fn5: (value: T5) => Parser<T6, Ctx>,
    fn6: (value: T6) => Parser<T7, Ctx>,
    fn7: (value: T7) => Parser<T8, Ctx>,
    fn8: (value: T8) => Parser<T9, Ctx>,
    fn9: (value: T9) => Parser<T10, Ctx>
  ): Parser<T10>
}

export const chain = <Ctx = {}>(
  parser: Parser<any, Ctx>,
  ...fns: Array<(value: any) => Parser<any, Ctx>>
): Chain<Ctx> => {
  return new Parser<any, Ctx>(state => {
    let result = parser.run(state)
    for (const fn of fns) {
      const { result: parserResult, state: newState } = result
      if (Either.isLeft(parserResult)) {
        return { result: parserResult as unknown as Either<any, ParseErrorBundle>, state: newState }
      }
      const value = parserResult.right
      result = fn(value).run(newState)
    }
    return result
  }) as any
}
</file>

<file path="src/errors.ts">
import type { ParserState, SourcePosition } from "./state"

export function printPosition(position: SourcePosition) {
  return `line ${position.line}, column ${position.column}`
}

export function printArrow(position: SourcePosition) {
  const lineNumberDigits = position.line.toString().length
  return " ".repeat(lineNumberDigits + 3 + position.column - 1) + "^"
}

export function printErrorContext<Ctx = {}>(
  state: ParserState<Ctx>,
  message?: string
) {
  return (
    "Parser Error:\n" +
    printErrorLine(state) +
    "\n" +
    printArrow(state.pos) +
    `${message ? `\n${message}` : ""}`
  )
}

export function printErrorLine<Ctx = {}>(state: ParserState<Ctx>) {
  const lines = state.context.source.split("\n")
  const lineNum = state.pos.line
  const startLine = Math.max(0, lineNum - 1)
  const endLine = lineNum
  const relevantLines = lines.slice(startLine, endLine + 1)
  const padding = lineNum.toString().length

  return relevantLines
    .map((line, i) => {
      const num = startLine + i + 1
      const paddedNum = num.toString().padStart(padding, " ")
      return `${paddedNum} | ${line}`
    })
    .join("\n")
}

export function printPositionWithOffset(position: SourcePosition) {
  return `line ${position.line}, column ${position.column}, offset ${position.offset}`
}
</file>

<file path="package.json">
{
  "name": "parserator",
  "version": "0.1.33",
  "description": "An elegant parser combinators library for Typescript",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "require": {
        "types": "./dist/index.d.cts",
        "default": "./dist/index.cjs"
      }
    }
  },
  "files": [
    "dist",
    "README.md"
  ],
  "scripts": {
    "build": "tsup && bun build.ts",
    "test": "bun test",
    "typecheck": "tsc --noEmit",
    "prepublishOnly": "bun run build && bun test",
    "publish:patch": "bun run build && npm version patch && npm publish --access public",
    "publish:minor": "bun run build && npm version minor && npm publish --access public",
    "publish:major": "bun run build && npm version major && npm publish --access public",
    "release:patch": "bun run build && bun test && bun run publish:patch",
    "release:minor": "bun run build && bun test && bun run publish:minor",
    "release:major": "bun run build && bun test && bun run publish:major",
    "format": "prettier --write ."
  },
  "keywords": [
    "parser",
    "parser-combinators",
    "typescript",
    "functional-programming"
  ],
  "author": "Sai (https://bsky.app/profile/texoport.in)",
  "license": "MIT",
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@types/bun": "^1.1.10",
    "prettier": "^3.5.3",
    "tsup": "^8.3.5",
    "typescript": "^5.0.0",
    "vitest": "^1.2.1"
  },
  "peerDependencies": {
    "typescript": "^5.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/saiashirwad/parserator.git"
  },
  "bugs": {
    "url": "https://github.com/saiashirwad/parserator/issues"
  },
  "homepage": "https://github.com/saiashirwad/parserator#readme",
  "prettier": {
    "printWidth": 80,
    "useTabs": false,
    "semi": false,
    "trailingComma": "none",
    "experimentalTernaries": true,
    "experimentalOperatorPosition": "end",
    "arrowParens": "avoid"
  }
}
</file>

<file path="README.md">
# Parserator

**Parserator** is a lightweight, generator-friendly parser-combinator toolkit for TypeScript/JavaScript. It pairs a minimal, monadic `Parser<T>` core with a rich set of ready-made combinators, debugging helpers, and human-friendly error reporting. If you are familiar with libraries such as Haskellâ€™s *megaparsec* or Rustâ€™s *nom*, think of Parserator as their ergonomic TypeScript cousin.

Key features

* âœ”ï¸ **Generator syntax** â€“ write top-down parsers that read like imperative code.
* âœ”ï¸ **Composable primitives** â€“ build larger grammars from tiny, reusable parts.
* âœ”ï¸ **Rich errors & hints** â€“ span-aware bundles, Levenshtein-based suggestions, and multi-format formatters (plain / ANSI / HTML / JSON).
* âœ”ï¸ **Batteries included** â€“ character, string, look-ahead, repetition, separators, whitespace-skipping, and more.
* âœ”ï¸ **Debugging tools** â€“ live trace, pretty state dumps, breakpoints, and benchmarks.

---

## API reference

> All symbols below are re-exported from the package root (`import { char } from "parserator"`). Types are omitted for brevity; see the generated declaration files for the full generics.

### 1. Chaining helper

| Function                    | Description                                                                                                         |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| **`chain(parser, ...fns)`** | Thread the result of `parser` through a pipeline of parsers returned by `fns`, short-circuiting on the first error  |


---

### 2. Primitive character & string parsers  (src/**combinators.ts**)

| Function                     | Matches                                    | Notes                                      |
| ---------------------------- | ------------------------------------------ | ------------------------------------------ |
| **`char(c)`**                | the literal character `c`                  | Yields the matched char.                   |
| **`string(s)`**              | the exact string `s`                       |                                            |
| **`narrowedString(regexp)`** | any string accepted by `regexp`            | Returns *typed* literal `s` (infer-safe).  |
| **`alphabet`**               | a single ASCII letter (`[a-zA-Z]`)         |                                            |
| **`digit`**                  | a single decimal digit (`[0-9]`)           |                                            |
| **`regex(re)`**              | the first match of regular expression `re` | Handy when no dedicated combinator exists. |
| **`anyChar`**                | any single character                       |                                            |

---

### 3. Combinators

| Function                          | Behaviour                                                        |
| --------------------------------- | ---------------------------------------------------------------- |
| **`or(...parsers)`**              | Try each parser left-to-right; succeed with the first match      |
| **`optional(p)`**                 | Succeed with `undefined` when `p` fails without consuming input  |
| **`sequence(...parsers)`**        | Run parsers in order, collect results in a tuple                 |
| **`between(left, right, inner)`** | Parse `left`, then `inner`, then `right`                         |
| **`sepBy(sep, value)`**           | Zero-or-more `value` separated by `sep`                          |
| **`lookAhead(p)`**                | Peek with `p` but do **not** consume input                       |
| **`skipSpaces`**                  | Skip ASCII spaces and tabs                                       |

#### Repetition helpers

| Function                                                     | Purpose                           |
| ------------------------------------------------------------ | --------------------------------- |
| **`many0(p)`**                                               | Zero or more `p` (array)          |
| **`many1(p)`**                                               | One or more `p`                   |
| **`manyN(n, p)`**                                            | *At least* `n` repetitions        |
| **`manyNExact(n, p)`**                                       | *Exactly* `n` repetitions         |
| **`skipMany0(p)`**, **`skipMany1(p)`**, **`skipManyN(n,p)`** | Same as above but discard results |

#### Slice / take helpers

| Function                 | Purpose                                                |
| ------------------------ | ------------------------------------------------------ |
| **`takeUntil(stop)`**    | Consume text until `stop` succeeds                     |
| **`takeUpto(stop)`**     | Same as `takeUntil` but leaves the delimiter untouched |
| **`parseUntilChar(ch)`** | Alias for `takeUntil(char(ch))`                        |

---

### 4. Generator wrapper

| Function                  | Description                                                                                  |
| ------------------------- | -------------------------------------------------------------------------------------------- |
| **`parser(generatorFn)`** | Lift a generator into a `Parser`, giving you `yield*` syntax with automatic state threading. |

---

### 5. Hint & typo support  (src/**hints.ts**)

| Function                             | Use                                                      |
| ------------------------------------ | -------------------------------------------------------- |
| **`levenshteinDistance(a,b)`**       | Raw edit distance                                        |
| **`generateHints(found, expected)`** | Pick closest `expected` strings to `found` (â‰¤2 edits)    |
| **`keywordWithHints(list)(kw)`**     | Parse keyword `kw`, suggest nearest alternatives on typo |
| **`anyKeywordWithHints(list)`**      | Accept *any* keyword from `list` with hints              |
| **`stringWithHints(list)`**          | Parse a quoted string belonging to `list` with hints     |

---

### 6. Error handling utilities

| Function                         | Purpose                                        |
| -------------------------------- | ---------------------------------------------- |
| **`createSpan(state, length?)`** | Derive a `Span` from parser state              |
| **`legacyError(bundle)`**        | Adapt new rich errors to legacy `ParserError`  |

**Error formatter**

`new ErrorFormatter(fmt = "plain", opts)` â†’ `string`

Multi-format rendering of a `ParseErrorBundle` (`plain`, `ansi`, `html`, `json`) with convenience helpers `formatError.plain/ansi/html/json` .

---

### 7. Debug helpers  (src/**debug.ts**)

| Function                                      | Description                                      |
| --------------------------------------------- | ------------------------------------------------ |
| **`debugState(label, state, result, opts?)`** | Pretty-print a single step                       |
| **`debug(parser, label)`**                    | Tap a parser and dump state on every invocation  |
| **`trace(label)`**                            | Log current state without consuming input        |
| **`breakpoint(parser, label)`**               | Like `debug`, then drops into `debugger`         |
| **`benchmark(parser, label)`**                | Time a parser run                                |

---

### 8. Low-level error-print helpers  (src/**errors.ts**)

| Function                                                                                                         |
| ---------------------------------------------------------------------------------------------------------------- |
| `printPosition`, `printArrow`, `printErrorContext`, `printErrorLine`, `printPositionWithOffset`, `getErrorLine`  |


---

### 9. Peek utilities  (src/**utils.ts**)

| Function        | What it returns                      |
| --------------- | ------------------------------------ |
| `peekState`     | The current `ParserState` unchanged  |
| `peekRemaining` | The remaining input string           |
| `peekAhead(n)`  | The next *n* characters              |
| `peekLine`      | Rest of the current line             |
| `peekUntil(ch)` | Slice until (but not including) `ch` |
</file>

<file path="tests/combinators.test.ts">
import { describe, expect, test } from "bun:test"
import {
  alphabet,
  between,
  char,
  digit,
  lookAhead,
  many0,
  many1,
  manyN,
  manyNExact,
  optional,
  or,
  regex,
  sepBy,
  sequence,
  skipSpaces,
  takeUntil
} from "../src/combinators"
import { Either } from "../src/either"
import { Parser } from "../src/parser"
import type { ParseErrorBundle } from "../src/rich-errors"

// Helper to get error message from ParseErrorBundle
function getErrorMessage(bundle: ParseErrorBundle): string {
	const primary = bundle.primary
	if (primary.tag === "Custom") {
		return primary.message
	} else if (primary.tag === "Unexpected") {
		return `Unexpected: ${primary.found}`
	} else {
		return `Expected: ${primary.items.join(", ")}`
	}
}

const stringParser = skipSpaces
  .then(char('"'))
  .then(many1(or(alphabet, digit)))
  .thenDiscard(char('"'))
  .map(s => s.join(""))

const integerParser = skipSpaces
  .then(many1(digit))
  .map(s => parseInt(s.join("")))
  .withError(() => "Expected an integer")

test("sepBy string array", () => {
  const p = char("[")
    .then(sepBy(char(","), or(stringParser, integerParser)))
    .thenDiscard(char("]"))
  expect(p.parseOrThrow('["hello", 2, "foo"]')).toEqual(["hello", 2, "foo"])
})

test("optional", () => {
  const p = optional(or(stringParser, integerParser))
  expect(p.parseOrThrow('"hello"')).toEqual("hello")
  expect(p.parseOrThrow("123")).toEqual(123)
})

test("sequence", () => {
  const p = sequence([
    stringParser,
    skipSpaces,
    char(","),
    skipSpaces,
    integerParser,
    skipSpaces,
    char(","),
    skipSpaces,
    integerParser
  ])
  expect(p.parseOrThrow('"hello", 123, 23')).toEqual(23)
})

describe("regex", () => {
  test("should match at the start of the input", () => {
    const p = regex(/foo/)
    expect(p.parseOrThrow("foo")).toEqual("foo")
  })

  test("should not match at the start of the input", () => {
    const p = regex(/foo/)
    expect(Either.isLeft(p.parse("bar").result)).toEqual(true)
  })

  test("should match at the start of the input with global flag", () => {
    const p = regex(/foo/g)
    expect(p.parseOrThrow("foo")).toEqual("foo")
  })
})

describe("basic combinators", () => {
  test("char", () => {
    const p = char("a")
    expect(p.parseOrThrow("a")).toBe("a")
    expect(Either.isLeft(p.parse("b").result)).toBe(true)
    expect(Either.isLeft(p.parse("").result)).toBe(true)
  })

  test("digit", () => {
    expect(digit.parseOrThrow("1")).toBe("1")
    expect(digit.parseOrThrow("9")).toBe("9")
    expect(Either.isLeft(digit.parse("a").result)).toBe(true)
    expect(Either.isLeft(digit.parse("").result)).toBe(true)
  })

  test("alphabet", () => {
    expect(alphabet.parseOrThrow("a")).toBe("a")
    expect(alphabet.parseOrThrow("Z")).toBe("Z")
    expect(Either.isLeft(alphabet.parse("1").result)).toBe(true)
    expect(Either.isLeft(alphabet.parse("").result)).toBe(true)
  })
})

describe("many combinators", () => {
  test("many1 requires at least one match", () => {
    const digits = many1(digit)
    expect(digits.parseOrThrow("123")).toEqual(["1", "2", "3"])
    expect(digits.parseOrThrow("1")).toEqual(["1"])
    expect(Either.isLeft(digits.parse("").result)).toBe(true)
    expect(Either.isLeft(digits.parse("abc").result)).toBe(true)
  })

  test("manyNExact requires exactly n matches", () => {
    const threeDigits = manyNExact(digit, 3)
    const t1 = threeDigits.parseOrError("123")
    expect(t1).toEqual(["1", "2", "3"])
    expect(Either.isLeft(threeDigits.parse("12").result)).toBe(true)
    const t2 = threeDigits.parse("1234")
    expect(Either.isLeft(t2.result)).toBe(true)
    expect(Either.isLeft(threeDigits.parse("").result)).toBe(true)
  })

  test("manyN with separator", () => {
    const threeDigitsComma = manyN(digit, 3, char(",")).thenDiscard(
      lookAhead(or(char("\n"), Parser.pure(undefined)))
    )
    expect(threeDigitsComma.parseOrThrow("1,2,3")).toEqual(["1", "2", "3"])
    expect(Either.isLeft(threeDigitsComma.parse("1,2").result)).toBe(true)
  })
})

describe("complex combinations", () => {
  test("nested array of numbers", () => {
    type Value = number | Value[]
    const value = Parser.lazy(() => or(number, array))
    const number = many1(digit).map(s => parseInt(s.join("")))
    const array: Parser<Value[]> = char("[")
      .then(sepBy(char(","), value))
      .thenDiscard(char("]"))

    expect(value.parseOrError("[1,2,[3,4],5]")).toEqual([1, 2, [3, 4], 5])
    expect(Either.isLeft(value.parse("[1,2,[3,4],]").result)).toBe(true)
  })

  test("simple expression parser", () => {
    type Expr = number
    const expr: Parser<Expr> = Parser.lazy(() => or(number, parens))
    const number = many1(digit).map(s => parseInt(s.join("")))
    const parens: Parser<number> = char("(")
      .then(expr)
      .thenDiscard(char(")"))
      .map((n: number) => n * 2)
    expect(expr.parseOrThrow("123")).toBe(123)
    expect(expr.parseOrThrow("(123)")).toBe(246)
    expect(expr.parseOrThrow("((123))")).toBe(492)
    expect(Either.isLeft(expr.parse("(123").result)).toBe(true)
  })

  test("key-value parser", () => {
    const key = many1(alphabet).map(s => s.join(""))
    const value = many1(digit).map(s => parseInt(s.join("")))
    const pair = key
      .thenDiscard(char(":"))
      .flatMap(k => value.map(v => [k, v] as const))
    const object = char("{")
      .then(sepBy(char(","), pair))
      .thenDiscard(char("}"))
      .map(Object.fromEntries)
    expect(object.parseOrThrow("{foo:123,bar:456}")).toEqual({
      foo: 123,
      bar: 456
    })
    expect(Either.isLeft(object.parse("{foo:123,}").result)).toBe(true)
  })
})

describe("error handling", () => {
  test("custom error messages", () => {
    const p = digit.withError(
      ({ state }) => `Expected a digit at position ${state.pos.offset}`
    )
    const { result } = p.parse("a")
    expect(Either.isLeft(result)).toBe(true)
  })

  test("error callback", () => {
    const p = digit.withError(
      ({ state }) => `Expected a digit at position ${state.pos.offset}`
    )
    const { result } = p.parse("a")
    expect(Either.isLeft(result)).toBe(true)
  })
})

describe("parser composition", () => {
  test("map transformation", () => {
    const p = digit.map(Number)
    expect(p.parseOrThrow("5")).toBe(5)
  })

  test("flatMap chaining", () => {
    const p = digit.flatMap(d => digit.map(d2 => Number(d + d2)))
    expect(p.parseOrThrow("12")).toBe(12)
  })

  test("then sequencing", () => {
    const p = char("[").then(digit).thenDiscard(char("]"))
    expect(p.parseOrThrow("[5]")).toBe("5")
  })
})

describe("advanced combinators", () => {
  test("lookAhead without consuming", () => {
    const p = lookAhead(char("a")).then(char("a"))
    expect(p.parseOrThrow("a")).toBe("a")
    expect(Either.isLeft(p.parse("b").result)).toBe(true)
  })

  test("sequence with type inference", () => {
    const p = sequence([digit.map(Number), char("+"), digit.map(Number)])
    expect(p.parseOrThrow("1+2")).toBe(2) // returns last value
  })

  test("sepBy with empty input", () => {
    const p = sepBy(char(","), digit)
    // expect(p.parseOrThrow("")).toEqual([])
    // expect(p.parseOrThrow("1")).toEqual(["1"])
    // expect(p.parseOrThrow("1,2,3")).toEqual(["1", "2", "3"])
  })

  test("optional with chaining", () => {
    const p = optional(char("-")).flatMap(sign =>
      many1(digit).map(digits => ({
        sign: sign === "-" ? -1 : 1,
        value: Number(digits.join(""))
      }))
    )

    expect(p.parseOrThrow("123")).toEqual({
      sign: 1,
      value: 123
    })
    expect(p.parseOrThrow("-123")).toEqual({
      sign: -1,
      value: 123
    })
  })
})

describe("error recovery", () => {
  test("custom error with context", () => {
    const identifier = regex(/[a-z]+/).withError(
      () => "Expected lowercase identifier"
    )
    const number = regex(/[0-9]+/).withError(() => "Expected number")
    const assignment = identifier
      .thenDiscard(char("=").thenDiscard(skipSpaces))
      .then(number)
      .withError(({ error }) => getErrorMessage(error))

    const { result } = assignment.parse("foo = bar")
    expect(Either.isLeft(result)).toBe(true)
  })

  test("error position tracking", () => {
    const p = many1(digit).thenDiscard(char(";"))
    const { result, state } = p.parse("123x")
    expect(Either.isLeft(result)).toBe(true)
  })
})

describe("between", () => {
  test("between parser", () => {
    const p = between(char("("), char(")"), many1(digit))
    expect(p.parseOrThrow("(123)")).toEqual(["1", "2", "3"])
  })

  test("between with nested parsers", () => {
    const strParser = char('"')
      .then(many1(or(alphabet, digit)))
      .thenDiscard(char('"'))
      .map(s => s.join(""))
    const p = between(
      char("["),
      char("]"),
      sepBy(
        many0(char(" "))
          .then(char(","))
          .then(many0(char(" "))),
        strParser
      )
    )
    const result = p.parseOrThrow('["hello", "world"]')
    expect(result).toEqual(["hello", "world"])
  })
})

describe("takeUntil", () => {
  test("takeUntil 1", () => {
    const p = takeUntil(char("a"))
    expect(p.parseOrThrow("123142abc")).toBe("123142")
  })

  test("takeUntil 2", () => {
    const strParser = char('"')
      .then(many1(or(alphabet, digit)))
      .thenDiscard(char('"'))
      .map(s => s.join(""))
    const p = takeUntil(strParser)
    expect(p.parseOrThrow('this is a "hello"')).toBe("this is a ")
  })
})
</file>

<file path="src/debug.ts">
import { Either } from "./either"
import { Parser } from "./parser"
import { type ParserOutput, type ParserState, State } from "./state"
/**
 * Creates a debug output for a parser's current state and result
 */
export function debugState<Ctx = {}>(
  label: string,
  state: ParserState<Ctx>,
  result: ParserOutput<any, Ctx>,
  options: {
    inputPreviewLength?: number
    separator?: string
  } = {}
) {
  const { inputPreviewLength = 20, separator = "=".repeat(40) } = options

  console.log(`\n=== ${label} ===`)
  console.log("Position:", State.printPosition(state))
  console.log(
    "Input:",
    JSON.stringify(
      state.remaining.slice(0, inputPreviewLength) +
        (state.remaining.length > inputPreviewLength ? "..." : "")
    )
  )
  console.log(
    "Result:",
    Either.isRight(result.result) ?
      `Success: ${JSON.stringify(result.result.right.value)}`
    : `Error: ${result.result.left.primary.tag === "Custom" ? 
        result.result.left.primary.message : 
        `${result.result.left.primary.tag}: ${JSON.stringify(result.result.left.primary)}`}`
  )
  console.log(separator)
}

/**
 * Adds debug output to a parser
 */
export function debug<T, Ctx = {}>(
  parser: Parser<T, Ctx>,
  label: string
): Parser<T, Ctx> {
  return parser.tap(({ state, result }) => debugState(label, state, result))
}

/**
 * Creates a parser that logs its input state and continues
 */
export function trace<Ctx = {}>(label: string): Parser<void, Ctx> {
  return new Parser(state => {
    console.log(`\n[TRACE] ${label}`)
    console.log("Position:", State.printPosition(state))
    console.log("Remaining:", JSON.stringify(state.remaining))
    return Parser.succeed(undefined, state)
  })
}

/**
 * Adds breakpoints to a parser for step-by-step debugging
 */
export function breakpoint<T, Ctx = {}>(
  parser: Parser<T, Ctx>,
  label: string
): Parser<T, Ctx> {
  return parser.tap(({ state, result }) => {
    debugState(label, state, result)
    // eslint-disable-next-line no-debugger
    debugger
  })
}

/**
 * Times how long a parser takes to run
 */
export function benchmark<T, Ctx = {}>(
  parser: Parser<T, Ctx>,
  label: string
): Parser<T, Ctx> {
  return new Parser(state => {
    const start = performance.now()
    const result = parser.run(state)
    const end = performance.now()
    console.log(`\n[BENCHMARK] ${label}: ${(end - start).toFixed(2)}ms`)
    return result
  })
}
</file>

<file path="src/state.ts">
import type { Either } from "./either"
import type { Prettify } from "./types"
import type { ParseErrorBundle } from "./rich-errors"

export type ParserContext<Ctx = {}> = Prettify<
  Ctx & {
    debug?: boolean
    source: string
    labelStack?: string[]
  }
>

export type ParserOptions = { name?: string }

export class ParserError {
  constructor(
    public message: string,
    public expected: string[],
    public found?: string
  ) {}
}

export type ParserOutput<T, Ctx = {}> = {
  state: ParserState<Ctx>
  result: Either<T, ParseErrorBundle>
}

export type SourcePosition = {
  line: number
  column: number
  offset: number
}

export type ParserState<Ctx = {}> = {
  remaining: string
  pos: SourcePosition
  context: ParserContext<Ctx>
}

/**
 * Utility object containing static methods for creating and manipulating parser state.
 */
export const State = {
  /**
   * Creates a new parser state from an input string.
   *
   * @param input - The input string to parse
   * @returns A new parser state initialized at the start of the input
   */
  fromInput<Ctx = {}>(
    input: string,
    context: ParserContext<Ctx>
  ): ParserState<Ctx> {
    return {
      remaining: input,
      pos: { line: 1, column: 1, offset: 0 },
      context
    }
  },

  /**
   * Creates a new state by consuming n characters from the current state.
   *
   * @param state - The current parser state
   * @param n - Number of characters to consume
   * @returns A new state with n characters consumed and position updated
   * @throws Error if attempting to consume more characters than remaining
   */
  consume<Ctx = {}>(state: ParserState<Ctx>, n: number): ParserState<Ctx> {
    if (n === 0) return state
    if (n > state.remaining.length) {
      throw new Error("Cannot consume more characters than remaining")
    }

    const consumed = state.remaining.slice(0, n)
    let { line, column, offset } = state.pos

    for (const char of consumed) {
      if (char === "\n") {
        line++
        column = 1
      } else {
        column++
      }
      offset++
    }

    return {
      remaining: state.remaining.slice(n),
      pos: { line, column, offset },
      context: state.context
    }
  },

  /**
   * Creates a new state by consuming a specific string from the current state.
   *
   * @param state - The current parser state
   * @param str - The string to consume
   * @returns A new state with the string consumed and position updated
   * @throws Error if the input doesn't start with the specified string
   */
  consumeString<Ctx = {}>(
    state: ParserState<Ctx>,
    str: string
  ): ParserState<Ctx> {
    if (!state.remaining.startsWith(str)) {
      throw new Error(
        `Cannot consume "${str}" - input "${state.remaining}" doesn't start with it`
      )
    }
    return State.consume(state, str.length)
  },

  move<Ctx = {}>(state: ParserState<Ctx>, moveBy: number) {
    return State.consume(
      {
        ...state,
        remaining: state.context.source,
        pos: { line: 1, column: 1, offset: 0 }
      },
      state.pos.offset + moveBy
    )
  },

  /**
   * Creates a new state by consuming characters while a predicate is true.
   *
   * @param state - The current parser state
   * @param predicate - Function that tests each character
   * @returns A new state with matching characters consumed
   */
  consumeWhile<Ctx = {}>(
    state: ParserState<Ctx>,
    predicate: (char: string) => boolean
  ): ParserState<Ctx> {
    let i = 0
    while (i < state.remaining.length && predicate(state.remaining[i])) {
      i++
    }
    return State.consume(state, i)
  },

  /**
   * Gets the next n characters from the input without consuming them.
   *
   * @param state - The current parser state
   * @param n - Number of characters to peek (default: 1)
   * @returns The next n characters as a string
   */
  peek<Ctx = {}>(state: ParserState<Ctx>, n: number = 1): string {
    return state.remaining.slice(0, n)
  },

  /**
   * Checks if the parser has reached the end of input.
   *
   * @param state - The current parser state
   * @returns True if at end of input, false otherwise
   */
  isAtEnd<Ctx = {}>(state: ParserState<Ctx>): boolean {
    return state.remaining.length === 0
  },

  printPosition<Ctx = {}>(state: ParserState<Ctx>): string {
    return `line ${state.pos.line}, column ${state.pos.column}, offset ${state.pos.offset}`
  }
}
</file>

<file path="examples/scheme/parser.ts">
import {
  char,
  digit,
  many0,
  many1,
  optional,
  or,
  Parser,
  parser,
  skipMany0,
  string,
  takeUpto
} from "../../src"
import { peekAhead } from "../../src/utils"
import { LispExpr } from "./ast"

const whitespace = skipMany0(or(char(" "), char("\n"), char("\t")))
const optionalWhitespace = optional(whitespace)

export let expr: Parser<LispExpr.LispExpr>

const symbol = parser(function* () {
  const name = yield* takeUpto(
    or(char(" "), char("\n"), char("\t"), char(")"), char("("))
  )
  if (name === "") return yield* Parser.error("Empty symbol")
  return LispExpr.symbol(name)
})

const number = parser(function* () {
  const sign = (yield* optional(char("-"))) ?? ""
  const digits = yield* many1(digit)
  const value = parseInt(sign + digits.join(""))
  return LispExpr.number(value)
})

const stringLiteral = parser(function* () {
  yield* char('"')
  const value = yield* takeUpto(char('"'))
  yield* char('"')
  return LispExpr.string(value)
})

const boolean = parser(function* () {
  const val = yield* or(string("#t"), string("#f"))
  return LispExpr.bool(val === "#t")
})

const atom = or(boolean, number, stringLiteral, symbol)

const list = parser(function* () {
  yield* char("(")
  yield* optionalWhitespace

  const items = yield* many0(
    parser(function* () {
      yield* optionalWhitespace
      const item = yield* expr
      yield* optionalWhitespace
      return item
    })
  )

  if (items.length === 0) {
    return yield* Parser.error("Empty list not allowed")
  }

  yield* char(")").withError(() => "Missing closing parenthesis ')'")
  return items
})

const listParser = list.flatMap(list =>
  parser(function* () {
    if (list.length === 3) {
      const [first, paramsExpr, bodyExpr] = list
      if (first.type === "Symbol" && paramsExpr.type === "List") {
        if (first.name === "lambda") {
          return yield* lambdaParser(paramsExpr, bodyExpr)
        }
        if (first.name === "let") {
          return yield* letParser(paramsExpr, bodyExpr)
        }
      }
    }
    return LispExpr.list(list)
  })
)

const lambdaParser = (paramsExpr: LispExpr.List, bodyExpr: LispExpr.LispExpr) =>
  parser(function* () {
    const params: string[] = []
    for (const item of paramsExpr.items) {
      if (item.type !== "Symbol") {
        return yield* Parser.error(
          "Invalid param definition for lambda expression"
        )
      }
      params.push(item.name)
    }

    return LispExpr.lambda(params, bodyExpr)
  })

const letParser = (bindingsExpr: LispExpr.List, bodyExpr: LispExpr.LispExpr) =>
  parser(function* () {
    const bindings: LispExpr.Let["bindings"] = []
    for (const item of bindingsExpr.items) {
      if (!(item.type === "List" && item.items.length === 2)) {
        return yield* Parser.error("Invalid let expression")
      }
      const [keyExpr, valExpr] = item.items
      if (keyExpr.type !== "Symbol") {
        return yield* Parser.error("Invalid let expression")
      }

      bindings.push({
        name: keyExpr.name,
        value: valExpr
      })
    }

    return LispExpr.let(bindings, bodyExpr)
  })

expr = Parser.lazy(() =>
  parser(function* () {
    yield* optionalWhitespace
    const isList = yield* peekAhead(1).map(x => x === "(")
    const result = yield* isList ? listParser : atom
    yield* optionalWhitespace
    return result
  })
)

export const lispParser = expr
</file>

<file path="src/parser.ts">
import { debug } from "./debug"
import { Either } from "./either"
import { type ParseErr, ParseErrorBundle, createSpan } from "./rich-errors"
import {
  type ParserContext,
  type ParserOptions,
  type ParserOutput,
  type ParserState,
  State
} from "./state"
import type { Prettify } from "./types"

type BindResult<T, K extends string, B> = Prettify<
  T & {
    [k in K]: B
  }
>

export class Parser<T, Ctx = {}> {
  constructor(
    /**
     * @internal
     */
    public run: (state: ParserState<Ctx>) => ParserOutput<T, Ctx>,
    public options?: ParserOptions
  ) {}

  name(name: string) {
    this.options = { ...this.options, name }
    return this
  }

  static succeed<T, Ctx = {}>(
    value: T,
    state: ParserState<Ctx>
  ): ParserOutput<T, Ctx> {
    return {
      state,
      result: Either.right(value)
    }
  }

  static fail<Ctx = {}>(
    error: {
      message: string
      expected?: string[]
      found?: string
    },
    state: ParserState<Ctx>
  ): ParserOutput<never, Ctx> {
    const span = createSpan({
      pos: {
        offset: state.pos.offset,
        line: state.pos.line,
        column: state.pos.column
      }
    })

    const parseErr: ParseErr = {
      tag: "Custom",
      span,
      message: error.message,
      context: state.context?.labelStack ?? [],
      hints: []
    }

    const bundle = new ParseErrorBundle([parseErr], state.context?.source ?? state.remaining)

    return {
      state,
      result: Either.left(bundle)
    }
  }

  static error<Ctx = {}>(
    message: string,
    expected: string[] = [],
    stateCallback?: (state: ParserState<Ctx>) => ParserState<Ctx>
  ): Parser<never, Ctx> {
    return new Parser(state => {
      return Parser.fail(
        { message, expected },
        stateCallback ? stateCallback(state) : state
      )
    })
  }

  /**
   * Adds an error message to the parser
   * @param makeMessage - A function that returns an error message
   * @returns A new parser with the error message added
   */
  withError(
    makeMessage: (errorCtx: {
      error: ParseErrorBundle
      state: ParserState<Ctx>
    }) => string
  ): Parser<T, Ctx> {
    return new Parser<T, Ctx>(state => {
      const output = this.run(state)
      if (Either.isLeft(output.result)) {
        return Parser.fail(
          {
            message: makeMessage({
              error: output.result.left,
              state: output.state
            })
          },
          output.state
        )
      }
      return output
    }, this.options)
  }

  parse(
    input: string,
    context = { source: input } as ParserContext<Ctx>
  ): ParserOutput<T, Ctx> {
    const { result, state } = this.run(State.fromInput(input, context))
    return { result, state }
  }

  withTrace(label: string): Parser<T, Ctx> {
    return new Parser<T, Ctx>(state => {
      if (!state.context?.debug) {
        return this.run(state)
      }
      return debug(this, label).run(state)
    }, this.options)
  }

  parseOrError(
    input: string,
    context = { source: input } as ParserContext<Ctx>
  ) {
    const { result } = this.run(State.fromInput(input, context))
    if (Either.isRight(result)) {
      return result.right
    }
    return result.left
  }

  parseOrThrow(
    input: string,
    context = { source: input } as ParserContext<Ctx>
  ): T {
    const { result } = this.parse(
      input,
      context ?? {
        source: input
      }
    )

    if (Either.isLeft(result)) {
      throw result.left
    }
    return result.right
  }

  map<B>(f: (a: T) => B): Parser<B, Ctx> {
    return new Parser<B, Ctx>(state => {
      const { result, state: newState } = this.run(state)
      if (Either.isLeft(result)) {
        return { state, result: result as unknown as Either<B, ParseErrorBundle> }
      }
      return Parser.succeed(f(result.right), newState)
    })
  }

  flatMap<B>(f: (a: T) => Parser<B, Ctx>): Parser<B, Ctx> {
    return new Parser<B, Ctx>(state => {
      const { result, state: newState } = this.run(state)
      if (Either.isLeft(result)) {
        return { state: newState, result: result as unknown as Either<B, ParseErrorBundle> }
      }
      const nextParser = f(result.right)
      return nextParser.run(newState)
    })
  }

  static pure = <A>(a: A): Parser<A> =>
    new Parser(state => Parser.succeed(a, state))

  static Do = Parser.pure({})

  /**
   * Creates a new parser that lazily evaluates the given function.
   * This is useful for creating recursive parsers.
   *
   * @param fn - A function that returns a parser
   * @returns A new parser that evaluates the function when parsing
   * @template T The type of value produced by the parser
   *
   * @example
   * ```ts
   * // Create a recursive parser for nested parentheses
   * const parens: Parser<string> = Parser.lazy(() =>
   *   between(
   *     char('('),
   *     char(')'),
   *     parens
   *   )
   * )
   * ```
   */
  static lazy<T>(fn: () => Parser<T>): Parser<T> {
    return new Parser(state => {
      const parser = fn()
      return parser.run(state)
    })
  }

  zip<B>(parserB: Parser<B, Ctx>): Parser<[T, B], Ctx> {
    return new Parser(state => {
      const { result: a, state: stateA } = this.run(state)
      if (Either.isLeft(a)) {
        return { result: a as unknown as Either<[T, B], ParseErrorBundle>, state: stateA }
      }
      const { result: b, state: stateB } = parserB.run(stateA)
      if (Either.isLeft(b)) {
        return { result: b as unknown as Either<[T, B], ParseErrorBundle>, state: stateB }
      }
      return Parser.succeed([a.right, b.right], stateB)
    })
  }

  then<B>(parserB: Parser<B, Ctx>): Parser<B, Ctx> {
    return this.zip(parserB).map(([_, b]) => b)
  }

  zipRight = this.then

  thenDiscard<B>(parserB: Parser<B, Ctx>): Parser<T, Ctx> {
    return this.zip(parserB).map(([a, _]) => a)
  }

  zipLeft = this.thenDiscard

  bind<K extends string, B>(
    k: K,
    other: Parser<B, Ctx> | ((a: T) => Parser<B, Ctx>)
  ): Parser<BindResult<T, K, B>, Ctx> {
    return new Parser<BindResult<T, K, B>, Ctx>(state => {
      const { result: resultA, state: stateA } = this.run(state)
      if (Either.isLeft(resultA)) {
        return { result: resultA as unknown as Either<BindResult<T, K, B>, ParseErrorBundle>, state: stateA }
      }
      const nextParser = other instanceof Parser ? other : other(resultA.right)
      const { result: resultB, state: stateB } = nextParser.run(stateA)
      if (Either.isLeft(resultB)) {
        return { result: resultB as unknown as Either<BindResult<T, K, B>, ParseErrorBundle>, state: stateB }
      }
      return Parser.succeed(
        { ...resultA.right, [k]: resultB.right } as BindResult<T, K, B>,
        stateB
      )
    }, this.options)
  }

  *[Symbol.iterator](): Generator<Parser<T, Ctx>, T, any> {
    return yield this
  }

  /**
   * Adds a tap point to observe the current state and result during parsing.
   * Useful for debugging parser behavior.
   *
   * @param callback - Function called with current state and result
   * @returns The same parser with the tap point added
   */
  tap(
    callback: (args: {
      state: ParserState<Ctx>
      result: ParserOutput<T, Ctx>
    }) => void
  ): Parser<T, Ctx> {
    return new Parser(state => {
      const result = this.run(state)
      callback({ state, result })
      return result
    }, this.options)
  }

  static gen<T, Ctx = unknown>(
    f: () => Generator<Parser<any, Ctx>, T, any>
  ): Parser<T, Ctx> {
    return new Parser<T, Ctx>(state => {
      const iterator = f()
      let current = iterator.next()
      let currentState: ParserState<Ctx> = state
      while (!current.done) {
        const { result, state: updatedState } = current.value.run(currentState)
        if (Either.isLeft(result)) {
          return { result: result as unknown as Either<T, ParseErrorBundle>, state: updatedState }
        }
        currentState = updatedState
        current = iterator.next(result.right)
      }
      return Parser.succeed(current.value, currentState)
    })
  }

  trim(parser: Parser<any, Ctx>) {
    return parser.then(this).thenDiscard(parser)
  }

  trimLeft(parser: Parser<any, Ctx>): Parser<T, Ctx> {
    return parser.then(this)
  }

  trimRight(parser: Parser<any, Ctx>): Parser<T, Ctx> {
    return this.thenDiscard(parser)
  }

  /**
   * Adds a label to this parser for better error messages
   * @param name - The label name to add to the context stack
   * @returns A new parser with the label added
   */
  label(name: string): Parser<T, Ctx> {
    return new Parser((state) => {
      const newState = {
        ...state,
        context: {
          ...state.context,
          labelStack: [name, ...(state.context.labelStack || [])],
        },
      }

      const result = this.run(newState)

      if (Either.isLeft(result.result)) {
        // Convert generic errors to labeled expectations
        const labeledError: ParseErr = {
          tag: "Expected",
          span: createSpan(state),
          items: [name],
          context: newState.context.labelStack || [],
        }

        return Parser.failRich({ errors: [labeledError] }, result.state)
      }

      return result
    }, this.options)
  }

  /**
   * Helper for creating semantic expectations with both label and error message
   * @param description - The description for both the label and error message
   * @returns A new parser with both labeling and error message
   */
  expect(description: string): Parser<T, Ctx> {
    return this.withError(() => `Expected ${description}`).label(description)
  }

  static failRich<Ctx = {}>(
    errorBundle: { errors: ParseErr[] },
    state: ParserState<Ctx>
  ): ParserOutput<never, Ctx> {
    const bundle = new ParseErrorBundle(
      errorBundle.errors,
      state.context?.source ?? state.remaining
    )

    return {
      state,
      result: Either.left(bundle)
    }
  }
}

export function parser<T, Ctx = unknown>(
  f: () => Generator<Parser<any, Ctx>, T, any>
): Parser<T, Ctx> {
  return new Parser<T, Ctx>(state => {
    const iterator = f()
    let current = iterator.next()
    let currentState: ParserState<Ctx> = state
    while (!current.done) {
      const { result, state: updatedState } = current.value.run(currentState)
      if (Either.isLeft(result)) {
        return { result: result as unknown as Either<T, ParseErrorBundle>, state: updatedState }
      }
      currentState = updatedState
      current = iterator.next(result.right)
    }
    return Parser.succeed(current.value, currentState)
  })
}
</file>

<file path="src/combinators.ts">
import { Either } from "./either"
import { Parser } from "./parser"
import type { ParseErrorBundle } from "./rich-errors"
import { type ParserState, State } from "./state"

/**
 * Creates a parser that looks ahead in the input stream without consuming any input.
 * The parser will succeed with the result of the given parser but won't advance the input position.
 *
 * @param parser - The parser to look ahead with
 * @returns A new parser that peeks at the input without consuming it
 * ```ts
 * const parser = lookAhead(char('a'))
 * parser.run('abc') // Right(['a', {...}])
 * // Input position remains at 'abc', 'a' is not consumed
 * ```
 */
export function lookAhead<T, Ctx = {}>(
  parser: Parser<T, Ctx>
): Parser<T | undefined, Ctx> {
  return new Parser(state => {
    const { result } = parser.run(state)
    if (Either.isRight(result)) {
      return Parser.succeed(result.right, state)
    }
    return Parser.succeed(undefined, state)
  })
}

/**
 * Creates a parser that succeeds only if the given parser fails to match.
 * If the parser succeeds, this parser fails with an error message.
 *
 * @param parser - The parser that should not match
 * @returns A new parser that succeeds only if the input parser fails
 * ```ts
 * const notA = notFollowedBy(char('a'))
 * notA.run('bcd') // Right([true, {...}]) - Succeeds because 'a' is not found
 * notA.run('abc') // Left(error) - Fails because 'a' is found
 * ```
 */
export function notFollowedBy<T, Ctx = {}>(
  parser: Parser<T, Ctx>
): Parser<boolean, Ctx> {
  return new Parser(state => {
    const { result, state: newState } = parser.run(state)
    if (Either.isRight(result)) {
      if (parser.options?.name) {
        const message = `Found ${parser.options.name} when it should not appear here`
        return Parser.fail({ message, expected: [] }, newState)
      }
      return Parser.fail(
        {
          message: "Expected not to follow",
          expected: [],
          found: state.remaining.at(0)
        },
        newState
      )
    }
    return Parser.succeed(true, state)
  })
}

/**
 * Creates a parser that matches an exact string in the input.
 *
 * @param str - The string to match
 * @returns A parser that matches and consumes the exact string
 * ```ts
 * const parser = string("hello")
 * parser.run("hello world") // Right(["hello", {...}])
 * parser.run("goodbye") // Left(error)
 * ```
 */
export const string = <Ctx = {}>(str: string): Parser<string, Ctx> =>
  new Parser(
    state => {
      if (state.remaining.startsWith(str)) {
        return Parser.succeed(str, State.consume(state, str.length))
      }

      const message =
        `Expected '${str}', ` +
        `but found '${state.remaining.slice(0, str.length)}'`

      return Parser.fail(
        {
          message,
          expected: [str],
          found: state.remaining.slice(0, str.length)
        },
        state
      )
    },
    { name: str }
  )

/**
 * Creates a parser that matches an exact string literal type.
 * Similar to string parser but preserves the literal type information.
 *
 * @param str - The string literal to match
 * @returns A parser that matches and consumes the exact string with preserved type
 * ```ts
 * const parser = narrowedString("hello") // Parser<"hello">
 * parser.run("hello world") // Right(["hello", {...}])
 * parser.run("goodbye") // Left(error)
 * ```
 */
export function narrowedString<const T extends string, Ctx>(
  str: T
): Parser<T, Ctx> {
  return string(str) as any
}

/**
 * Creates a parser that matches a single character.
 *
 * @param ch - The character to match
 * @returns A parser that matches and consumes a single character
 * ```ts
 * const parser = char("a")
 * parser.run("abc") // Right(["a", {...}])
 * parser.run("xyz") // Left(error)
 * ```
 */
export const char = <T extends string, Ctx = {}>(ch: T): Parser<T, Ctx> => {
  return new Parser(
    state => {
      if (ch.length !== 1) {
        return Parser.fail(
          { message: "Incorrect usage of char parser.", expected: [ch] },
          state
        )
      }
      if (state.remaining[0] === ch) {
        return Parser.succeed(ch, State.consume(state, 1))
      }

      const message = `Expected ${ch} but found ${state.remaining.at(0)}.`
      return Parser.fail(
        { message, expected: [ch], found: state.remaining.at(0) },
        state
      )
    },
    { name: ch }
  )
}

/**
 * A parser that matches any single alphabetic character (a-z, A-Z).
 *
 * ```ts
 * const parser = alphabet
 * parser.run("abc") // Right(["a", {...}])
 * parser.run("123") // Left(error)
 * ```
 */
export const alphabet = new Parser(
  state => {
    if (State.isAtEnd(state)) {
      return Parser.fail(
        { message: "Unexpected end of input", expected: [] },
        state
      )
    }
    const first = state.remaining[0]
    if (first && /^[a-zA-Z]$/.test(first)) {
      return Parser.succeed(first, State.consume(state, 1))
    }
    const message = `Expected alphabetic character, but got '${first}'`
    return Parser.fail(
      { message, expected: [], found: state.remaining[0] },
      state
    )
  },
  { name: "alphabet" }
)

/**
 * A parser that matches any single digit character (0-9).
 *
 * ```ts
 * const parser = digit
 * parser.run("123") // Right(["1", {...}])
 * parser.run("abc") // Left(error)
 * ```
 */
export const digit = new Parser(
  state => {
    if (State.isAtEnd(state)) {
      return Parser.fail(
        { message: "Unexpected end of input", expected: [] },
        state
      )
    }
    const first = state.remaining[0]
    if (first && /^[0-9]$/.test(first)) {
      return Parser.succeed(first, State.consume(state, 1))
    }
    const message = `Expected digit, but got '${first}'`
    return Parser.fail(
      { message, expected: [], found: state.remaining[0] },
      state
    )
  },
  { name: "digit" }
)

/**
 * Creates a parser that matches zero or more occurrences of elements separated by a separator.
 *
 * @param sepParser - Parser for the separator between elements
 * @param parser - Parser for the elements
 * @returns A parser that produces an array of matched elements
 *
 * ```ts
 * const parser = sepBy(char(','), digit)
 * parser.run("1,2,3") // Right([["1", "2", "3"], {...}])
 * parser.run("") // Right([[], {...}])
 * ```
 */
// TODO: fix this
export function sepBy<S, T, Ctx>(
  sepParser: Parser<S, Ctx>,
  parser: Parser<T, Ctx>
): Parser<T[], Ctx> {
  return new Parser(state => {
    const results: T[] = []
    let currentState = state

    const { result: firstResult, state: firstState } = parser.run(currentState)
    if (Either.isLeft(firstResult)) {
      return Parser.succeed([], state)
    }

    results.push(firstResult.right)
    currentState = firstState

    while (true) {
      const { result: sepResult, state: sepState } = sepParser.run(currentState)
      if (Either.isLeft(sepResult)) {
        break
      }
      currentState = sepState

      const { result: itemResult, state: itemResultState } =
        parser.run(currentState)
      if (Either.isLeft(itemResult)) {
        return { result: itemResult as unknown as Either<T[], ParseErrorBundle>, state: itemResultState }
      }
      results.push(itemResult.right)
      currentState = itemResultState
    }

    return Parser.succeed(results, currentState)
  })
}

/**
 * Creates a parser that matches content between two string delimiters.
 *
 * @param start - The opening delimiter string
 * @param end - The closing delimiter string
 * @param parser - The parser for the content between delimiters
 * @returns A parser that matches content between delimiters
 *
 * ```ts
 * const parser = between('(', ')', digit)
 * parser.run('(5)') // Right(['5', {...}])
 * parser.run('5') // Left(error)
 * ```
 */
export function between<T, Ctx = {}>(
  start: Parser<any, Ctx>,
  end: Parser<any, Ctx>,
  parser: Parser<T, Ctx>
): Parser<any, Ctx> {
  return new Parser(state => {
    // Parse opening delimiter
    const startResult = start.run(state)
    if (Either.isLeft(startResult.result)) {
      return startResult
    }

    // Parse content
    const contentResult = parser.run(startResult.state)
    if (Either.isLeft(contentResult.result)) {
      return contentResult
    }

    // Parse closing delimiter
    const endResult = end.run(contentResult.state)
    if (Either.isLeft(endResult.result)) {
      return endResult
    }

    // Return the content and final state
    return Parser.succeed(contentResult.result.right, endResult.state)
  })
}

export function anyChar<Ctx = {}>() {
  return new Parser<string, Ctx>(state => {
    if (State.isAtEnd(state)) {
      return Parser.fail(
        { message: "Unexpected end of input", expected: [] },
        state
      )
    }
    return Parser.succeed(state.remaining[0], State.consume(state, 1))
  })
}

/**
 * Internal helper function for creating repetition parsers.
 *
 * @param count - Minimum number of repetitions required
 * @returns A function that creates a parser matching multiple occurrences
 */
function many_<S, T, Ctx = {}>(count: number) {
  return (
    parser: Parser<T, Ctx>,
    separator?: Parser<S, Ctx>
  ): Parser<T[], Ctx> => {
    return new Parser(state => {
      const results: T[] = []
      let currentState = state

      while (true) {
        // Try to parse the next item
        const itemResult = parser.run(currentState)
        if (Either.isLeft(itemResult.result)) {
          // If we have enough items, return success
          if (results.length >= count) {
            return Parser.succeed(results, currentState)
          }
          const message = `Expected at least ${count} occurrences, but only found ${results.length}`
          return Parser.fail({ message, expected: [] }, itemResult.state)
        }

        // Add the item and update state
        const { result: value, state: newState } = itemResult
        results.push(value.right)
        
        // Check that parser advanced - prevent infinite loops
        if (newState.pos.offset <= currentState.pos.offset) {
          throw new Error("Parser did not advance - infinite loop prevented")
        }
        currentState = newState as ParserState<Ctx>

        // If we have a separator, try to parse it
        if (separator) {
          const { result: sepResult, state } = separator.run(currentState)
          if (Either.isLeft(sepResult)) {
            break
          }
          // Check that separator advanced too
          if (state.pos.offset <= currentState.pos.offset) {
            throw new Error("Separator parser did not advance - infinite loop prevented")
          }
          currentState = state as ParserState<Ctx>
        }
      }

      if (results.length >= count) {
        return Parser.succeed(results, currentState)
      }

      const message = `Expected at least ${count} occurrences, but only found ${results.length}`
      return Parser.fail({ message, expected: [] }, currentState)
    })
  }
}

/**
 * Creates a parser that matches zero or more occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @returns A parser that produces an array of all matches
 */
export const many0 = <S, T, Ctx = {}>(
  parser: Parser<T, Ctx>,
  separator?: Parser<S, Ctx>
) => many_<S, T, Ctx>(0)(parser, separator)

/**
 * Creates a parser that matches one or more occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @returns A parser that produces an array of all matches (at least one)
 */
export const many1 = <S, T, Ctx>(
  parser: Parser<T, Ctx>,
  separator?: Parser<S, Ctx>
) => many_<S, T, Ctx>(1)(parser, separator)

/**
 * Creates a parser that matches at least n occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @param n - Number of required repetitions
 * @returns A parser that produces an array of at least n matches
 */
export const manyN = <S, T, Ctx>(
  parser: Parser<T, Ctx>,
  n: number,
  separator?: Parser<S, Ctx>
) => many_<S, T, Ctx>(n)(parser, separator)

/**
 * Creates a parser that matches exactly n occurrences of the input parser.
 *
 * @param parser - The parser to repeat
 * @param n - Number of required repetitions
 * @param separator - Optional parser to match between occurrences
 * @returns A parser that produces an array of exactly n matches
 */

export const manyNExact = <S, T, Ctx>(
  parser: Parser<T, Ctx>,
  n: number,
  separator?: Parser<S, Ctx>
) =>
  Parser.gen(function* () {
    const results = yield* manyN(parser, n, separator)
    if (results.length !== n) {
      const message = `Expected exactly ${n} occurrences, but found ${results.length}`
      return yield* Parser.error<Ctx>(message)
    }
    return results
  })

/**
 * Internal helper function for creating skipping repetition parsers.
 *
 * @param count - Minimum number of repetitions required
 * @returns A function that creates a parser skipping multiple occurrences
 */
function skipMany_<T, Ctx>(count: number) {
  return (parser: Parser<T, Ctx>): Parser<undefined, Ctx> => {
    return new Parser(state => {
      let currentState = state
      let successes = 0

      while (true) {
        const { result, state: newState } = parser.run(currentState)
        if (Either.isLeft(result)) {
          break
        }
        
        // Check that parser advanced - prevent infinite loops
        if (newState.pos.offset <= currentState.pos.offset) {
          throw new Error("Parser did not advance - infinite loop prevented")
        }
        
        successes++
        currentState = newState as ParserState<Ctx>
      }

      if (successes >= count) {
        return Parser.succeed(undefined, currentState)
      }
      const message = `Expected at least ${count} occurrences, but only found ${successes}`
      return Parser.fail({ message, expected: [] }, state)
    })
  }
}

/**
 * Creates a parser that skips zero or more occurrences of the input parser.
 *
 * @param parser - The parser to skip
 * @returns A parser that skips all matches
 */
export const skipMany0 = <T, Ctx = {}>(parser: Parser<T, Ctx>) =>
  skipMany_<T, Ctx>(0)(parser)

/**
 * Creates a parser that skips one or more occurrences of the input parser.
 *
 * @param parser - The parser to skip
 * @returns A parser that skips all matches (requires at least one)
 */
export const skipMany1 = <T, Ctx>(parser: Parser<T, Ctx>) =>
  skipMany_<T, Ctx>(1)(parser)

/**
 * Creates a parser that skips exactly n occurrences of the input parser.
 *
 * @param parser - The parser to skip
 * @param n - Number of required repetitions to skip
 * @returns A parser that skips exactly n matches
 */
export const skipManyN = <T, Ctx>(parser: Parser<T, Ctx>, n: number) =>
  skipMany_<T, Ctx>(n)(parser)

/**
 * Creates a parser that skips input until the given parser succeeds.
 *
 * @param parser - The parser to look for
 * @returns A parser that skips input until a match is found
 */
export function skipUntil<T, Ctx = {}>(
  parser: Parser<T, Ctx>
): Parser<undefined, Ctx> {
  return new Parser(state => {
    let currentState = state

    while (!State.isAtEnd(currentState)) {
      const { result, state: newState } = parser.run(currentState)
      if (Either.isRight(result)) {
        return Parser.succeed(undefined, newState)
      }
      currentState = State.consume(currentState, 1)
    }

    return Parser.succeed(undefined, currentState)
  })
}

/**
 * Creates a parser that takes input until the given parser succeeds.
 *
 * @param parser - The parser to look for
 * @returns A parser that takes input until a match is found
 */
export function takeUntil<T, Ctx = {}>(
  parser: Parser<T, Ctx>
): Parser<string, Ctx> {
  return new Parser(state => {
    let currentState = state
    let collected = ""

    while (!State.isAtEnd(currentState)) {
      const { result, state: newState } = parser.run(currentState)
      if (Either.isRight(result)) {
        return Parser.succeed(collected, newState)
      }
      collected += currentState.remaining[0]
      currentState = State.consume(currentState, 1)
    }

    return Parser.succeed(collected, currentState)
  })
}

/**
 * Creates a parser that takes input until the given character is found.
 *
 * @param char - The character to look for
 * @returns A parser that takes input until the character is found
 */
export function parseUntilChar<Ctx = {}>(char: string): Parser<string, Ctx> {
  return new Parser(state => {
    if (char.length !== 1) {
      return Parser.fail(
        {
          message: "Incorrect usage of parseUntilChar parser.",
          expected: [char]
        },
        state
      )
    }
    let currentState = state
    let collected = ""

    while (!State.isAtEnd(currentState)) {
      if (currentState.remaining[0] === char) {
        return Parser.succeed(collected, currentState)
      }
      collected += currentState.remaining[0]
      currentState = State.consume(currentState, 1)
    }

    const message = `Expected character ${char} but found ${collected}`
    return Parser.fail({ message, expected: [char] }, currentState)
  })
}

/**
 * A parser that skips any number of space characters.
 */
export const skipSpaces = new Parser(
  state =>
    Parser.succeed(
      undefined,
      State.consumeWhile(state, char => char === " ")
    ),
  { name: "skipSpaces" }
)

/**
 * Creates a parser that tries multiple parsers in order until one succeeds.
 *
 * @param parsers - Array of parsers to try
 * @returns A parser that succeeds if any of the input parsers succeed
 */
export function or<Parsers extends Parser<any, any>[], Ctx = {}>(
  ...parsers: Parsers
): Parser<Parsers[number] extends Parser<infer T, Ctx> ? T : never, Ctx> {
  return new Parser(state => {
    // const expectedNames: string[] = []
    for (const parser of parsers) {
      const { result, state: newState } = parser.run(state)
      if (Either.isRight(result)) {
        return Parser.succeed(result.right, newState)
      }
      // if (parser.options?.name) {
      // 	expectedNames.push(parser.options.name)
      // }
    }

    const message = `None of the ${parsers.length} choices could be satisfied`
    return Parser.fail({ message }, state)
  })
}

/**
 * Creates a parser that optionally matches the input parser.
 * If the parser fails, returns undefined without consuming input.
 *
 * @param parser - The parser to make optional
 * @returns A parser that either succeeds with a value or undefined
 */
export function optional<T, Ctx = {}>(parser: Parser<T, Ctx>) {
  return new Parser((state: ParserState<Ctx>) => {
    const { result, state: newState } = parser.run(state)
    if (Either.isLeft(result)) {
      return Parser.succeed(undefined, state)
    }
    // return result
    return Parser.succeed(result.right, newState)
  })
}

type LastParser<T, Ctx = {}> =
  T extends [...any[], Parser<infer L, Ctx>] ? L : never

/**
 * Creates a parser that runs multiple parsers in sequence.
 * Returns the result of the last parser in the sequence.
 *
 * @param parsers - Array of parsers to run in sequence
 * @returns A parser that succeeds if all parsers succeed in sequence
 */
export function sequence<Parsers extends Parser<any>[], Ctx = {}>(
  parsers: [...Parsers]
): Parser<LastParser<Parsers, Ctx>, Ctx> {
  return new Parser((state: ParserState<Ctx>) => {
    let currentState = state
    let lastResult: any

    for (const parser of parsers) {
      const { result, state: newState } = parser.run(currentState)
      if (Either.isLeft(result)) {
        return { result: result as unknown as Either<LastParser<Parsers, Ctx>, ParseErrorBundle>, state: newState }
      }
      lastResult = result.right
      currentState = newState as ParserState<Ctx>
    }

    return Parser.succeed(lastResult, currentState) as any
  })
}

/**
 * Creates a parser that matches input against a regular expression.
 * The regex must match at the start of the input.
 *
 * @param re - The regular expression to match against
 * @returns A parser that matches the regex pattern
 */
export const regex = <Ctx = {}>(re: RegExp): Parser<string, Ctx> => {
  // Create a new RegExp without global flag to ensure consistent behavior
  const nonGlobalRe = new RegExp(re.source, re.flags.replace("g", ""))

  return new Parser(
    state => {
      const match = nonGlobalRe.exec(state.remaining)
      if (match && match.index === 0) {
        const value = match[0]
        return Parser.succeed(value, State.consume<Ctx>(state, value.length))
      }
      const message = `Expected ${re} but found ${state.remaining.slice(0, 10)}...`
      return Parser.fail(
        {
          message,
          expected: [re.toString()]
        },
        state
      )
    },
    { name: re.toString() }
  )
}

export function zip<A, B>(
  parserA: Parser<A>,
  parserB: Parser<B>
): Parser<[A, B]> {
  return parserA.zip(parserB)
}

export function then<A, B>(parserA: Parser<A>, parserB: Parser<B>): Parser<B> {
  return parserA.then(parserB)
}

export const zipRight = then

export function thenDiscard<A, B>(
  parserA: Parser<A>,
  parserB: Parser<B>
): Parser<A> {
  return parserA.thenDiscard(parserB)
}
export const zipLeft = thenDiscard

/**
 * Creates a parser that takes input until the given parser would succeed, without consuming the parser.
 *
 * @param parser - The parser to look for
 * @returns A parser that takes input until before a match would be found
 */
export function takeUpto<T>(parser: Parser<T>): Parser<string> {
  return new Parser(state => {
    let currentState = state
    let collected = ""

    while (!State.isAtEnd(currentState)) {
      const { result } = parser.run(currentState)
      if (Either.isRight(result)) {
        return Parser.succeed(collected, currentState)
      }
      collected += currentState.remaining[0]
      currentState = State.consume(currentState, 1)
    }

    return Parser.succeed(collected, currentState)
  })
}
</file>

</files>
